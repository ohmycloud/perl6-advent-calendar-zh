<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Perl 6 日历">
<meta name="keywords" content="perl6,example">
<title>Perl 6 Advent Calendar</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Perl 6 Advent Calendar</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_第一天_perl_6_鬼精灵_圣诞节实用指南">1. 第一天 – Perl 6 鬼精灵: 圣诞节实用指南</a>
<ul class="sectlevel2">
<li><a href="#_but_true_does_false">1.1. But True does False</a></li>
<li><a href="#_wrapping_it_up">1.2. Wrapping It Up</a></li>
<li><a href="#_看不见的斗篷">1.3. 看不见的斗篷</a></li>
<li><a href="#_ho_ho_ho">1.4. Ho-Ho-Ho</a></li>
<li><a href="#_结论">1.5. 结论</a></li>
</ul>
</li>
<li><a href="#_第二天_perl_6_符号_变量和容器">2. 第二天-Perl 6: 符号, 变量和容器</a>
<ul class="sectlevel2">
<li><a href="#_把钱拿出来">2.1. 把钱拿出来</a></li>
<li><a href="#_我们祝你有一个愉快的列表圣诞">2.2. 我们祝你有一个愉快的列表圣诞</a></li>
<li><a href="#_thats_your_assignment">2.3. That&#8217;s Your Assignment</a></li>
<li><a href="#_positionlly">2.4. Position@lly</a></li>
<li><a href="#_the_one_and_only">2.5. The One and Only</a></li>
<li><a href="#_decont">2.6. Decont</a></li>
<li><a href="#_不要让它溜走">2.7. 不要让它溜走</a></li>
<li><a href="#_i_want_less">2.8. I Want Less</a></li>
<li><a href="#_defaulting_on_default_defaults">2.9. Defaulting on Default Defaults</a></li>
<li><a href="#_自定义">2.10. 自定义</a></li>
<li><a href="#_这就是全部伙计">2.11. 这就是全部，伙计</a></li>
<li><a href="#_结论_2">2.12. 结论</a></li>
</ul>
</li>
<li><a href="#_第三天_letterops_with_perl6">3. 第三天 – LetterOps with Perl6</a>
<ul class="sectlevel2">
<li><a href="#_规模">3.1. 规模</a></li>
<li><a href="#_markdown_来拯救">3.2. Markdown 来拯救</a></li>
<li><a href="#_使用_perl_6_处理_markdown">3.3. 使用 Perl 6 处理 Markdown</a></li>
<li><a href="#_需要更多的结构">3.4. 需要更多的结构</a></li>
<li><a href="#_这里的玩具是重要的">3.5. 这里的玩具是重要的</a></li>
<li><a href="#_还没有">3.6. 还没有</a></li>
<li><a href="#_包起来">3.7. 包起来</a></li>
</ul>
</li>
<li><a href="#_第四天_使用_grammars_进行解析">4. 第四天-使用 Grammars 进行解析</a>
<ul class="sectlevel2">
<li><a href="#_理解_grammars">4.1. 理解 Grammars</a></li>
<li><a href="#_递归下降分析法和优先级">4.2. 递归下降分析法和优先级</a></li>
<li><a href="#_左递归和其他陷阱">4.3. 左递归和其他陷阱</a></li>
<li><a href="#_始于简单">4.4. 始于简单</a></li>
<li><a href="#_组装完整的_grammars">4.5. 组装完整的 Grammars</a></li>
<li><a href="#_调试_grammars">4.6. 调试 Grammars</a></li>
<li><a href="#_解析空白和注释">4.7. 解析空白和注释</a></li>
<li><a href="#_保存状态">4.8. 保存状态</a></li>
<li><a href="#_使用动态变量实现词法作用域">4.9. 使用动态变量实现词法作用域</a></li>
<li><a href="#_总结">4.10. 总结</a></li>
<li><a href="#_解构_json">4.11. 解构 JSON</a></li>
<li><a href="#_在块儿中使用签名">4.12. 在块儿中使用签名</a></li>
<li><a href="#_你甚至可以解构对象">4.13. 你甚至可以解构对象!</a></li>
<li><a href="#_结论_3">4.14. 结论</a></li>
</ul>
</li>
<li><a href="#_第六天_perl_6_书籍">5. 第六天-Perl 6 书籍</a></li>
<li><a href="#_第七天_测试所有的东西">6. 第七天 – 测试所有的东西</a>
<ul class="sectlevel2">
<li><a href="#_it_depends">6.1. It depends…</a></li>
<li><a href="#_懒惰和不耐烦">6.2. 懒惰和不耐烦</a></li>
<li><a href="#_晾干">6.3. 晾干</a></li>
</ul>
</li>
<li><a href="#_第八天_adventures_in_nqp_land_hacking_the_rakudo_compiler">7. 第八天 - Adventures in NQP Land: Hacking the Rakudo Compiler</a>
<ul class="sectlevel2">
<li><a href="#_背景">7.1. 背景</a></li>
<li><a href="#_not_quite_perl_nqp">7.2. Not Quite Perl (NQP)</a></li>
<li><a href="#_进入战壕">7.3. 进入战壕</a></li>
<li><a href="#_工作区和工具">7.4. 工作区和工具</a></li>
<li><a href="#_hacking">7.5. Hacking</a></li>
<li><a href="#_测试">7.6. 测试</a></li>
<li><a href="#_文档">7.7. 文档</a></li>
<li><a href="#_nqp_经验教训">7.8. NQP 经验教训</a></li>
<li><a href="#_成功">7.9. 成功！</a></li>
<li><a href="#_总结_2">7.10. 总结</a></li>
<li><a href="#_参考">7.11. 参考</a></li>
<li><a href="#_附录">7.12. 附录</a></li>
<li><a href="#_主要的_perl_6_pod_渲染器">7.13. 主要的 Perl 6 POD 渲染器</a></li>
</ul>
</li>
<li><a href="#_第九天_http_and_web_sockets_with_cro">8. 第九天 – HTTP and Web Sockets with Cro</a>
<ul class="sectlevel2">
<li><a href="#_响应式管道">8.1. 响应式管道</a></li>
<li><a href="#_http_服务器简单的方法">8.2. HTTP 服务器，简单的方法</a></li>
<li><a href="#_通向幸福的途径">8.3. 通向幸福的途径</a></li>
<li><a href="#_中间件变得更容易">8.4. 中间件变得更容易</a></li>
<li><a href="#_这只是一个供应链supply_chain">8.5. 这只是一个供应链(Supply chain)</a></li>
<li><a href="#_哦和websockets">8.6. 哦，和WebSockets？</a></li>
<li><a href="#_综上所述">8.7. 综上所述</a></li>
</ul>
</li>
<li><a href="#_第十天_wrapping_rats">9. 第十天 – Wrapping Rats</a></li>
<li><a href="#_第十一天_perl_6_中所有的星号">10. 第十一天-Perl 6 中所有的星号</a>
<ul class="sectlevel2">
<li><a href="#_1_乘法">10.1. 1. 乘法</a></li>
<li><a href="#_2_幂">10.2. 2. 幂</a></li>
<li><a href="#_3_零或多次重复">10.3. 3. 零或多次重复</a></li>
<li><a href="#_4_min_到_max_次重复">10.4. 4. Min 到 Max 次重复</a></li>
<li><a href="#_5_吞噬参数">10.5. 5. 吞噬参数</a></li>
<li><a href="#_6_吨吨吨吨吨吨吨">10.6. 6. 吨吨吨吨吨吨吨</a></li>
<li><a href="#_7_动态作用域">10.7. 7. 动态作用域</a></li>
<li><a href="#_8_编译变量">10.8. 8. 编译变量</a></li>
<li><a href="#_9_all_methods">10.9. 9. All methods</a></li>
<li><a href="#_10_whatever">10.10. 10. Whatever</a></li>
<li><a href="#_11_whatevercode">10.11. 11. WhateverCode</a></li>
<li><a href="#_作业">10.12. 作业</a></li>
<li><a href="#_附加题">10.13. 附加题</a></li>
</ul>
</li>
<li><a href="#_第十二天_the_year_of_perl_6_books">11. 第十二天 – The Year of Perl 6 Books</a></li>
<li><a href="#_第十三天_使用_perl_6_挖掘维基百科">12. 第十三天 - 使用 Perl 6 挖掘维基百科</a>
<ul class="sectlevel2">
<li><a href="#_介绍">12.1. 介绍</a></li>
<li><a href="#_grammar_和_actions_难学吗">12.2. Grammar 和 Actions 难学吗?</a></li>
<li><a href="#_第一根火柴">12.3. 第一根火柴</a></li>
<li><a href="#_第二根火柴">12.4. 第二根火柴</a></li>
<li><a href="#_第三根火柴">12.5. 第三根火柴</a></li>
<li><a href="#_面向对象">12.6. 面向对象</a></li>
<li><a href="#_w_is_your_friend">12.7. &lt;|w&gt; is your friend</a></li>
</ul>
</li>
<li><a href="#_第十五天_带有_promise_的简单网络爬虫">13. 第十五天-带有 Promise 的简单网络爬虫</a>
<ul class="sectlevel2">
<li><a href="#_结论是">13.1. 结论是</a></li>
</ul>
</li>
<li><a href="#_第十六天_perl_6_性能改进">14. 第十六天-Perl 6 性能改进</a></li>
<li><a href="#_第十七天_关于消息传递">15. 第十七天-关于消息传递</a>
<ul class="sectlevel2">
<li><a href="#_为什么要传递消息">15.1. 为什么要传递消息</a></li>
<li><a href="#_传递什么信息">15.2. 传递什么信息</a></li>
<li><a href="#_强制性的你好世界">15.3. 强制性的你好，世界</a></li>
<li><a href="#_一些更有用的东西">15.4. 一些更有用的东西</a></li>
<li><a href="#_保持主题">15.5. 保持主题</a></li>
<li><a href="#_但是生命比amqp更重要">15.6. 但是，生命比AMQP更重要</a></li>
<li><a href="#_把它包起来">15.7. 把它包起来</a></li>
</ul>
</li>
<li><a href="#_第十八天_perl_6_支持的工作流">16. 第十八天-Perl 6 支持的工作流</a></li>
<li><a href="#_第十九天_language_independent_validation_rules_livr_for_perl6">17. 第十九天-Language Independent Validation Rules (LIVR) for Perl6</a>
<ul class="sectlevel2">
<li><a href="#_livr_介绍">17.1. LIVR 介绍</a></li>
<li><a href="#_livr和perl6">17.2. LIVR和Perl6</a></li>
<li><a href="#_livr_链接">17.3. LIVR 链接</a></li>
</ul>
</li>
<li><a href="#_第二十天_宏的进阶">18. 第二十天-宏的进阶</a></li>
<li><a href="#_第二十一天_数独与junctions和集合">19. 第二十一天-数独与Junctions和集合</a>
<ul class="sectlevel2">
<li><a href="#_junctions量子逻辑测试">19.1. Junctions：量子逻辑测试</a></li>
<li><a href="#_集合对象的集合">19.2. 集合：对象的集合</a></li>
<li><a href="#_关于对象的说明">19.3. 关于对象的说明</a></li>
</ul>
</li>
<li><a href="#_第二十二天_perl_6_d_的特性">20. 第二十二天-Perl 6.d 的特性</a>
<ul class="sectlevel2">
<li><a href="#_在创建时调整对象">20.1. 在创建时调整对象</a></li>
<li><a href="#_并发性改进">20.2. 并发性改进</a></li>
<li><a href="#_unicode_goodies">20.3. Unicode goodies</a></li>
<li><a href="#_跳过值">20.4. 跳过值</a></li>
<li><a href="#_of_bufs_and_blobs">20.5. Of Bufs and Blobs</a></li>
<li><a href="#_测试测试测试">20.6. 测试，测试，测试！</a></li>
<li><a href="#_这是怎么回事">20.7. 这是怎么回事</a></li>
<li><a href="#_main_函数">20.8. MAIN 函数</a></li>
<li><a href="#_嵌入_perl_6">20.9. 嵌入 Perl 6</a></li>
<li><a href="#_礼品袋的底部">20.10. 礼品袋的底部</a></li>
<li><a href="#_赶上雪橇的时间">20.11. 赶上雪橇的时间</a></li>
</ul>
</li>
<li><a href="#_第二十三天_perl_6_高尔夫">21. 第二十三天-Perl 6 高尔夫</a>
<ul class="sectlevel2">
<li><a href="#_一些基本的例子">21.1. 一些基本的例子</a></li>
<li><a href="#_numbers">21.2. Numbers</a></li>
<li><a href="#_条件">21.3. 条件</a></li>
<li><a href="#_打字很难让我们使用一些预定义的字符串">21.4. 打字很难，让我们使用一些预定义的字符串！</a></li>
<li><a href="#_base_16_base_36_nah_base_0x10ffff">21.5. Base 16? Base 36? Nah, Base 0x10FFFF!</a></li>
<li><a href="#_所有的好事都必须结束可怕的事情_更是如此">21.6. 所有的好事都必须结束;可怕的事情 - 更是如此</a></li>
</ul>
</li>
<li><a href="#_第二十四天_解魔方">22. 第二十四天-解魔方</a>
<ul class="sectlevel2">
<li><a href="#_介绍_2">22.1. 介绍</a></li>
<li><a href="#_符号">22.2. 符号</a></li>
<li><a href="#_算法">22.3. 算法</a></li>
<li><a href="#_设计一个模块">22.4. 设计一个模块</a></li>
<li><a href="#_代码">22.5. 代码</a></li>
</ul>
</li>
<li><a href="#_第二十五天_圣诞奖金_并发http服务器实施和scripter的方法">23. 第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</a>
<ul class="sectlevel2">
<li><a href="#_perl6_范式">23.1. Perl6 范式</a></li>
<li><a href="#_perl6_supplies_就像一个_v12_引擎">23.2. Perl6 Supplies 就像一个 V12 引擎</a></li>
<li><a href="#_wap6_的结构">23.3. Wap6 的结构</a></li>
<li><a href="#_wap6_的核心">23.4. Wap6 的核心</a></li>
<li><a href="#_webservices">23.5. Webservices</a></li>
<li><a href="#_当客户端请求静态文件时">23.6. 当客户端请求静态文件时</a></li>
<li><a href="#_结语">23.7. 结语</a></li>
</ul>
</li>
<li><a href="#_第一天_移植_vigilance将perl_6与标准工具集成在一起">24. 第一天 - 移植 Vigilance，将Perl 6与标准工具集成在一起</a>
<ul class="sectlevel2">
<li><a href="#_shebang_和导入">24.1. Shebang 和导入</a></li>
<li><a href="#_命令行选项">24.2. 命令行选项</a></li>
<li><a href="#_io_读写文件">24.3. IO: 读写文件</a></li>
<li><a href="#_获得md5校验和">24.4. 获得MD5校验和</a></li>
<li><a href="#_结束之前的思考">24.5. 结束之前的思考</a></li>
</ul>
</li>
<li><a href="#_第二天_like_6_perls_in_a_pod_document_everything">25. 第二天 – Like 6 Perls in a Pod: document everything</a></li>
<li><a href="#_大多数人都可以阅读源代码但每个人都可以阅读文档">大多数人都可以阅读源代码，但每个人都可以阅读文档。</a></li>
<li><a href="#_pod_6_stands_for_plain_old_documentation_for_perl_6">Pod 6 stands for “Plain Old documentation for Perl 6”</a></li>
<li><a href="#_给模块添加文档">给模块添加文档</a></li>
<li><a href="#_回到生产">回到生产</a>
<ul class="sectlevel1">
<li><a href="#_第三天_perl_6_跳转到那儿">26. 第三天 – Perl 6 – 跳转到那儿</a></li>
<li><a href="#_第四天_献给新年的_perl_6_pod_新功能">27. 第四天 - 献给新年的 Perl 6 Pod 新功能</a>
<ul class="sectlevel2">
<li><a href="#_介绍_3">27.1. 介绍</a></li>
<li><a href="#_准备">27.2. 准备</a></li>
<li><a href="#_背景_2">27.3. 背景</a></li>
<li><a href="#_rakudo_nqp_grammar_和_actions_学到的东西">27.4. Rakudo NQP grammar 和 actions: 学到的东西</a></li>
<li><a href="#_总结_3">27.5. 总结</a></li>
<li><a href="#_左还是右">27.6. 左还是右？</a></li>
<li><a href="#_参数">27.7. 参数</a></li>
<li><a href="#_动态范围">27.8. 动态范围</a></li>
<li><a href="#_宏里面的变量">27.9. 宏里面的变量</a></li>
</ul>
</li>
<li><a href="#_第六天_懒惰精灵与勤劳精灵">28. 第六天 - 懒惰精灵与勤劳精灵</a>
<ul class="sectlevel2">
<li><a href="#_lazy_slack">28.1. Lazy slack</a></li>
<li><a href="#_尽力追赶">28.2. 尽力追赶</a></li>
<li><a href="#_use_the_right_elf">28.3. Use the right elf</a></li>
</ul>
</li>
<li><a href="#_第七天_细胞自动机">29. 第七天 – 细胞自动机</a>
<ul class="sectlevel2">
<li><a href="#_为学习而做">29.1. 为学习而做</a></li>
<li><a href="#_走在前面">29.2. 走在前面</a></li>
<li><a href="#_制作东西">29.3. 制作东西</a></li>
<li><a href="#_改变">29.4. 改变</a></li>
<li><a href="#_改变邻居">29.5. 改变邻居</a></li>
<li><a href="#_优化机会">29.6. 优化机会？</a></li>
<li><a href="#_其他变化">29.7. 其他变化？</a></li>
<li><a href="#_这有用吗">29.8. 这有用吗？</a></li>
</ul>
</li>
<li><a href="#_第八天_让你的_perl_6_grammar_紧凑一点">30. 第八天 — 让你的 Perl 6 grammar 紧凑一点</a>
<ul class="sectlevel2">
<li><a href="#_1_拆分_actions">30.1. 1.拆分 actions</a></li>
<li><a href="#_使用_multi_方法">30.2. 使用 multi 方法</a></li>
<li><a href="#_3_让_perl_完成这项工作">30.3. 3. 让 Perl 完成这项工作</a></li>
<li><a href="#_4_使用_multi_rules_和_multi_tokens">30.4. 4. 使用 multi-rules 和 multi-tokens</a></li>
</ul>
</li>
<li><a href="#_第九天_perl_6_中的常量">31. 第九天 - Perl 6 中的常量</a>
<ul class="sectlevel2">
<li><a href="#_如何制作一个常数">31.1. 如何制作一个常数</a></li>
<li><a href="#_从模块导出常量">31.2. 从模块导出常量</a></li>
<li><a href="#_在程序中使用模块">31.3. 在程序中使用模块</a></li>
<li><a href="#_最后对代码维护进行了一些注释">31.4. 最后，对代码维护进行了一些注释</a></li>
</ul>
</li>
<li><a href="#_第十天_跳转_开启你的工作流">32. 第十天 - 跳转, 开启你的工作流</a></li>
<li><a href="#_第十一天_使用_perl_6_测试你的时刻表">33. 第十一天 - 使用 Perl 6 测试你的时刻表</a></li>
<li><a href="#_第十二天_构建灵活的_grammar">34. 第十二天 - 构建灵活的 grammar</a></li>
<li><a href="#_第十三天_使用_cro_和_debian_从头构建_web_服务">35. 第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</a>
<ul class="sectlevel2">
<li><a href="#_安装_rakudo_perl6_编译器">35.1. 安装 Rakudo Perl6 编译器</a></li>
<li><a href="#_安装_cro_服务">35.2. 安装 Cro 服务</a></li>
<li><a href="#_cro_实战">35.3. Cro 实战</a></li>
<li><a href="#_总结_4">35.4. 总结</a></li>
</ul>
</li>
<li><a href="#_第十四天_使用_perl_6_设计小航天器">36. 第十四天 - 使用 Perl 6 设计(小)航天器</a>
<ul class="sectlevel2">
<li><a href="#_寻找共同点">36.1. 寻找共同点</a></li>
<li><a href="#_asn_1_和限制">36.2. <code>ASN.1</code> 和限制</a></li>
<li><a href="#_逐步建设问题答案">36.3. 逐步建设。问题答案。</a></li>
</ul>
</li>
<li><a href="#_第十五天_使用_perl_6_构建小型航天器">37. 第十五天 - 使用 Perl 6 构建(小型)航天器</a>
<ul class="sectlevel2">
<li><a href="#_炫耀长耳朵">37.1. 炫耀长耳朵</a></li>
<li><a href="#_类型类型类型">37.2. 类型，类型，类型</a></li>
<li><a href="#_进步进化序列化">37.3. 进步，进化，序列化！</a></li>
<li><a href="#_如果有时间进行编码总会有时间进行解码">37.4. 如果有时间进行编码，总会有时间进行解码</a></li>
<li><a href="#_what_oclock_supply_oclock">37.5. What o’clock? Supply o’clock!</a></li>
</ul>
</li>
<li><a href="#_第十六天_检查你的列表俩次">38. 第十六天 - 检查你的列表俩次</a>
<ul class="sectlevel2">
<li><a href="#_从命令行了解_perl_6">38.1. 从命令行了解 Perl 6</a></li>
<li><a href="#_就像拔牙">38.2. 就像拔牙?</a></li>
<li><a href="#_一种强大的沉默的类型">38.3. 一种强大的，沉默的类型</a></li>
<li><a href="#_精灵类型不匹配_弥补改进的错误处理">38.4. 精灵类型不匹配 - 弥补改进的错误处理</a></li>
<li><a href="#_我们不会去直到我们得到一些">38.5. 我们不会去，直到我们得到一些！</a></li>
<li><a href="#_跑步者走上了这条路">38.6. 跑步者走上了这条路。</a></li>
</ul>
</li>
<li><a href="#_第17天_通往幸福的编译之路">39. 第17天 - 通往幸福的编译之路</a>
<ul class="sectlevel2">
<li><a href="#_marcus_junius_brute_forcethe_younger">39.1. Marcus Junius Brute Force（The Younger）</a></li>
<li><a href="#_我让路径遍历少了以及所有其他路径">39.2. 我让路径遍历少了（以及所有其他路径）</a></li>
<li><a href="#_在方程式中思考">39.3. 在方程式中思考</a></li>
<li><a href="#_第四语言">39.4. 第四语言</a></li>
<li><a href="#_结论_5">39.5. 结论</a></li>
</ul>
</li>
<li><a href="#_第十八天_一棵_avg_格式的圣诞树">40. 第十八天 - 一棵 AVG 格式的圣诞树</a>
<ul class="sectlevel2">
<li><a href="#_关于svg并创建它">40.1. 关于SVG并创建它</a></li>
<li><a href="#_我们抽象吧">40.2. 我们抽象吧！</a></li>
<li><a href="#_让我们延伸">40.3. 让我们延伸！</a></li>
<li><a href="#_一个重构点">40.4. 一个重构点</a></li>
<li><a href="#_一个进一步的抽象">40.5. 一个进一步的抽象</a></li>
<li><a href="#_最后是我们的树">40.6. 最后是我们的树</a></li>
</ul>
</li>
<li><a href="#_第十九天_交互式桌面应用">41. 第十九天 - 交互式桌面应用</a>
<ul class="sectlevel2">
<li><a href="#_骰子滚动">41.1. 骰子滚动</a></li>
<li><a href="#_简单的_gtksimple">41.2. 简单的 GTK::Simple</a></li>
<li><a href="#_网格布局">41.3. 网格布局</a></li>
<li><a href="#_交互">41.4. 交互</a></li>
<li><a href="#_把它们放在一起">41.5. 把它们放在一起</a></li>
<li><a href="#_最后的想法">41.6. 最后的想法</a></li>
</ul>
</li>
<li><a href="#_第二十天_perl_6_中的命题组合">42. 第二十天 - Perl 6 中的命题组合</a></li>
</ul>
</li>
<li><a href="#_你如何以数学方式包装礼物">你如何以数学方式包装礼物？</a>
<ul class="sectlevel2">
<li><a href="#_一个立方体卡罗尔">.1. 一个立方体卡罗尔</a></li>
<li><a href="#_sat_a_clause的令人满意的故事">.2. SAT-a-Clause的令人满意的故事</a></li>
<li><a href="#_比你想知道的3d礼品包装更多">.3. 比你想知道的3D礼品包装更多</a></li>
</ul>
</li>
<li><a href="#_把它包起来_2">把它包起来</a>
<ul class="sectlevel1">
<li><a href="#_第二十一天_一个红色的圣诞老人">43. 第二十一天 - 一个红色的圣诞老人</a></li>
<li><a href="#_第二十二天_测试_cro_http_api">44. 第二十二天 - 测试 Cro HTTP API</a>
<ul class="sectlevel2">
<li><a href="#_测试cro_http_api">44.1. 测试Cro HTTP API</a></li>
</ul>
</li>
<li><a href="#_第二十三天_blin很快就到圣诞节了">45. 第二十三天 - Blin，很快就到圣诞节了！</a>
<ul class="sectlevel2">
<li><a href="#_git_bisect_和二分法查找">45.1. <code>git bisect</code> 和二分法查找</a></li>
<li><a href="#_问题跳过">45.2. 问题❶：跳过</a></li>
<li><a href="#_问题构建时间">45.3. 问题❷：构建时间</a></li>
<li><a href="#_bisectable">45.4. Bisectable</a></li>
<li><a href="#_存储">45.5. 存储</a></li>
<li><a href="#_更多机器人更好">45.6. 更多机器人，更好</a></li>
<li><a href="#_好的现在怎么样">45.7. 好的，现在怎么样？</a></li>
<li><a href="#_是的blin">45.8. 是的，Blin！</a></li>
<li><a href="#_blin_项目_重新发明了_toasting">45.9. Blin 项目- 重新发明了 Toasting</a></li>
<li><a href="#_未来">45.10. 未来</a></li>
</ul>
</li>
<li><a href="#_第二十四天_使用_perl_6_进行主题建模">46. 第二十四天 - 使用 Perl 6 进行主题建模</a>
<ul class="sectlevel2">
<li><a href="#_介绍_4">46.1. 介绍</a></li>
<li><a href="#_建模报价">46.2. 建模报价</a></li>
<li><a href="#_结论_6">46.3. 结论</a></li>
<li><a href="#_引文_2">46.4. 引文</a></li>
<li><a href="#_友善的数字">46.5. 友善的数字</a></li>
<li><a href="#_factorion">46.6. Factorion</a></li>
<li><a href="#_循环数">46.7. 循环数</a></li>
<li><a href="#_快乐的数字">46.8. 快乐的数字</a></li>
<li><a href="#_摘要">46.9. 摘要</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_第一天_perl_6_鬼精灵_圣诞节实用指南">1. 第一天 – Perl 6 鬼精灵: 圣诞节实用指南</h2>
<div class="sectionbody">
<div class="paragraph">
<p>看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Perl 6 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！</p>
</div>
<div class="paragraph">
<p>但是等一下&#8230;&#8203; 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的"圣诞"上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！</p>
</div>
<div class="paragraph">
<p>欢迎来到 2017 年的 Perl 6 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Perl6 的博客推送到你面前。</p>
</div>
<div class="paragraph">
<p>今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！</p>
</div>
<div class="sect2">
<h3 id="_but_true_does_false">1.1. But True does False</h3>
<div class="paragraph">
<p>你听过 <code>but</code> 操作符吗？一个好玩的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-nb">True</span> <span class="tok-k">but</span> <span class="tok-nb">False</span> ?? <span class="tok-s">&#39;Tis true&#39;</span> !! <span class="tok-s">&#39;Tis false&#39;</span>;
<span class="tok-c1"># OUTPUT: «Tis false␤»</span>

<span class="tok-k">my</span>  <span class="tok-nv">$n</span> = <span class="tok-mi">42</span> <span class="tok-k">but</span> <span class="tok-s">&#39;forty two&#39;</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$n</span>;     <span class="tok-c1"># OUTPUT: «forty two␤»</span>
<span class="tok-nb">say</span> <span class="tok-nv">$n</span> + <span class="tok-mi">7</span>; <span class="tok-c1"># OUTPUT: «49␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-mi">42</span> <span class="tok-k">but</span> <span class="tok-k">role</span> <span class="tok-n">Evener</span> {
    <span class="tok-k">method</span> <span class="tok-n">is-even</span> { <span class="tok-k">self</span> %% <span class="tok-mi">2</span> }
}
<span class="tok-nb">say</span> <span class="tok-nv">$n</span>.<span class="tok-n">is-even</span>; <span class="tok-c1"># OUTPUT: «True␤»</span>
<span class="tok-nb">say</span> <span class="tok-nv">$n</span>.^<span class="tok-nb">name</span>;   <span class="tok-c1"># OUTPUT: «Int+{Evener}␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的前俩个例子中的那些不是 roles。<code>but</code> 操作符有种便捷的写法：如果 but 右边的东西不是 role，它就会给你创建一个！那个 role 只会有一个方法，以右侧对象的 <code>^name</code> 命名，并且那个方法只会简单地返回那个给定的对象。因此，这&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">put</span> <span class="tok-nb">True</span> <span class="tok-k">but</span> <span class="tok-s">&#39;some boolean&#39;</span>; <span class="tok-c1"># OUTPUT: «some boolean␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">put</span> <span class="tok-nb">True</span> <span class="tok-k">but</span> <span class="tok-k">role</span> {
    <span class="tok-k">method</span> ::(<span class="tok-k">BEGIN</span> <span class="tok-s">&#39;some boolean&#39;</span>.^<span class="tok-nb">name</span>) {
        <span class="tok-s">&#39;some boolean&#39;</span>
    }
} <span class="tok-c1"># OUTPUT: «some boolean␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.^name</code> 在我们的字符串上返回 <code>Str</code>， 因为它是一个 <code>Str</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-s">&#39;some boolean&#39;</span>.^<span class="tok-nb">name</span>;  <span class="tok-c1"># OUTPUT: «Str␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所以那个 role 提供了一个叫做 <code>Str</code> 的方法, 在非 <code>Str</code> 对象上调用该方法以获取字符串值的输出, 使我们的布尔值变成修改过的字符串化的表示。</p>
</div>
<div class="paragraph">
<p>举个例子，字符串 <code>0</code> 在 Rakudo Perl 6 中是 <code>True</code> 但是在 Perl 5 中是 <code>False</code>。使用 <code>but</code> 操作符, 我们能修改字符串的行为，让它表现的像 Perl 5 版本那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">role</span> <span class="tok-n">Perl5Str</span> {
    <span class="tok-k">method</span> <span class="tok-nb">Bool</span> {
        <span class="tok-nb">nextsame</span> <span class="tok-k">unless</span> <span class="tok-k">self</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;0&#39;</span>;
        <span class="tok-nb">False</span>
    }
}
<span class="tok-k">sub</span> <span class="tok-n">perlify</span> { <span class="tok-nv">$^v</span> <span class="tok-k">but</span> <span class="tok-n">Perl5Str</span> };

<span class="tok-nb">say</span> <span class="tok-o">so</span> <span class="tok-n">perlify</span> <span class="tok-s">&#39;meows&#39;</span>; <span class="tok-c1"># OUTPUT: «True␤»</span>
<span class="tok-nb">say</span> <span class="tok-o">so</span> <span class="tok-n">perlify</span> <span class="tok-s">&#39;0&#39;</span>;     <span class="tok-c1"># OUTPUT: «False␤»</span>
<span class="tok-nb">say</span> <span class="tok-o">so</span> <span class="tok-n">perlify</span> <span class="tok-s">&#39;&#39;</span>;      <span class="tok-c1"># OUTPUT: «False␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Perl5Str</code> 这个 role 提供了供 <code>so</code>  子例程调用的  <code>.Bool</code> 方法。在这个方法里面，我们使用 <code>nextsame</code> 子例程重新分派了原来的 <code>.Bool</code> 方法，除非那个字符串是 <code>0</code>, 那时我们仅仅返回 <code>False</code>。</p>
</div>
<div class="paragraph">
<p><code>but</code> 操作符有一个兄弟： <code>does</code> 中缀操作符。它们的行为相似，但是它不拷贝。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$o</span> = <span class="tok-k">class</span> { <span class="tok-k">method</span> <span class="tok-n">stuff</span> { <span class="tok-s">&#39;original&#39;</span> } }.<span class="tok-nb">new</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$o</span>.<span class="tok-n">stuff</span>;  <span class="tok-c1"># OUTPUT: «original␤»</span>

<span class="tok-nv">$o</span> <span class="tok-nb">does</span> <span class="tok-k">role</span> { <span class="tok-k">method</span> <span class="tok-n">stuff</span> { <span class="tok-s">&#39;modded&#39;</span> } };
<span class="tok-nb">say</span> <span class="tok-nv">$o</span>.<span class="tok-n">stuff</span>; <span class="tok-c1"># OUTPUT: «modded␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>程序中的某些东西是全局可访问的，而在有些实现（例如 Rakudo）中，某些常量被缓存了。这意味着我们可以在程序的不同部分变得很淘气，而那些圣诞节的庆祝者们甚至不知道发生了什么！</p>
</div>
<div class="paragraph">
<p>假如我们覆写了 <code>prompt</code> 子例程的读方法会怎么样？他们喜欢圣诞节？我们来给他们一些圣诞树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-vg">$*IN</span> <span class="tok-nb">does</span> <span class="tok-k">role</span> { <span class="tok-k">method</span> <span class="tok-n">get</span> { <span class="tok-s">&quot;🎄 {callsame} 🎄&quot;</span> } }

<span class="tok-k">my</span> <span class="tok-nv">$name</span> = <span class="tok-n">prompt</span> <span class="tok-s">&quot;Enter your name: &quot;</span>;
<span class="tok-nb">say</span> <span class="tok-s">&quot;You entered your name as: $name&quot;</span>;

<span class="tok-c1"># OUTPUT</span>
<span class="tok-c1"># Enter your name: (typed by user:) Zoffix Znet</span>
<span class="tok-c1"># You entered your name as: 🎄 Zoffix Znet 🎄</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>即使我们把代码粘贴到模块中该覆盖也会起作用。 我们也可以把它提升一个档次，弄乱枚举和缓存的常量，虽然这个顽皮的举动可能将无法跨越模块边界和其他特定实现的缓存失效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">True</span> <span class="tok-nb">does</span> <span class="tok-nb">False</span>;
<span class="tok-nb">say</span> <span class="tok-mi">42</span> ?? <span class="tok-s">&quot;tis true&quot;</span> !! <span class="tok-s">&quot;tis false&quot;</span>;
<span class="tok-c1"># OUTPUT: «tis true␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，这还没有达到想要的效果，但是让我们试着把我们的数字强制为 <code>Bool</code> 值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">True</span> <span class="tok-nb">does</span> <span class="tok-nb">False</span>;
<span class="tok-nb">say</span> <span class="tok-mi">42</span>.<span class="tok-nb">Bool</span> ?? <span class="tok-s">&quot;tis true&quot;</span> !! <span class="tok-s">&quot;tis false&quot;</span>;
<span class="tok-c1"># OUTPUT: «tis false␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们做到了！ 而现在，对于最后的格林奇 - 值得接触，我们将混淆数字计算的数值结果。 Rakudo 缓存 <code>Int</code> 常量。 当用不同类型的数字计算时，Infix <code>+</code> 运算符也使用 <a href="https://github.com/perl6/doc/issues/1690">internal-ish-ish</a> <code>.Bridge</code> 方法。 所以，让我们重写常量上的 <code>.Bridge</code> 来返回一些奇怪的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">BEGIN</span> <span class="tok-mi">42</span> <span class="tok-nb">does</span> <span class="tok-k">role</span> { <span class="tok-k">method</span> <span class="tok-n">Bridge</span> { <span class="tok-mf">12e0</span> } }
<span class="tok-nb">say</span> <span class="tok-mi">42</span> + <span class="tok-mi">15</span>;   <span class="tok-c1"># OUTPUT: «57␤»</span>
<span class="tok-nb">say</span> <span class="tok-mi">42</span> + <span class="tok-mf">15e0</span>; <span class="tok-c1"># OUTPUT: «27␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是善意的邪恶，肯定会毁了圣诞节，但这只是开始&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="_wrapping_it_up">1.2. Wrapping It Up</h3>
<div class="paragraph">
<p>没有包装的礼物，会是什么样的圣诞节？ 哦，对于礼物，我们将有 Perl 6 的 <a href="https://docs.perl6.org/type/Routine">Routine</a> 类型的 <a href="https://docs.perl6.org/routine/wrap">.wrap</a> 方法包装他们，哦，太好了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">soft</span>;
<span class="tok-k">sub</span> <span class="tok-n">foo</span> { <span class="tok-nb">say</span> <span class="tok-s">&#39;in foo&#39;</span> }
<span class="tok-nv">&amp;foo</span>.<span class="tok-n">wrap:</span> -&gt; | {
    <span class="tok-nb">say</span> <span class="tok-s">&#39;in the wrap&#39;</span>;
    <span class="tok-nb">callsame</span>;
    <span class="tok-nb">say</span> <span class="tok-s">&#39;back in the wrap&#39;</span>;
}
<span class="tok-n">foo</span>;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># in the wrap</span>
<span class="tok-c1"># in foo</span>
<span class="tok-c1"># back in the wrap</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <code>use soft</code> 编译指令来防止不必要的内联，否则这些内联会干扰我们的包装。然后，我们使用一个我们想要包装成一个名词的例程，通过它和 <code>＆</code> sigil 来使用它，并调用带有一个<a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a>的 <a href="https://docs.perl6.org/routine/wrap"><code>.wrap</code></a> 方法。</p>
</div>
<div class="paragraph">
<p>给定的 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 的签名必须与包装的例程（或其 <code>proto</code> 原型，如果它是一个 multi）兼容;否则我们将无法正确调度程序并使用参数调用包装器。在上面的例子中，我们只是使用匿名的 <a href="https://docs.perl6.org/type/Capture"><code>Capture</code></a>（<code>|</code>）来接受所有可能的参数。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 里面，我们有两个 <a href="https://docs.perl6.org/routine/say"><code>say</code></a> 调用，并使用 <a href="https://rakudo.party/post/Perl6-But-Heres-My-Dispatch-So-Callwith-Maybe">callsame</a> 例程来调用下一个可用的调度候选者，这正好是我们原来的例程。这很方便，因为我们试图在包装器中按照它的名字来调用 <code>foo</code> ，我们将从头开始调度，导致无限的调度循环。</p>
</div>
<div class="paragraph">
<p>既然方法是 <a href="https://docs.perl6.org/type/Routine">Routine</a>，我们也可以把它们包装起来。我们可以使用 <code>.^lookup</code> 元方法来获取 <a href="https://docs.perl6.org/type/Method"><code>Method</code></a> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">IO::Handle</span>.^<span class="tok-n">lookup</span>(<span class="tok-s">&#39;print&#39;</span>).<span class="tok-n">wrap:</span> <span class="tok-k">my</span> <span class="tok-k">method</span> (|<span class="tok-n">c</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">&amp;wrapee</span> = <span class="tok-n">nextcallee</span>;
    <span class="tok-n">wrapee</span> <span class="tok-k">self</span>, <span class="tok-s">&quot;🎄 Ho-ho-ho! 🎄\n&quot;</span>;
    <span class="tok-n">wrapee</span> <span class="tok-k">self</span>, |<span class="tok-n">c</span>
};

<span class="tok-nb">print</span> <span class="tok-s">&quot;Hello, World!\n&quot;</span>;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># 🎄 Ho-ho-ho! 🎄</span>
<span class="tok-c1"># Hello, World!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们从 <a href="https://docs.perl6.org/type/IO::Handle">IO::Handle</a> 类型中获取 <a href="https://docs.perl6.org/routine/print">.print</a> 方法，然后包装它。我们希望在方法内部使用 <code>self</code>，所以我们使用独立的方法（<code>my method …</code>）来代替块或子例程。我们想使用 <code>self</code> 的原因是能够调用我们包装的方法来打印我们的 Christmassy 消息。因为我们的方法是分离的，<a href="https://rakudo.party/post/Perl6-But-Heres-My-Dispatch-So-Callwith-Maybe">callwith</a> 和相关的例程将需要与其他参数一起自我馈送，以确保我们继续分派给正确的对象。</p>
</div>
<div class="paragraph">
<p>在 wrap 中，我们使用 <code>nextcallee</code> 例程来获得原始的方法。如果它是一个 <code>multi</code>，我们将得到 <code>proto</code>，而不是一个与原始参数最匹配的特定候选者，所以相比传统的例程，下一个 <a href="https://rakudo.party/post/Perl6-But-Heres-My-Dispatch-So-Callwith-Maybe#haveyoutriedtocallthemwith&#8230;&#8203;">candidate ordering</a> 候选排序在 wrap 中略有不同。我们把 <code>nextcallee</code> 放到一个变量中，因为我们想多次调用它，调用它将例程从调度栈中移出。在第一个调用中，我们打印了我们的 Christmass 信息，而在第二个调用中，我们只是 slip 我们的原始参数的 <a href="https://docs.perl6.org/type/Capture">Capture</a>（<code>|c</code>），完成了原来想要发生的调用。</p>
</div>
<div class="paragraph">
<p>感谢 <a href="https://docs.perl6.org/routine/wrap">.wrap</a>，我们可以改变甚至完全重新定义子程序和方法的行为，当你的朋友尝试使用它们的时候肯定会很快乐。哈哈哈！</p>
</div>
</div>
<div class="sect2">
<h3 id="_看不见的斗篷">1.3. 看不见的斗篷</h3>
<div class="paragraph">
<p>我们到目前为止所玩的技巧是非常可怕的，但它们太明显，太&#8230;&#8203;明显。 由于 Perl 6 具有极好的 Unicode 支持，所以我认为我们应该搜索大量的 Unicode 字符来获得一些有趣的恶作剧。 特别是，我们正在寻找不是空白的隐形字符。 我们的目的只有一个就足够了，但是这四个在我的电脑上是相当隐蔽的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>[⁠] <span class="tok-n">U</span><span class="tok-o">+</span><span class="tok-mi">2060</span> <span class="tok-n">WORD</span> <span class="tok-n">JOINER</span> [<span class="tok-n">Cf</span>]
[⁡] <span class="tok-n">U</span><span class="tok-o">+</span><span class="tok-mi">2061</span> <span class="tok-n">FUNCTION</span> <span class="tok-n">APPLICATION</span> [<span class="tok-n">Cf</span>]
[⁢] <span class="tok-n">U</span><span class="tok-o">+</span><span class="tok-mi">2062</span> <span class="tok-n">INVISIBLE</span> <span class="tok-n">TIMES</span> [<span class="tok-n">Cf</span>]
[⁣] <span class="tok-n">U</span><span class="tok-o">+</span><span class="tok-mi">2063</span> <span class="tok-n">INVISIBLE</span> <span class="tok-n">SEPARATOR</span> [<span class="tok-n">Cf</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 6 支持可以由任何字符组成的自定义术语和操作符，除了空格之外。 例如，这是我的专利耸肩操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">infix:</span><span class="tok-s">&lt;¯\(°_o)/¯&gt;</span> {
    (<span class="tok-nv">$^a</span>, <span class="tok-nv">$^b</span>).<span class="tok-nb">pick</span>
}

<span class="tok-nb">say</span> <span class="tok-s">&#39;Coke&#39;</span> ¯\(°<span class="tok-n">_o</span>)/¯ <span class="tok-s">&#39;Pepsi&#39;</span>;
<span class="tok-c1"># OUTPUT: «Pepsi␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个由非标识字符组成的术语（我们也可以在定义中使用真实的字符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">term:</span>«\<span class="tok-n">c</span>[<span class="tok-n">family:</span> <span class="tok-n">woman</span> <span class="tok-n">woman</span> <span class="tok-n">boy</span> <span class="tok-n">boy</span>]» {
    <span class="tok-s">&#39;♫ We— are— ♪ faaaamillyyy ♬&#39;</span>
}
<span class="tok-nb">say</span> 👩‍👩‍👦‍👦;
<span class="tok-c1"># OUTPUT: «♫ We— are— ♪ faaaamillyyy ♬»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用我们看不见的非空白字符，我们可以使无形的操作符和术语！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">infix:</span>«\<span class="tok-n">c</span>[<span class="tok-n">INVISIBLE</span> <span class="tok-n">TIMES</span>]» { <span class="tok-nv">$^a</span> × <span class="tok-nv">$^b</span> }
<span class="tok-k">my</span> \<span class="tok-n">r</span> = <span class="tok-mi">42</span>;

<span class="tok-nb">say</span> <span class="tok-s">&quot;Area of the circle is &quot;</span> ~ <span class="tok-n">π</span>⁢<span class="tok-n">r²</span>;
<span class="tok-c1"># OUTPUT: «Area of the circle is 5541.76944093239␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来创建一个 <code>Jolly</code> 模块，它将导出一些不可见的术语和操作符。 然后我们把它们撒在我们的 Christmassy朋友的代码中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">unit</span> <span class="tok-k">module</span> <span class="tok-n">Jolly</span>;

<span class="tok-k">sub</span>   <span class="tok-n">term:</span>«\<span class="tok-n">c</span>[<span class="tok-n">INVISIBLE</span> <span class="tok-n">TIMES</span>]» <span class="tok-k">is</span> <span class="tok-k">export</span> { <span class="tok-mi">42</span> }
<span class="tok-k">sub</span>  <span class="tok-n">infix:</span>«\<span class="tok-n">c</span>[<span class="tok-n">INVISIBLE</span> <span class="tok-n">TIMES</span>]» <span class="tok-k">is</span> <span class="tok-k">export</span> {
    <span class="tok-nv">$^a</span> × <span class="tok-nv">$^b</span>
}
<span class="tok-k">sub</span> <span class="tok-n">prefix:</span>«\<span class="tok-n">c</span>[<span class="tok-n">INVISIBLE</span> <span class="tok-n">SEPARATOR</span>]» (|)
    <span class="tok-k">is</span> <span class="tok-k">looser</span>(&amp;[,]) <span class="tok-k">is</span> <span class="tok-k">export</span>
{
    <span class="tok-nb">say</span> <span class="tok-s">&quot;Ho-ho-ho!&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们对术语和中缀操作符使用了相同的字符。 这很好，因为 Perl 6 对操作符有相当严格的期望，反之亦然，所以它会知道我们什么时候使用该术语或何时使用中缀操作符。 下面是由此产生的 Grinch 代码，以及它产生的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>⁣<span class="tok-nb">say</span> <span class="tok-mi">42</span>⁢⁢;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># 1764</span>
<span class="tok-c1"># Ho-ho-ho!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保调试的乐趣！ 以下是该行代码中的字符列表，供您查看我们使用隐形好东西的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>.<span class="tok-nb">say</span> <span class="tok-k">for</span> <span class="tok-s">&#39;⁣say 42⁢⁢;&#39;</span>.<span class="tok-n">uninames</span>;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># INVISIBLE SEPARATOR</span>
<span class="tok-c1"># LATIN SMALL LETTER S</span>
<span class="tok-c1"># LATIN SMALL LETTER A</span>
<span class="tok-c1"># LATIN SMALL LETTER Y</span>
<span class="tok-c1"># SPACE</span>
<span class="tok-c1"># DIGIT FOUR</span>
<span class="tok-c1"># DIGIT TWO</span>
<span class="tok-c1"># INVISIBLE TIMES</span>
<span class="tok-c1"># INVISIBLE TIMES</span>
<span class="tok-c1"># SEMICOLON</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ho_ho_ho">1.4. Ho-Ho-Ho</h3>
<div class="paragraph">
<p>圣诞节时的生产力下降到停滞状态。 人们心中都有节日和新年。 在所有代码中看到大量的 TODO 注释并不让我感到惊讶。 但是如果我们能够发现并投诉他们呢？ 只要有人感到懒惰，没有什么比 Grinch 更像编程了！</p>
</div>
<div class="paragraph">
<p>Perl 6 有俚语。 这是一个实验性的功能，目前还没有一个官方支持的接口，但是，对于我们的目的来说，它会做的很好。</p>
</div>
<div class="paragraph">
<p>使用俚语，可以在词法上改变 Perl 6 的文法，并引入语言特性和行为，就像 Perl 6 核心开发者一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">BEGIN</span> <span class="tok-vg">$*LANG</span>.<span class="tok-n">refine_slang:</span> <span class="tok-s">&#39;MAIN&#39;</span>,
    <span class="tok-k">role</span> <span class="tok-n">SomeExtraGrammar</span> {
        <span class="tok-k">token</span><span class="tok-n"> term:sym&lt;meow&gt;</span> {<span class="tok-sr"></span>
<span class="tok-sr">            &#39;This is not a syntax error&#39;</span>
<span class="tok-sr">        </span>}
    },
    <span class="tok-k">role</span> <span class="tok-n">SomeExtraActions</span> {
        <span class="tok-k">method</span> <span class="tok-n">EXPR</span> (<span class="tok-n">Mu</span> <span class="tok-vg">$/</span>) {
            <span class="tok-nb">say</span> <span class="tok-s">&quot;Parsed expression: &quot;</span> ~ <span class="tok-vg">$/</span>;
            <span class="tok-nb">nextsame</span>
        }
    }

<span class="tok-n">This</span> <span class="tok-k">is</span> <span class="tok-nb">not</span> <span class="tok-n">a</span> <span class="tok-n">syntax</span> <span class="tok-n">error</span>;
<span class="tok-nb">say</span> <span class="tok-s">&#39;hehe&#39;</span>

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># Parsed expression: This is not a syntax error</span>
<span class="tok-c1"># Parsed expression: &#39;hehe&#39;</span>
<span class="tok-c1"># Parsed expression: say &#39;hehe&#39;</span>
<span class="tok-c1"># hehe</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>俚语功能的“实验性”部分主要在于不得不依靠 <a href="https://github.com/rakudo/rakudo/blob/master/src/Perl6/Grammar.nqp">core Grammar</a> 和 <a href="https://github.com/rakudo/rakudo/blob/master/src/Perl6/Actions.nqp">core Actions</a> 的结构;目前没有官方保证这些将保持不变，这使得俚语变得脆弱。</p>
</div>
<div class="paragraph">
<p>对于我们调皮的 Grinchy 技巧，我们将修改注释的行为，如果我们读取代码来追踪调用 <a href="https://github.com/rakudo/rakudo/blob/79390147ac6b874f7c01c5818520cc5b31bde042/src/Perl6/Grammar.nqp#L700-L702">the comment token</a> 的代码，我们会发现它实际上是重新定义的 <a href="https://github.com/rakudo/rakudo/blob/79390147ac6b874f7c01c5818520cc5b31bde042/src/Perl6/Grammar.nqp#L652-L666">ws</a> token 的一部分，正如您可能从每天都知道的 Perl 6 文法除其他外，负责语法规则中的空白匹配。</p>
</div>
<div class="paragraph">
<p>这个问题稍微复杂一些，因为 <code>ws</code> 是一个基石标记，与 <code>comp_unit</code>，<code>statementlist</code> 和 <code>statement</code> 一起，它不能在 mainline（例程和块之外的代码）中修改。原因是在使用这些令牌的股票版本解析主线之后，俚语被加载。<code>statement</code>  token 内的标记甚至可以在 mainline 中更改，因为 <code>statement</code>  标记会 reblesses 文法，但是 <code>ws</code> 不会获得如此的奢侈。</p>
</div>
<div class="paragraph">
<p>既然我们已经开始深入到底了&#8230;&#8203;&#8230;&#8203;足够的话了！我们来写代码吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">BEGIN</span> <span class="tok-vg">$*LANG</span>.<span class="tok-n">refine_slang:</span> <span class="tok-s">&#39;MAIN&#39;</span>, <span class="tok-k">role</span> {
    <span class="tok-k">token</span><span class="tok-n"> comment:sym&lt;todo&gt;</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;#&#39; \s* &#39;TODO&#39; &#39;:&#39;? \s+ &lt;( \N*</span>
<span class="tok-sr">        </span>{ <span class="tok-k">die</span> <span class="tok-s">&quot;Ho-ho-ho! I think you were&quot;</span>
            ~ <span class="tok-s">&quot; meant to finish &quot;</span> ~ <span class="tok-vg">$/</span> }<span class="tok-sr"></span>
<span class="tok-sr">    </span>}
}

<span class="tok-k">sub</span> <span class="tok-n">business-stuff</span> {
    <span class="tok-c1"># TODO: business stuff</span>
}

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># ===SORRY!===</span>
<span class="tok-c1"># Ho-ho-ho! I think you were meant to finish business stuff</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <a href="https://docs.perl6.org/language/phasers">BEGIN phaser</a> 在编译时进行俚语修改，因为我们试图影响如何进一步编译。</p>
</div>
<div class="paragraph">
<p>我们添加了一个新的 <code>proto</code> 标记： <code>comment:sym&lt;todo&gt;</code> 到核心 Perl 6 文法，匹配类似于常规注释匹配的内容，除了它还寻找我们的 Christmassy 朋友决定离开的 <code>TODO</code>。 <code>\N*</code> 原子捕获用户在 <code>TODO</code> 之后键入的字符串，匹配捕获标记指示编译器将存储在 <code>$/</code> 变量中的匹配对象内的捕获文本中的以前匹配的东西排除在外。</p>
</div>
<div class="paragraph">
<p>在 token 的末尾，我们简单地使用一个代码块来告诉用户完成他们的 TODO 的消息。 很狡猾！</p>
</div>
<div class="paragraph">
<p>由于我们宁愿用户不注意我们的诡计，让我们将俚语粘贴到目标代码将要加载的模块中。 我们只是稍微调整一下原来的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># File: ./Jolly.pm6</span>
<span class="tok-k">sub</span> <span class="tok-n">EXPORT</span> {
    <span class="tok-vg">$*LANG</span>.<span class="tok-n">refine_slang:</span> <span class="tok-s">&#39;MAIN&#39;</span>, <span class="tok-k">role</span> {
        <span class="tok-k">token</span><span class="tok-n"> comment:sym&lt;todo&gt;</span> {<span class="tok-sr"></span>
<span class="tok-sr">            &#39;#&#39; \s* &#39;TODO&#39; &#39;:&#39;? \s+ &lt;( \N*</span>
<span class="tok-sr">            </span>{ <span class="tok-k">die</span> <span class="tok-s">&quot;Ho-ho-ho! I think you were&quot;</span>
                ~ <span class="tok-s">&quot; meant to finish &quot;</span> ~ <span class="tok-vg">$/</span> }<span class="tok-sr"></span>
<span class="tok-sr">        </span>}
    }

    <span class="tok-n">Map</span>.<span class="tok-nb">new</span>
}

<span class="tok-c1"># File: ./script.p6</span>
<span class="tok-k">use</span> <span class="tok-n">lib</span> &lt;.&gt;;
<span class="tok-k">use</span> <span class="tok-n">Jolly</span>;

<span class="tok-k">sub</span> <span class="tok-n">business-stuff</span> {
    <span class="tok-c1"># TODO: business stuff</span>
}

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># ===SORRY!===</span>
<span class="tok-c1"># Ho-ho-ho! I think you were meant to finish business stuff</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们希望俚语在脚本的编译时运行，而不是在模块中，所以我们删除了 <code>BEGIN</code> phaser，而是将代码固定在 <a href="https://docs.perl6.org/language/modules#index-entry-sub_EXPORT">sub EXPORT</a> 中，在脚本编译过程中使用该模块时运行。 <code>Map.new</code> 就是我喜欢在 <code>EXPORT</code>  sub 中写 <code>{}</code>，以表示我们不希望导出任何符号。 在我们的脚本中，我们现在只需要使用模块，俚语被激活。真棒！</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论">1.5. 结论</h3>
<div class="paragraph">
<p>今天，我们开始淘气的 Grinches 2017 年的 Perl 6 的降临日历和搞乱用户的程序。 我们使用 <code>but`和 `does</code> 操作符来改变对象。 包装的方法和子程序与我们的自定义例程，实现额外的功能。 做出隐形术语和操作符。 甚至突变语言本身来做我们的竞标。</p>
</div>
<div class="paragraph">
<p>在接下来的 23 天里，我们会看到更多的 Perl 6 Advent 文章，所以一定要回头看看。 也许，到这一切的尽头，我们的 Grinchy 心将长大三个尺寸&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>-Ofun</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_perl_6_符号_变量和容器">2. 第二天-Perl 6: 符号, 变量和容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对容器的基本理解对于在 Perl 6 中进行愉快的编程是至关重要的。它们无处不在，不仅影响你获得的变量类型，还决定了 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 和 <a href="https://docs.perl6.org/type/Map"><code>Map</code></a> 在迭代时的行为方式。</p>
</div>
<div class="paragraph">
<p>今天，我们将学习什么是容器，以及如何使用它们，但是首先，我希望你暂时忘记你对 Perl 6 的符号和变量的所有知识或怀疑，特别是如果你来自 Perl 5 的背景。 忘记一切。</p>
</div>
<div class="sect2">
<h3 id="_把钱拿出来">2.1. 把钱拿出来</h3>
<div class="paragraph">
<p>在 Perl 6 中，变量以 <code>$</code> 符号为前缀，用绑定运算符（<code>:=</code>）赋值。 像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$foo</span> := <span class="tok-mi">42</span>;
<span class="tok-nb">say</span> <span class="tok-s">&quot;The value is $foo&quot;</span>; <span class="tok-c1"># OUTPUT: «The value is 42␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你已经按照我的建议来忘记你所知道的一切，那么学习 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 和 <a href="https://docs.perl6.org/type/Hash"><code>Hash</code></a> 类型也是一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$ordered-things</span> := <span class="tok-s">&lt;foo bar ber&gt;</span>;
<span class="tok-k">my</span> <span class="tok-nv">$named-things</span>   := %(:<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-n">bar</span><span class="tok-s">&lt;ber&gt;</span>);

<span class="tok-nb">say</span> <span class="tok-s">&quot;$named-things&lt;foo&gt; bottles of $ordered-things[2] on the wall&quot;</span>;
<span class="tok-c1"># OUTPUT: «42 bottles of ber on the wall␤»</span>

.<span class="tok-nb">say</span> <span class="tok-k">for</span> <span class="tok-nv">$ordered-things</span>;  <span class="tok-c1"># OUTPUT: «foo␤bar␤ber␤»</span>
.<span class="tok-nb">say</span> <span class="tok-k">for</span> <span class="tok-nv">$named-things</span>;    <span class="tok-c1"># OUTPUT: «bar =&gt; ber␤foo =&gt; 42␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>了解这一点，你可以写出各种各样的程序，所以如果你开始觉得有太多的东西需要学习，记住你不需要一次学习所有东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们祝你有一个愉快的列表圣诞">2.2. 我们祝你有一个愉快的列表圣诞</h3>
<div class="paragraph">
<p>让我们试着用我们的变量做更多的事情。 想要更改列表中的值并不罕见。 到目前为止我们的表现如何呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$list</span> := (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>);
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] := <span class="tok-mi">100</span>;
<span class="tok-c1"># OUTPUT: «Cannot use bind operator with this left-hand side […] »</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管我们可以绑定到变量，但是如果我们试图绑定到某个值，我们会得到一个错误，无论这个值是来自 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 还是只是一个字面值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">1</span> := <span class="tok-mi">100</span>;
<span class="tok-c1"># OUTPUT: «Cannot use bind operator with this left-hand side […] »</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是为什么列表是不可变的。 然而，这是一个实现愿望的季节，所以我们希望有一个可变的<a href="https://docs.perl6.org/type/List"><code>List</code></a>！</p>
</div>
<div class="paragraph">
<p>我们需要掌握的是一个 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 对象，因为绑定操作符可以使用它。 顾名思义，一个 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 存储一个东西。 你不能通过 <a href="https://docs.perl6.org/routine/new"><code>.new</code></a> 方法实例化一个 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a>，但是我们可以通过声明一些词法变量来得到它们。 不需要费心给他们的名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$list</span> := (<span class="tok-k">my</span> $, <span class="tok-k">my</span> $, <span class="tok-k">my</span> $);
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] := <span class="tok-mi">100</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$list</span>; <span class="tok-c1"># OUTPUT: «(100 (Any) (Any))␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出中的 <code>(Any)</code> 是容器的默认值（稍后一点）。 上面，似乎我们设法在 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 创建后将一个值绑定到列表的元素上，我们不是吗？ 确实我们做了，但是&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$list</span> := (<span class="tok-k">my</span> $, <span class="tok-k">my</span> $, <span class="tok-k">my</span> $);
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] := <span class="tok-mi">100</span>;
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] := <span class="tok-mi">200</span>;
<span class="tok-c1"># OUTPUT: «Cannot use bind operator with this left-hand side […] »</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定操作用一个新的值（<code>100</code>）代替 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器，所以如果我们试图再次绑定，我们又回到了原来的方括号那个，试图绑定到一个值，而不是一个容器。</p>
</div>
<div class="paragraph">
<p>我们需要一个更好的工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_thats_your_assignment">2.3. That&#8217;s Your Assignment</h3>
<div class="paragraph">
<p>绑定运算符有一个表亲：赋值运算符（<code>=</code>）。 我们不用一个绑定操作符替换我们的 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器，而是使用赋值操作符来赋值或者“存储”我们在容器中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$list</span> := (<span class="tok-k">my</span> $ = <span class="tok-mi">1</span>, <span class="tok-k">my</span> $ = <span class="tok-mi">2</span>, <span class="tok-k">my</span> $ = <span class="tok-mi">3</span>);
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] = <span class="tok-mi">100</span>;
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] = <span class="tok-mi">200</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$list</span>;
<span class="tok-c1"># OUTPUT: «(200 2 3)␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以从一开始就指定我们的原始值，并且可以随时用其他值替换它们。 我们甚至可以变得时髦，并在每个容器上放置不同的类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$list</span> := (<span class="tok-k">my</span> <span class="tok-nb">Int</span> $ = <span class="tok-mi">1</span>, <span class="tok-k">my</span> <span class="tok-nb">Str</span> $ = <span class="tok-s">&#39;2&#39;</span>, <span class="tok-k">my</span> <span class="tok-nb">Rat</span> $ = <span class="tok-mf">3.0</span>);
<span class="tok-nv">$list</span>[<span class="tok-mi">0</span>] = <span class="tok-mi">100</span>; <span class="tok-c1"># OK!</span>
<span class="tok-nv">$list</span>[<span class="tok-mi">1</span>] = <span class="tok-mi">42</span>;  <span class="tok-c1"># Typecheck failure!</span>

<span class="tok-c1"># OUTPUT: «Type check failed in assignment;</span>
<span class="tok-c1">#    expected Str but got Int (42) […] »</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这有些放纵，但有一件事可以使用类型约束：<code>$list</code> 变量。 我们将其限制为 <a href="https://docs.perl6.org/type/Positional"><code>Positional</code></a> 角色，以确保它只能保持 <a href="https://docs.perl6.org/type/Positional"><code>Positional</code></a> 类型，就像 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 和 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nb">Positional</span> <span class="tok-nv">$list</span> := (<span class="tok-k">my</span> $ = <span class="tok-mi">1</span>, <span class="tok-k">my</span> $ = <span class="tok-s">&#39;2&#39;</span>, <span class="tok-k">my</span> $ = <span class="tok-mf">3.0</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>不知你咋想的，但是这对我来说看起来非常冗长。 幸运的是，Perl 6 有语法来简化它！</p>
</div>
</div>
<div class="sect2">
<h3 id="_positionlly">2.4. Position@lly</h3>
<div class="paragraph">
<p>首先，让我们摆脱变量的显式类型约束。 在 Perl 6 中，您可以使用 <code>@</code> 而不是 <code>$</code> 作为符号来表示您希望变量受到角色 <a href="https://docs.perl6.org/type/Positional"><code>Positional</code></a> 的类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@list</span> := <span class="tok-mi">42</span>;
<span class="tok-c1"># OUTPUT: «Type check failed in binding;</span>
<span class="tok-c1">#   expected Positional but got Int (42) […] »</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其次，我们将使用方括号来代替圆括号来存储我们的 <a href="https://docs.perl6.org/type/List"><code>List</code></a>。 这告诉编译器创建一个 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a> 而不是一个 <a href="https://docs.perl6.org/type/List"><code>List</code></a>。 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a>s 是可变的，它们将每个元素自动粘贴到 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器中，就像我们在前一节中手动操作一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@list</span> := [<span class="tok-mi">1</span>, <span class="tok-s">&#39;2&#39;</span>, <span class="tok-mf">3.0</span>];
<span class="tok-nv">@list</span>[<span class="tok-mi">0</span>] = <span class="tok-mi">100</span>;
<span class="tok-nv">@list</span>[<span class="tok-mi">0</span>] = <span class="tok-mi">200</span>;
<span class="tok-nb">say</span> <span class="tok-nv">@list</span>;
<span class="tok-c1"># OUTPUT: «[200 2 3]␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的代码变得更短了，但我们可以折腾更多的字符。 就像赋值给`$<code>-sigiled 变量而不是绑定一样，你可以赋值给</code>@` -sigiled 变量来获得一个自由的 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a>。 如果我们切换到赋值，我们可以完全摆脱方括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@list</span> = <span class="tok-mi">1</span>, <span class="tok-s">&#39;2&#39;</span>, <span class="tok-mf">3.0</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>好，简洁。</p>
</div>
<div class="paragraph">
<p>类似的想法背后是 <code>％</code> - 和 <code>&amp;</code> 符号化的变量。 <code>％</code> sigil 意味着 <a href="https://docs.perl6.org/type/Associative"><code>Associative</code></a> 角色的类型约束，并为赋值提供相同的快捷方式（给你一个 <a href="https://docs.perl6.org/type/Hash"><code>Hash</code></a>），并为这些值创建 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器。 对于角色 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 和赋值的 <code>＆</code>-sigiled变量类型 - 行为类似于 <code>$</code> sigils，给出一个可以修改其值的自由 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span>  <span class="tok-nv">%hash</span> = :<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-n">bar</span><span class="tok-s">&lt;ber&gt;</span>;
<span class="tok-nb">say</span> <span class="tok-nv">%hash</span>;  <span class="tok-c1"># OUTPUT: «{bar =&gt; ber, foo =&gt; 42}␤»</span>

<span class="tok-k">my</span> <span class="tok-nv">&amp;reversay</span> = <span class="tok-k">sub</span> { <span class="tok-nv">$^text</span>.<span class="tok-nb">flip</span>.<span class="tok-nb">say</span> }
<span class="tok-n">reversay</span> <span class="tok-s">&#39;6 lreP ♥ I&#39;</span>; <span class="tok-c1"># OUTPUT: «I ♥ Perl 6␤»</span>

<span class="tok-c1"># store a different Callable in the same variable</span>
<span class="tok-nv">&amp;reversay</span> = *.<span class="tok-nb">uc</span>.<span class="tok-nb">say</span>;  <span class="tok-c1"># a WhateverCode object</span>
<span class="tok-n">reversay</span> <span class="tok-s">&#39;I ♥ Perl 6&#39;</span>; <span class="tok-c1"># OUTPUT: «I ♥ PERL 6␤»</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_one_and_only">2.5. The One and Only</h3>
<div class="paragraph">
<p>之前我们知道赋值给 <code>$</code> -sigiled 变量会给你一个免费的 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器。 由于标量，顾名思义，只包含一个东西&#8230;&#8203;&#8230;&#8203;如果你把一个 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 放到 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 中会发生什么？ 毕竟，当你试图这样做的时候，宇宙仍然没有被扼杀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span>  <span class="tok-nv">$listish</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$listish</span>; <span class="tok-c1"># OUTPUT: «(1 2 3)␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的行为可能使 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 看起来似乎是一个用词不当，但它确实把整个列表视为一个东西。 我们可以通过几种方式观察其差异。 我们来比较绑定到 <code>$</code> -sigiled 变量的 <a href="https://docs.perl6.org/type/List"><code>List</code></a>（所以不包含 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a>）和赋值给 <code>$</code> -sigiled 变量（自动 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器）的 <a href="https://docs.perl6.org/type/List"><code>List</code></a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># Binding:</span>
<span class="tok-k">my</span>  <span class="tok-nv">$list</span> := (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$list</span>.<span class="tok-nb">perl</span>;
<span class="tok-nb">say</span> <span class="tok-s">&quot;Item: $_&quot;</span> <span class="tok-k">for</span> <span class="tok-nv">$list</span>;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># (1, 2, 3)</span>
<span class="tok-c1"># Item: 1</span>
<span class="tok-c1"># Item: 2</span>
<span class="tok-c1"># Item: 3</span>


<span class="tok-c1"># Assignment:</span>
<span class="tok-k">my</span> <span class="tok-nv">$listish</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$listish</span>.<span class="tok-nb">perl</span>;
<span class="tok-nb">say</span> <span class="tok-s">&quot;Item: $_&quot;</span> <span class="tok-k">for</span> <span class="tok-nv">$listish</span>;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># $(1, 2, 3)</span>
<span class="tok-c1"># Item: 1 2 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.perl6.org/routine/perl"><code>.perl</code></a> 方法给了我们一个额外的见解，并在第二个 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 之前显示了一个 <code>$</code>，以表明它在 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 中是集装箱化的。 更重要的是，当我们用 <code>for</code> 循环迭代我们的 <a href="https://docs.perl6.org/type/List"><code>List</code></a>s 时，第二个 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 结果只有一个迭代：整个 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 作为一个项目！ <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 没有辜负它的名字。</p>
</div>
<div class="paragraph">
<p>这种行为不仅仅是学术上的兴趣。 回想一下，<a href="https://docs.perl6.org/type/Array"><code>Array</code></a>s（和<a href="https://docs.perl6.org/type/Hash"><code>Hash</code></a>es）为它们的值创建<a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器。 这意味着如果我们嵌套东西，即使我们选择一个单独的列表或散列在里面存储着 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a>（或 <a href="https://docs.perl6.org/type/Hash"><code>Hash</code></a>），并试图迭代它，它将只被视为一个单一的项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@stuff</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>), %(:<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-mi">70</span><span class="tok-n">bar</span>);
<span class="tok-nb">say</span> <span class="tok-s">&quot;List Item: $_&quot;</span> <span class="tok-k">for</span> <span class="tok-nv">@stuff</span>[<span class="tok-mi">0</span>];
<span class="tok-nb">say</span> <span class="tok-s">&quot;Hash Item: $_&quot;</span> <span class="tok-k">for</span> <span class="tok-nv">@stuff</span>[<span class="tok-mi">1</span>];

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># List Item: 1 2 3</span>
<span class="tok-c1"># Hash Item: bar  70</span>
<span class="tok-c1"># foo 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的推理（即 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器中的列表和散列是单个项目）适用于当您试图压扁 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a> 的元素或将它们作为参数传递给 <a href="https://docs.perl6.org/type/Signature#index-entry-parameter_%2A%40-parameter_%2A%2525_slurpy_argument_%28Signature%29-Slurpy_%28A.K.A._Variadic%29_Parameters">slurpy</a> 参数时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@stuff</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>), %(:<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-mi">70</span><span class="tok-n">bar</span>);
<span class="tok-nb">say</span> <span class="tok-n">flat</span> <span class="tok-nv">@stuff</span>;
<span class="tok-c1"># OUTPUT: «((1 2 3) {bar =&gt; 70, foo =&gt; 42})␤»</span>

-&gt; *<span class="tok-nv">@args</span> { <span class="tok-nv">@args</span>.<span class="tok-nb">say</span> }(<span class="tok-nv">@stuff</span>)
<span class="tok-c1"># OUTPUT: «[(1 2 3) {bar =&gt; 70, foo =&gt; 42}]␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正是这种行为可以将 Perl 6 初学者推上墙，特别是那些来自 Perl 5 自动展平语言的人。然而，现在我们知道为什么会出现这种行为，我们可以改变它！</p>
</div>
</div>
<div class="sect2">
<h3 id="_decont">2.6. Decont</h3>
<div class="paragraph">
<p>如果 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器是罪魁祸首，我们所要做的就是删除它。 我们需要将我们的列表和哈希值去容器化，或者简称为 “decont”。 在你的 Perl 6 之旅中，你可以找到几种方法来完成这个工作，但是为此设计的一个方法就是 decont methodop（<code>&lt;&gt;</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@stuff</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>), %(:<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-mi">70</span><span class="tok-n">bar</span>);
<span class="tok-nb">say</span> <span class="tok-s">&quot;Item: $_&quot;</span> <span class="tok-k">for</span> <span class="tok-nv">@stuff</span>[<span class="tok-mi">0</span>]<span class="tok-s">&lt;&gt;;</span>
<span class="tok-s">say &quot;Item: $_&quot; for @stuff[1]&lt;&gt;</span>;

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># Item: 1</span>
<span class="tok-c1"># Item: 2</span>
<span class="tok-c1"># Item: 3</span>
<span class="tok-c1"># Item: bar   70</span>
<span class="tok-c1"># Item: foo   42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它很容易记住：它看起来像一个被挤压的盒子（一个被踩踏的容器）。 在通过索引到 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a> 中检索我们的容器化项目之后，我们附加了 decont 并从 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器中移除了内容，导致我们的循环遍历它们中的每个项目。</p>
</div>
<div class="paragraph">
<p>如果您希望一次去除 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a> 中的每个元素，只需使用超运算符（<code>»</code>，或 <code>&gt;&gt;</code>，如果您更喜欢使用 ASCII）就可以使用 decont：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@stuff</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>), %(:<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-mi">70</span><span class="tok-n">bar</span>);
<span class="tok-nb">say</span> <span class="tok-n">flat</span> <span class="tok-nv">@stuff</span>»<span class="tok-s">&lt;&gt;;</span>
<span class="tok-s"># OUTPUT: «(1 2 3 bar =&gt;</span> <span class="tok-mi">70</span> <span class="tok-n">foo</span> =&gt; <span class="tok-mi">42</span>)␤»

-&gt; *<span class="tok-nv">@args</span> { <span class="tok-nv">@args</span>.<span class="tok-nb">say</span> }(<span class="tok-nv">@stuff</span>»<span class="tok-s">&lt;&gt;)</span>
<span class="tok-s"># OUTPUT: «[1 2 3 bar =&gt;</span> <span class="tok-mi">70</span> <span class="tok-n">foo</span> =&gt; <span class="tok-mi">42</span>]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着容器被删除，我们的列表和散列就像我们想要的那样变平。 当然，我们可以避免使用 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a>，而将原始 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 绑定到变量上。 由于 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 没有把它们的元素放入容器，所以没有任何东西可以去除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@stuff</span> := (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>), %(:<span class="tok-mi">42</span><span class="tok-n">foo</span>, :<span class="tok-mi">70</span><span class="tok-n">bar</span>);
<span class="tok-nb">say</span> <span class="tok-n">flat</span> <span class="tok-nv">@stuff</span>;
<span class="tok-c1"># OUTPUT: «(1 2 3 bar =&gt; 70 foo =&gt; 42)␤»</span>

-&gt; *<span class="tok-nv">@args</span> { <span class="tok-nv">@args</span>.<span class="tok-nb">say</span> }(<span class="tok-nv">@stuff</span>)
<span class="tok-c1"># OUTPUT: «[1 2 3 bar =&gt; 70 foo =&gt; 42]␤»</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_不要让它溜走">2.7. 不要让它溜走</h3>
<div class="paragraph">
<p>当我们在这里的时候，值得注意的是，当他们想要执行decont（我们不是在传递参数给 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 的时候使用它）时，许多人使用 *slip*运算符（<code>|</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@stuff</span> = (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>), (<span class="tok-mi">4</span>, <span class="tok-mi">5</span>);
<span class="tok-nb">say</span> <span class="tok-s">&quot;Item: $_&quot;</span> <span class="tok-k">for</span> |<span class="tok-nv">@stuff</span>[<span class="tok-mi">0</span>];

<span class="tok-c1"># OUTPUT:</span>
<span class="tok-c1"># Item: 1</span>
<span class="tok-c1"># Item: 2</span>
<span class="tok-c1"># Item: 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然它可以完成工作，但可能会引入微妙的 bugs，这些 bug 可能很难追查到。 尝试在这里找到一个，在一个程序中迭代了一个无限的非负整数列表，并打印那些素数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$primes</span> = ^∞ .<span class="tok-n">grep:</span> *.<span class="tok-n">is-prime</span>;
<span class="tok-nb">say</span> <span class="tok-s">&quot;$_ is a prime number&quot;</span> <span class="tok-k">for</span> |<span class="tok-nv">$primes</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>放弃？ 这个程序会导致内存泄漏&#8230;&#8203; 非常缓慢。 尽管我们遍历了无限的项目列表，但这不是问题，因为 <a href="https://docs.perl6.org/routine/grep"><code>.grep</code></a> 方法返回的 <a href="https://docs.perl6.org/type/Seq"><code>Seq</code></a> 对象不会保留已经迭代的项目，因此内存使用永远不会增长。</p>
</div>
<div class="paragraph">
<p>有问题的部分是我们的 <code>|</code>  slip 操作符。 它将我们的 <a href="https://docs.perl6.org/type/Seq"><code>Seq</code></a> 转换成一个 <a href="https://docs.perl6.org/type/Slip"><code>Slip</code></a> ，这是一个 <a href="https://docs.perl6.org/type/List"><code>List</code></a> 类型，并且保存我们已经消耗的所有的值。 如果您希望在 <a href="http://hisham.hm/htop/"><code>htop</code></a> 中看到增长，那么这个程序的修改版本会更快地增长：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># CAREFUL! Don&#39;t consume all of your resources!</span>
<span class="tok-k">my</span> <span class="tok-nv">$primes</span> = ^∞ .<span class="tok-n">map:</span> *.<span class="tok-k">self</span>;
<span class="tok-n">Nil</span> <span class="tok-k">for</span> |<span class="tok-nv">$primes</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们再试一次，但是这次使用 decont 方法 op：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$primes</span> = ^∞ .<span class="tok-n">map:</span> *.<span class="tok-k">self</span>;
<span class="tok-n">Nil</span> <span class="tok-k">for</span> <span class="tok-nv">$primes&lt;&gt;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>内存使用现在是稳定的，程序可以坐在那里迭代直到时间结束。 当然，因为我们知道这是 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器导致的容器化，我们希望在这里避免它，所以我们可以简单地将 <a href="https://docs.perl6.org/type/Seq"><code>Seq</code></a> 绑定到变量上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$primes</span> := ^∞ .<span class="tok-n">map:</span> *.<span class="tok-k">self</span>;
<span class="tok-n">Nil</span> <span class="tok-k">for</span> <span class="tok-nv">$primes</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_i_want_less">2.8. I Want Less</h3>
<div class="paragraph">
<p>如果你讨厌符号，Perl 6 会得到一些你可以微笑的东西：无符号的变量。 只要在声明中加一个反斜杠的前缀，表示你不想要讨厌的符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> \<span class="tok-n">Δ</span> = <span class="tok-mi">42</span>;
<span class="tok-nb">say</span> <span class="tok-n">Δ²</span>; <span class="tok-c1"># OUTPUT: «1764␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你不会得到任何这样的变量的自由 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a>，因此，在声明期间，绑定或赋值给他们没有任何区别。 它们的行为类似于将值绑定到 <code>$</code> -sigiled 变量的行为，包括绑定 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a>s 并使变量可变：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> \<span class="tok-n">Δ</span> = <span class="tok-k">my</span> $ = <span class="tok-mi">42</span>;
<span class="tok-n">Δ</span> = <span class="tok-mi">11</span>;
<span class="tok-nb">say</span> <span class="tok-n">Δ²</span>; <span class="tok-c1"># OUTPUT: «121␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个更常见的地方，你可能会看到这样的变量是作为例程的参数，在这里，这意味着你想把 <code>is raw</code> trait 应用到参数上。 这在 <a href="https://docs.perl6.org/type/Signature#index-entry-%2B_%28Single_Argument_Rule_Slurpy%29"><code>+</code> positional slurpy</a> 参数的含义也是存在的（不需要反斜杠），如果它是 <code>is raw</code> 的，意味着你将不会得到不需要的 <a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a> 容器，因为它是一个 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a>，因为它具有 <code>@</code> sigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">sigiled</span> (<span class="tok-nv">$x</span> <span class="tok-k">is</span> <span class="tok-n">raw</span>, +<span class="tok-nv">@y</span>) {
    <span class="tok-nv">$x</span> = <span class="tok-mi">100</span>;
    <span class="tok-nb">say</span> <span class="tok-n">flat</span> <span class="tok-nv">@y</span>
}

<span class="tok-k">sub</span> <span class="tok-n">sigil-less</span> (\<span class="tok-o">x</span>, +<span class="tok-n">y</span>) {
    <span class="tok-o">x</span> = <span class="tok-mi">200</span>;
    <span class="tok-nb">say</span> <span class="tok-n">flat</span> <span class="tok-n">y</span>
}

<span class="tok-k">my</span> <span class="tok-nv">$x</span> = <span class="tok-mi">42</span>;
<span class="tok-n">sigiled</span>    <span class="tok-nv">$x</span>, (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>), (<span class="tok-mi">3</span>, <span class="tok-mi">4</span>); <span class="tok-c1"># OUTPUT: «((1 2) (3 4))␤»</span>
<span class="tok-nb">say</span> <span class="tok-nv">$x</span>;                        <span class="tok-c1"># OUTPUT: «100␤»</span>

<span class="tok-n">sigil-less</span> <span class="tok-nv">$x</span>, (<span class="tok-mi">1</span>, <span class="tok-mi">2</span>), (<span class="tok-mi">3</span>, <span class="tok-mi">4</span>); <span class="tok-c1"># OUTPUT: «(1 2 3 4)␤»</span>
<span class="tok-nb">say</span> <span class="tok-nv">$x</span>;                        <span class="tok-c1"># OUTPUT: «200␤»</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defaulting_on_default_defaults">2.9. Defaulting on Default Defaults</h3>
<div class="paragraph">
<p>容器提供的一个很棒的功能是默认值。 你可能听说过在 Perl 6 中，`Nil`表示缺少一个值，而不是一个值。 容器默认值就是它的作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$x</span> <span class="tok-k">is</span> <span class="tok-k">default</span>(<span class="tok-mi">42</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$x</span>;   <span class="tok-c1"># OUTPUT: «42␤»</span>

<span class="tok-nv">$x</span> = <span class="tok-mi">10</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$x</span>;   <span class="tok-c1"># OUTPUT: «10␤»</span>

<span class="tok-nv">$x</span> = <span class="tok-n">Nil</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$x</span>;   <span class="tok-c1"># OUTPUT: «42␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个容器的默认值是使用 <a href="https://docs.perl6.org/type/Variable#index-entry-trait_is_default_%28Variable%29-trait_is_default"><code>is default</code> trait</a> 给它的。 它的参数是在编译时计算的，每当容器缺少一个值时，就使用结果值。 由于 <code>Nil</code> 的工作是表明这一点，因此将 <code>Nil</code> 分配到容器中将导致容器包含其默认值，而不是 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>可以给 <a href="https://docs.perl6.org/type/Array"><code>Array</code></a> 和 <a href="https://docs.perl6.org/type/Hash"><code>Hash</code></a> 容器赋予默认值，如果你希望你的容器在字面上包含 <code>Nil</code>，当没有值时，只需要指定 <code>Nil</code> 作为默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@a</span> <span class="tok-k">is</span> <span class="tok-k">default</span><span class="tok-s">&lt;meow&gt;</span> = <span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-mi">3</span>;
<span class="tok-nb">say</span> <span class="tok-nv">@a</span>[<span class="tok-mi">0</span>, <span class="tok-mi">2</span>, <span class="tok-mi">42</span>]; <span class="tok-c1"># OUTPUT: «(1 3 meow)␤»</span>

<span class="tok-nv">@a</span>[<span class="tok-mi">0</span>]:<span class="tok-n">delete</span>;
<span class="tok-nb">say</span> <span class="tok-nv">@a</span>[<span class="tok-mi">0</span>];        <span class="tok-c1"># OUTPUT: «meow␤»</span>

<span class="tok-k">my</span> <span class="tok-nv">%h</span> <span class="tok-k">is</span> <span class="tok-k">default</span>(<span class="tok-n">Nil</span>) = :<span class="tok-n">bar</span><span class="tok-s">&lt;ber&gt;</span>;
<span class="tok-nb">say</span> <span class="tok-nv">%h&lt;bar foos&gt;</span>; <span class="tok-c1"># OUTPUT: «(ber Nil)␤»</span>

<span class="tok-nv">%h&lt;bar&gt;</span>:<span class="tok-n">delete</span>;
<span class="tok-nb">say</span> <span class="tok-nv">%h&lt;bar&gt;</span>       <span class="tok-c1"># OUTPUT: «Nil␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>容器的默认值有一个默认的默认值：容器上的显式类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$y</span>; <span class="tok-c1"># OUTPUT: «(Int)␤»</span>
<span class="tok-nb">say</span> <span class="tok-k">my</span> <span class="tok-n">Mu</span>  <span class="tok-nv">$z</span>; <span class="tok-c1"># OUTPUT: «(Mu)␤»</span>

<span class="tok-nb">say</span> <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$i</span> <span class="tok-k">where</span> *.<span class="tok-n">is-prime</span>; <span class="tok-c1"># OUTPUT: «(&lt;anon&gt;)␤»</span>
<span class="tok-nv">$i</span>.<span class="tok-nb">new</span>; <span class="tok-c1"># OUTPUT: (exception) «You cannot create […]»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有明确的类型约束，默认的默认值是一个 <a href="https://docs.perl6.org/type/Any"><code>Any</code></a> 类型的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-k">my</span> <span class="tok-nv">$x</span>;    <span class="tok-c1"># OUTPUT: «(Any)␤»</span>
<span class="tok-nb">say</span> <span class="tok-nv">$x</span> = <span class="tok-n">Nil</span>; <span class="tok-c1"># OUTPUT: «(Any)␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您可能在可选参数的例程签名中使用的默认值不是容器默认值，将 <code>Nil</code> 分配给子例程参数或分配给参数不会使用签名中的默认值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自定义">2.10. 自定义</h3>
<div class="paragraph">
<p>如果容器的标准行为不适合您的需求，您可以使用 <a href="https://docs.perl6.org/type/Proxy"><code>Proxy</code></a> 类型创建自己的容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$collector</span> := <span class="tok-k">do</span> {
    <span class="tok-k">my</span> <span class="tok-nv">@stuff</span>;
    <span class="tok-nb">Proxy</span>.<span class="tok-n">new:</span> :<span class="tok-n">STORE</span>{ <span class="tok-nv">@stuff</span>.<span class="tok-n">push:</span> <span class="tok-nv">@_</span>[<span class="tok-mi">1</span>] },
               :<span class="tok-n">FETCH</span>{ <span class="tok-nv">@stuff</span>.<span class="tok-n">join:</span> <span class="tok-s">&quot;|&quot;</span>   }
}

<span class="tok-nv">$collector</span> = <span class="tok-mi">42</span>;
<span class="tok-nv">$collector</span> = <span class="tok-s">&#39;meows&#39;</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$collector</span>; <span class="tok-c1"># OUTPUT: «42|meows␤»</span>

<span class="tok-nv">$collector</span> = <span class="tok-s">&#39;foos&#39;</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$collector</span>; <span class="tok-c1"># OUTPUT: «42|meows|foos␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接口有点笨重，但它完成了工作。我们使用 <a href="https://docs.perl6.org/routine/new"><code>.new</code></a> 方法创建 <a href="https://docs.perl6.org/type/Proxy"><code>Proxy</code></a> 对象，该方法需要两个必需的命名参数：<code>STORE</code> 和 <code>FETCH</code>，每个都带一个 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a>。</p>
</div>
<div class="paragraph">
<p>每当从容器中读取一个值时，<code>FETCH`<a href="https://docs.perl6.org/type/Callable">`Callable</code></a> 被调用，这可能比直接看到的次数多出现一次：在上面的代码中，当容器通过调度和例程这两个调用渗透时，<code>FETCH`<a href="https://docs.perl6.org/type/Callable">`Callable</code></a> 被调用10次。 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 被调用一个单一的位置参数：<a href="https://docs.perl6.org/type/Proxy"><code>Proxy</code></a> 对象本身。</p>
</div>
<div class="paragraph">
<p>无论何时将值存储到我们的容器中（例如，使用赋值运算符（<code>=</code>）），<code>STORE</code> <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 都会被调用。 <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 的第一个位置参数是 <a href="https://docs.perl6.org/type/Proxy"><code>Proxy</code></a> 对象本身，第二个参数是存储的值。</p>
</div>
<div class="paragraph">
<p>我们希望 <code>STORE</code> 和 <code>FETCH</code>  <a href="https://docs.perl6.org/type/Callable"><code>Callable</code></a> 共享 <code>@stuff</code> 变量，所以我们使用 <a href="https://docs.perl6.org/syntax/do"><code>do</code> statement prefix</a> 和一个代码块来很好地包含它。</p>
</div>
<div class="paragraph">
<p>我们将我们的 <a href="https://docs.perl6.org/type/Proxy"><code>Proxy</code></a> 绑定到一个变量，其余的只是正常的变量用法。输出显示我们的自定义容器提供的改变过的行为。</p>
</div>
<div class="paragraph">
<p>Proxies 也可以方便地作为返回值来提供具有可变属性的额外行为。例如，这里有一个属性，从外部看来只是一个正常的可变属性，但实际上强制它的值从 <a href="https://docs.perl6.org/type/Any"><code>Any</code></a> 任何类型变为 <a href="https://docs.perl6.org/type/Int"><code>Int</code></a> 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">Foo</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$!foo</span>;
    <span class="tok-k">method</span> <span class="tok-n">foo</span> {
        <span class="tok-nb">Proxy</span>.<span class="tok-n">new:</span> :<span class="tok-n">STORE</span>(-&gt; $, <span class="tok-nb">Int</span>() <span class="tok-nv">$!foo</span> { <span class="tok-nv">$!foo</span> }),
                   :<span class="tok-n">FETCH</span>{ <span class="tok-nv">$!foo</span> }
    }
}

<span class="tok-k">my</span> <span class="tok-nv">$o</span> = <span class="tok-n">Foo</span>.<span class="tok-nb">new</span>;
<span class="tok-nv">$o</span>.<span class="tok-n">foo</span> = <span class="tok-s">&#39; 42.1e0 &#39;</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$o</span>.<span class="tok-n">foo</span>; <span class="tok-c1"># OUTPUT: «42␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>很甜蜜！ 如果你想要一个更好的接口的 <a href="https://docs.perl6.org/type/Proxy"><code>Proxy</code></a> 与一些更多的功能，请检查 <a href="http://modules.perl6.org/dist/Proxee">Proxee</a> 模块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这就是全部伙计">2.11. 这就是全部，伙计</h3>
<div class="paragraph">
<p>那关于这一切。 在 Perl 6 中你将会看到的剩下的动物是 “twigils”：名称前带有两个符号的变量，但是就容器而言，它们的行为与我们所介绍的变量相同。 第二个符号只是表示附加信息，如变量是隐含的位置参数还是命名参数&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">test</span> { <span class="tok-nb">say</span> <span class="tok-s">&quot;$^implied @:parameters[]&quot;</span> }
<span class="tok-n">test</span> <span class="tok-s">&#39;meow&#39;</span>, :<span class="tok-n">parameters</span><span class="tok-s">&lt;says the cat&gt;</span>;
<span class="tok-c1"># OUTPUT: «meow says the cat␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;或者该变量是私有属性还是公共属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">with</span> <span class="tok-k">class</span> <span class="tok-n">Foo</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$!foo</span> = <span class="tok-mi">42</span>;
    <span class="tok-k">has</span> <span class="tok-nv">@.bar</span> = <span class="tok-mi">100</span>;
    <span class="tok-k">method</span> <span class="tok-n">what&#39;s-foo</span> { <span class="tok-nv">$!foo</span> }
}.<span class="tok-nb">new</span> {
    <span class="tok-nb">say</span> .<span class="tok-n">bar</span>;       <span class="tok-c1"># OUTPUT: «[100]␤»</span>
    <span class="tok-nb">say</span> .<span class="tok-n">what&#39;s-foo</span> <span class="tok-c1"># OUTPUT: «42␤»</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，这是另一天的旅程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_2">2.12. 结论</h3>
<div class="paragraph">
<p>Perl 6 有一个丰富的变量和容器系统，与 Perl 5 有很大的不同。理解它的工作方式是非常重要的，因为它会影响列表和哈希行为的迭代和展开方式。</p>
</div>
<div class="paragraph">
<p>赋值给变量提供了有价值的快捷方式，例如提供<a href="https://docs.perl6.org/type/Scalar"><code>Scalar</code></a>，<a href="https://docs.perl6.org/type/Array"><code>Array</code></a>或<a href="https://docs.perl6.org/type/Hash"><code>Hash</code></a> 容器，具体取决于符号。 如果您需要，绑定到变量允许您绕过这样的快捷方式。</p>
</div>
<div class="paragraph">
<p>在 Perl 6 中存在无符号变量，它们与具有绑定功能的 <code>$</code> -sigiled 变量具有相似的行为。 当用作参数时，这些变量的行为就像应用了 <code>is raw</code> trait一样。</p>
</div>
<div class="paragraph">
<p>最后，容器可以有默认值，可以创建自己的自定义容器，可以绑定到变量或从例程返回。</p>
</div>
<div class="paragraph">
<p>节日快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三天_letterops_with_perl6">3. 第三天 – LetterOps with Perl6</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_规模">3.1. 规模</h3>
<div class="paragraph">
<p>“规模！规模就是一切！“。</p>
</div>
<div class="paragraph">
<p>当圣诞老人的声音传到他们身上时，精灵散落在四面八方。</p>
</div>
<div class="paragraph">
<p>“这个 operation 是为三十四个孩子准备的？现在我们有无数的！大人也送信！“</p>
</div>
<div class="paragraph">
<p>小精灵 Buzzius 站了出来，喷出“但现在我们有电脑！”，又回到他精灵的追求。</p>
</div>
<div class="paragraph">
<p>“他们有什么好处？请告诉我，如果我仍然需要阅读每一封信，我该怎么办？“。</p>
</div>
<div class="paragraph">
<p>小精灵 Diodius 短暂地从藏身处抬起头，说：“告诉孩子们发一封文字信”。</p>
</div>
<div class="paragraph">
<p>圣诞老人停止了叫喊，并抓住了他有胡子的下巴。 “我可以做到这一点”。早期的儿童采用者就像这样发了一封信。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Dear</span> <span class="tok-n">Santa:</span> <span class="tok-n">I</span> <span class="tok-n">have</span> <span class="tok-n">been</span> <span class="tok-n">a</span> <span class="tok-n">good</span> <span class="tok-n">boy</span> <span class="tok-o">so</span> <span class="tok-n">I</span> <span class="tok-nb">want</span> <span class="tok-n">you</span> <span class="tok-nb">to</span> <span class="tok-n">bring</span> <span class="tok-n">me</span> <span class="tok-n">a</span> <span class="tok-n">collection</span> <span class="tok-k">of</span> <span class="tok-n">scythes</span> <span class="tok-o">and</span> <span class="tok-n">an</span> <span class="tok-n">ocean</span> <span class="tok-n">liner</span> <span class="tok-n">with</span> <span class="tok-n">a</span> <span class="tok-n">captain</span> <span class="tok-o">and</span> <span class="tok-n">a</span> <span class="tok-n">purser</span> <span class="tok-o">and</span> <span class="tok-n">a</span> <span class="tok-nb">time</span> <span class="tok-n">travel</span> <span class="tok-n">machine</span> <span class="tok-o">and</span> <span class="tok-n">instructions</span> <span class="tok-nb">to</span> <span class="tok-n">operate</span> <span class="tok-n">it</span> <span class="tok-o">and</span> <span class="tok-n">I</span> <span class="tok-n">know</span> <span class="tok-n">I</span> <span class="tok-n">haven&#39;t</span> <span class="tok-n">been</span> <span class="tok-o">so</span> <span class="tok-n">good</span> <span class="tok-n">at</span> <span class="tok-nb">times</span> <span class="tok-k">but</span> <span class="tok-n">that</span> <span class="tok-k">is</span> <span class="tok-n">why</span> <span class="tok-n">I&#39;m</span> <span class="tok-n">asking</span> <span class="tok-n">the</span> <span class="tok-nb">time</span> <span class="tok-n">machine</span> <span class="tok-o">so</span> <span class="tok-n">that</span> <span class="tok-n">I</span> <span class="tok-nb">can</span> <span class="tok-k">make</span> <span class="tok-n">it</span> <span class="tok-n">good</span> <span class="tok-o">and</span> <span class="tok-n">well</span> <span class="tok-o">and</span> <span class="tok-o">also</span> <span class="tok-n">find</span> <span class="tok-n">out</span> <span class="tok-n">what</span> <span class="tok-n">happened</span> <span class="tok-n">on</span> <span class="tok-n">July</span> <span class="tok-mi">13</span><span class="tok-n">th</span> <span class="tok-n">which</span> <span class="tok-n">I</span> <span class="tok-n">completely</span> <span class="tok-n">forgot</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>“我能做到吗？”。圣诞老人重复自己。他必须从单线混乱中提取一份礼物清单。例如，除以 <code>and</code>。</p>
</div>
<div class="paragraph">
<p>当然，使用 Perl 6 可以使用 <code>$þ</code> 作为变量，甚至可以<a href="https://en.wikipedia.org/wiki/Runic_(Unicode_block">使用</a>) <code>our $ᚣ= True</code> 作为标准，这是他最喜欢的语言。在一行中，您可以获得所有块，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>[ <span class="tok-s">&quot;Dear Santa: I have been a good boy so I want you to bring me a collection of scythes&quot;</span>, <span class="tok-s">&quot;an ocean liner with a captain&quot;</span>, <span class="tok-s">&quot;a purser&quot;</span>, <span class="tok-s">&quot;a time travel machine&quot;</span>, <span class="tok-s">&quot;instructions to operate it&quot;</span>, <span class="tok-s">&quot;I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good&quot;</span>, <span class="tok-s">&quot;well&quot;</span>, <span class="tok-s">&quot;also find out what happened on July 13th which I completely forgot.\n&quot;</span> ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>/\s* «and» \s*/</code> regexp 使用了 `and`s 并且移除了空格，创建了一组句子。这些句子可能包含或不包含客户希望圣诞老人带来的东西。这让圣诞老人又一次咆哮起来。 “规模和结构！我们需要扩展，我们需要结构！“</p>
</div>
</div>
<div class="sect2">
<h3 id="_markdown_来拯救">3.2. Markdown 来拯救</h3>
<div class="paragraph">
<p>“马修斯投了出来。”每个人都知道 <a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/">Markdown</a>。这是文字，为结构引入了几个标志。“</p>
</div>
<div class="paragraph">
<p>奥克斯正在努力晋升为第二级的精灵，他说。 “用Elvish-est的语言，榆树。你知道，这是精灵，但对于一封信“</p>
</div>
<div class="paragraph">
<p>“我可以做到这一点，”圣诞老人说。精灵喜欢他可以做的方法。所以他安装了所有东西，并做了这个小程序</p>
</div>
<div class="paragraph">
<p>圣诞老人安静了约 30 秒。然后再次听到了他的咆哮。</p>
</div>
<div class="paragraph">
<p>“永远，你听到我说话了吗？我从来不想再听到复活节兔子或其他邪恶生物的这种产卵。“</p>
</div>
<div class="paragraph">
<p>离屏幕最近的那些精灵观察到大量的红色，但不是很好的红色，没有任何类似于工作代码。所以他们给了鲁道夫一张便条（红红的鼻子驯鹿）一张便条，他用一只小鹿角忠实地扛着它。</p>
</div>
<div class="paragraph">
<p>“那么我们应该回到 Perl6 吗？”</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_perl_6_处理_markdown">3.3. 使用 Perl 6 处理 Markdown</h3>
<div class="paragraph">
<p>圣诞老人发现了 <code>Text::Markdown</code>，他立即安装了该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Text::Markdown</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它有Text，它有Markdown，它承诺处理它，这是他所需要的。所以他向他的客户群通报说，如果你希望这个人在你的烟囱里拿着一个装有好东西的麻袋，那么今年就需要降价了。</p>
</div>
<div class="paragraph">
<p>早期的采用者再一次回答了这个问题</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># Dear Santa</span>

<span class="tok-n">I</span> <span class="tok-n">have</span> <span class="tok-n">been</span> <span class="tok-n">a</span> <span class="tok-n">good</span> <span class="tok-n">boy</span> <span class="tok-o">so</span> <span class="tok-n">I</span> <span class="tok-nb">want</span> <span class="tok-n">you</span> <span class="tok-nb">to</span> <span class="tok-n">bring</span> <span class="tok-n">me</span> <span class="tok-n">a</span> <span class="tok-n">collection</span> <span class="tok-k">of</span>
<span class="tok-n">scythes</span> <span class="tok-o">and</span> <span class="tok-n">an</span> <span class="tok-n">ocean</span> <span class="tok-n">liner</span> <span class="tok-n">with</span> <span class="tok-n">a</span> <span class="tok-n">captain</span> <span class="tok-o">and</span> <span class="tok-n">a</span> <span class="tok-n">purser</span> <span class="tok-o">and</span> <span class="tok-n">a</span> <span class="tok-nb">time</span>
<span class="tok-n">travel</span> <span class="tok-n">machine</span> <span class="tok-o">and</span> <span class="tok-n">instructions</span> <span class="tok-nb">to</span> <span class="tok-n">operate</span> <span class="tok-n">it</span> <span class="tok-o">and</span> <span class="tok-n">I</span> <span class="tok-n">know</span> <span class="tok-n">I</span> <span class="tok-n">haven&#39;t</span>
<span class="tok-n">been</span> <span class="tok-o">so</span> <span class="tok-n">good</span> <span class="tok-n">at</span> <span class="tok-nb">times</span> <span class="tok-k">but</span> <span class="tok-n">that</span> <span class="tok-k">is</span> <span class="tok-n">why</span> <span class="tok-n">I&#39;m</span> <span class="tok-n">asking</span> <span class="tok-n">the</span> <span class="tok-nb">time</span> <span class="tok-n">machine</span> <span class="tok-o">so</span>
<span class="tok-n">that</span> <span class="tok-n">I</span> <span class="tok-nb">can</span> <span class="tok-k">make</span> <span class="tok-n">it</span> <span class="tok-n">good</span> <span class="tok-o">and</span> <span class="tok-n">well</span> <span class="tok-o">and</span> <span class="tok-o">also</span> <span class="tok-n">find</span> <span class="tok-n">out</span> <span class="tok-n">what</span> <span class="tok-n">happened</span> <span class="tok-n">on</span>
<span class="tok-n">July</span> <span class="tok-mi">13</span><span class="tok-n">th</span> <span class="tok-n">which</span> <span class="tok-n">I</span> <span class="tok-n">completely</span> <span class="tok-n">forgot</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，这是降价，是不是？这是妥善处理和所有。 “正确处理一封信很重要”，圣诞老人大声说道，大声说道，只是让鲁道夫惊呆了，鲁道夫是唯一一个挂着的人。 “它给结构。让我们检查一下信件是否有这个“。</p>
</div>
<div class="paragraph">
<p>“哇！”圣诞老人说。然后，“哇”。只需几行代码即可阅读并理解文档的结构，另一行则检查是否至少有一个是标题。如果是这样，它会表示真。这是真的。</p>
</div>
<div class="paragraph">
<p>圣诞老人很高兴一小会儿。他抓住了鲁道夫脖子的后背，这让他感到惊讶。然后他停止了这样做。鲁道夫抬起头来，只是稍微支撑了他的后腿，感到不快。</p>
</div>
</div>
<div class="sect2">
<h3 id="_需要更多的结构">3.4. 需要更多的结构</h3>
<div class="paragraph">
<p>圣诞老人发现了这封信：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># Dude</span>

<span class="tok-cm">=== Welll...</span>

<span class="tok-n">I</span> <span class="tok-n">have</span> <span class="tok-n">been</span> <span class="tok-n">a</span> <span class="tok-n">naughty</span> <span class="tok-n">person</span>


<span class="tok-cm">=== Requests</span>

<span class="tok-n">Well</span>...</code></pre>
</div>
</div>
<div class="paragraph">
<p>妥善处理和一切，他不能浪费他的时间与不好的人。规模。和资源。资源只能用于好人，而不是坏人。坏人不好，就是这样。所以回到编码，鲁道夫溜走寻找地衣糖或任何东西，他出示了这样的：</p>
</div>
<div class="paragraph">
<p>圣诞老人对第二个标题之后的段落提取技巧以及他能够很好地使用他所喜爱的Thorn信件这一事实感到自豪。他还喜欢函数式编程，在Lisp中咬牙切齿。所以他创建了这个最初是假的翻转开关，但是当它正在处理的元素是一个标题并且其级别是两个时，翻转开关。他也很高兴他可以用标记的文本顶部的分层结构来做这种事情。</p>
</div>
<div class="paragraph">
<p>此外，他可以检查该标题（行为）与下一行之间的任何段落中是否出现“好”字。而且任何一个都很酷。其中一个段落提到的很好就足够了。最后一行将首先返回一个布尔值数组，如果其中一个包含好的话，它最终将会声明为True。否则为假。适合从坏的方面挑选好的东西。</p>
</div>
<div class="paragraph">
<p>圣诞老人很开心。 -ier。但仍然。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这里的玩具是重要的">3.5. 这里的玩具是重要的</h3>
<div class="paragraph">
<p>所以他真正想要的是玩具清单。在再次请求改变信件格式，他可以做的，因为他是圣诞老人，每个人都希望他的圣诞节免费的东西，他开始接收这种结构的信件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># Dear Santa</span>

<span class="tok-cm">=== Behavior</span>

<span class="tok-n">I</span> <span class="tok-n">have</span> <span class="tok-n">been</span> <span class="tok-n">a</span> <span class="tok-n">good</span> <span class="tok-n">boy</span>


<span class="tok-cm">=== Requests</span>

<span class="tok-n">And</span> <span class="tok-n">this</span> <span class="tok-k">is</span> <span class="tok-n">what</span> <span class="tok-n">I</span> <span class="tok-nb">want</span>

 - <span class="tok-n">scythes</span>
 - <span class="tok-n">an</span> <span class="tok-n">ocean</span> <span class="tok-n">liner</span> <span class="tok-n">with</span> <span class="tok-n">a</span> <span class="tok-n">captain</span> <span class="tok-o">and</span> <span class="tok-n">a</span> <span class="tok-n">purser</span>
 - <span class="tok-n">a</span> <span class="tok-nb">time</span> <span class="tok-n">travel</span> <span class="tok-n">machine</span> <span class="tok-o">and</span> <span class="tok-n">instructions</span> <span class="tok-nb">to</span> <span class="tok-n">operate</span> <span class="tok-n">it</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>他们在结构上的自发性缺乏。而且结构很好。你可以得到一个请求列表：</p>
</div>
<div class="paragraph">
<p>这实际上是链表列表处理表达式的一个不清晰的列表。在这之前的这句话有一个列表提及几乎一样坏。但让我们看看那里发生了什么。</p>
</div>
<div class="paragraph">
<p>首先在列表中，我们仅使用正则表达式和东西来获取请求标题后面的内容。我们本可能已经把它归结为对Str的转变，但是我们已经失去了结构。结构很重要，圣诞老人永远不会厌倦这一点。接下来，我们只提取那些实际上是列表的元素，将所有绒毛都取出来。</p>
</div>
<div class="paragraph">
<p>而事实恰恰是，结构太多这样的事情。该列表包含具有元素的元素。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">那或Text </dt>
<dd>
<p>Markdown可以做一个大改造。这篇文章的作者正在将他的特别愿望清单放在这里。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_还没有">3.6. 还没有</h3>
<div class="paragraph">
<p>但几乎。我们有这个名单，现在圣诞老人发现像时间旅行机器和星期一这样的事情。他不能在精灵工厂订购周一。他必须阅读每一件事情。但不用担心。这也可以照顾到：</p>
</div>
<div class="paragraph">
<p>简单来说，这个程序会遍历愿望清单中保存的项目清单，并检查产品性能。它是一种产品吗？它走了。你是在问上周五晚上，你完全错过了什么？它不，也不敢浪费圣诞老人的时间，男孩。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这件事的要点在于使用全新的Wikidata </dt>
<dd>
<p>API模块的Wikidata查询。此模块只是将内容发送到Wikidata API并将其作为对象返回。相信与否，这就是SPARQL查询的作用：将项目名称插入到查询中，进行查询，并在返回的元素数量不为零时返回true。产品在你的指尖！在几行代码中！现在，他可以将所有东西链接在一起，并从包含此信件的信件中获取</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span> - <span class="tok-n">Morning</span> <span class="tok-n">sickness</span>
 - <span class="tok-n">Scythe</span>
 - <span class="tok-n">Mug</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>只有你们可以从当地，市中心，妈妈和流行商店订购的其中两件，这是圣诞老人实际上偷偷购买所有东西的地方，因为他大量购买，并且他得到了很好的交易。</p>
</div>
<div class="paragraph">
<p>圣诞老人微微一笑，精灵，驯鹿和几只海雀在那里没有任何理由就爆发出大声的欢呼声。然后，他们往下看</p>
</div>
</div>
<div class="sect2">
<h3 id="_包起来">3.7. 包起来</h3>
<div class="paragraph">
<p>圣诞老人和 Perl 6 是一个很好的比赛，因为他们都是在圣诞节的时候来的。圣诞老人发现你可以自己做很多有用的事情，或者使用最近可用的优质模块之一。</p>
</div>
<div class="paragraph">
<p>不过，这位作者在给圣诞老人的信中将包括一些帮助，以继续介绍由他维护的这篇文章中使用的两个模块，这些模块需要更多有经验的编码人员进行测试，扩展或者重新编写。但他很高兴地看到，使用Perl6可以直接完成处理给圣诞老人的信件等世俗和略微神圣的事情。你也应该这样做。</p>
</div>
<div class="paragraph">
<p>这篇文章的代码和样例可以从 <a href="https://github.com/JJ/santa-markdown">GitHub</a> 获得。也是这个文本。帮助和建议非常受欢迎。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_使用_grammars_进行解析">4. 第四天-使用 Grammars 进行解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下面是从 <a href="https://www.apress.com/us/book/9781484232279">Parsing with Perl 6 Regexes and Grammars: A Recursive Descent into Parsing</a> 这本书里面提取出来的一章, 作者是 Moritz Lenz, 由 Apress Media 出版社出版。版权经过允许。</p>
</div>
<div class="paragraph">
<p>这本书马上就要出版了。至少该书的电子版这个月应该可以购买, 纸质版的可以在 <a href="https://smile.amazon.com/dp/1484232275/">亚马逊</a> 预定了。原本最迟会在 2018 年元月发出, 但是幸运的是, 圣诞节你就可以看到了。</p>
</div>
<div class="paragraph">
<p>下面你会看到第九章, 使用 Grammars 进行解析。前面的章节详细探讨了创建正则表达式块儿、正则表达式怎么和 Perl 6 代码进行交互、匹配对象、正则力学、常用正则技术，还有重用和组合正则。你可以通过阅读<a href="https://docs.perl6.org/language/regexes">正则表达式官方文档</a>来获取更多关于正则的背景。</p>
</div>
<div class="paragraph">
<p>后面的章节涵盖了 action 类和对象, 怎么报告高质量的解析错误, Unicode 支持, 最后还有三个案例研究。</p>
</div>
<div class="paragraph">
<p>现在, 尽情享受吧！</p>
</div>
<div class="paragraph">
<p>Grammar 是众人皆知的用于解析的瑞士军刀。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将更详细地探讨它们。 最重要的是，我们将讨论如何利用他们的威力。</p>
</div>
<div class="sect2">
<h3 id="_理解_grammars">4.1. 理解 Grammars</h3>
<div class="paragraph">
<p>Grammars 实现了自顶向下的解析方法。 入口点，通常是 <code>TOP</code> regex 正则表达式，它知道粗粒度的结构，并调用下降到繁复细节的更深一步的正则表达式。 也会涉及到递归。 例如，如果解析算术表达式，则操作符可以是一对括号内的任意表达式。</p>
</div>
<div class="paragraph">
<p>这是一个自顶向下的结构，或者更确切地说是一个<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降分析方法</a>。 如果不涉及回溯，我们称之为*预测分析法*，因为在字符串中的每个位置，我们确切地知道我们在寻找什么 - 我们可以预测下一个 token 将会是什么（即使我们只能预测它可能是一组可选分支的其中之一）。</p>
</div>
<div class="paragraph">
<p>结果匹配树在结构上完全对应于 grammar 中正则表达式的调用结构。 让我们考虑解析一个只包含运算符 <code>*</code>，`+`和用于分组的括号的算术表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">MathExpression</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span>    {<span class="tok-sr"> &lt;sum&gt; </span>}
    <span class="tok-k">rule</span><span class="tok-n"> sum</span>     {<span class="tok-sr"> &lt;product&gt;+ %  &#39;+&#39; </span>}
    <span class="tok-k">rule</span><span class="tok-n"> product</span> {<span class="tok-sr"> &lt;term&gt;+ % &#39;*&#39; </span>}
    <span class="tok-k">rule</span><span class="tok-n"> term</span>    {<span class="tok-sr"> &lt;number&gt; | &lt;group&gt; </span>}
    <span class="tok-k">rule</span><span class="tok-n"> group</span>   {<span class="tok-sr"> &#39;(&#39; &lt;sum&gt; &#39;)&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
}

<span class="tok-nb">say</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;2 + 4 * 5 * (1 + 3)&#39;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 Grammar 本身，你已经可以看到递归的可能性：<code>sum</code> 调用 <code>product</code>，<code>product</code> 调用 <code>term</code>，<code>term</code> 调用 <code>group</code>，<code>group</code> 再次调用 <code>sum</code>。 这允许解析任意深度的嵌套表达式。</p>
</div>
<div class="paragraph">
<p>解析上面的例子产生下面的匹配对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>⌜<span class="tok-mi">2</span> + <span class="tok-mi">4</span> * <span class="tok-mi">5</span> * (<span class="tok-mi">1</span> + <span class="tok-mi">3</span>)⌟
 <span class="tok-nb">sum</span> =&gt; ⌜<span class="tok-mi">2</span> + <span class="tok-mi">4</span> * <span class="tok-mi">5</span> * (<span class="tok-mi">1</span> + <span class="tok-mi">3</span>)⌟
  <span class="tok-n">product</span> =&gt; ⌜<span class="tok-mi">2</span> ⌟
   <span class="tok-n">term</span> =&gt; ⌜<span class="tok-mi">2</span> ⌟
    <span class="tok-n">number</span> =&gt; ⌜<span class="tok-mi">2</span>⌟
  <span class="tok-n">product</span> =&gt; ⌜<span class="tok-mi">4</span> * <span class="tok-mi">5</span> * (<span class="tok-mi">1</span> + <span class="tok-mi">3</span>)⌟
   <span class="tok-n">term</span> =&gt; ⌜<span class="tok-mi">4</span> ⌟
    <span class="tok-n">number</span> =&gt; ⌜<span class="tok-mi">4</span>⌟
   <span class="tok-n">term</span> =&gt; ⌜<span class="tok-mi">5</span> ⌟
    <span class="tok-n">number</span> =&gt; ⌜<span class="tok-mi">5</span>⌟
   <span class="tok-n">term</span> =&gt; ⌜(<span class="tok-mi">1</span> + <span class="tok-mi">3</span>)⌟
    <span class="tok-n">group</span> =&gt; ⌜(<span class="tok-mi">1</span> + <span class="tok-mi">3</span>)⌟
     <span class="tok-nb">sum</span> =&gt; ⌜<span class="tok-mi">1</span> + <span class="tok-mi">3</span>⌟
      <span class="tok-n">product</span> =&gt; ⌜<span class="tok-mi">1</span> ⌟
       <span class="tok-n">term</span> =&gt; ⌜<span class="tok-mi">1</span> ⌟
        <span class="tok-n">number</span> =&gt; ⌜<span class="tok-mi">1</span>⌟
      <span class="tok-n">product</span> =&gt; ⌜<span class="tok-mi">3</span>⌟
       <span class="tok-n">term</span> =&gt; ⌜<span class="tok-mi">3</span>⌟
        <span class="tok-n">number</span> =&gt; ⌜<span class="tok-mi">3</span>⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想知道某个特定的数字是如何解析的，你可以通过查找当前行上缩进较少的行来追踪路径。 例如，数字 <code>1</code> 由 token <code>number`解析，调用自 `term</code>，再调用自 <code>product</code>，以此类推。</p>
</div>
<div class="paragraph">
<p>我们可以通过从 token <code>number</code> 引发异常来验证这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"></span>
<span class="tok-sr">        (\d+)</span>
<span class="tok-sr">        </span>{ <span class="tok-k">die</span> <span class="tok-s">&quot;how did I get here?&quot;</span> <span class="tok-k">if</span> <span class="tok-nv">$0</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;1&#39;</span> }<span class="tok-sr"></span>
<span class="tok-sr">    </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这确实显示了回溯中的调用链，其中最直接的上下文是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">how</span> <span class="tok-n">did</span> <span class="tok-n">I</span> <span class="tok-n">get</span> <span class="tok-n">here</span>?
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> number</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">9</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> term</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">5</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> product</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">4</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> sum</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">3</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> group</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">6</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> term</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">5</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> product</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">4</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> sum</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">3</span>
  <span class="tok-n">in</span> <span class="tok-k">regex</span><span class="tok-n"> TOP</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">2</span>
  <span class="tok-n">in</span> <span class="tok-n">block</span> <span class="tok-s">&lt;unit&gt;</span> <span class="tok-n">at</span> <span class="tok-n">bt</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">13</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法只使用 tokens 和 rules，所以不涉及回溯，而 grammar 是一个预测分析法。 这是相当典型的。 没有回溯或在几个地方有回溯时, 许多 grammars 都工作正常。</p>
</div>
</div>
<div class="sect2">
<h3 id="_递归下降分析法和优先级">4.2. 递归下降分析法和优先级</h3>
<div class="paragraph">
<p><code>MathExpression</code> grammar 有两个结构相同的 rules：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n"> sum</span> {<span class="tok-sr"> &lt;product&gt;+ %  &#39;+&#39; </span>}
<span class="tok-k">rule</span><span class="tok-n"> product</span> {<span class="tok-sr"> &lt;term&gt;+ % &#39;*&#39; </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是, 我们也可以写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n">  expression</span> {<span class="tok-sr"> &lt;operator&gt;+ % &lt;term&gt; </span>}
<span class="tok-k">token</span><span class="tok-n"> operator</span>   {<span class="tok-sr">  &#39;*&#39; | &#39;+&#39; </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至使用前一章讨论的 <code>proto token</code> 构造来解析不同的操作符。我选择第一种更重复的方法的原因是它使匹配结构对应于运算符 <code>*</code> 和 <code>+</code> 的优先级。</p>
</div>
<div class="paragraph">
<p>当计算数学表达式 <code>1 + 2 * 5</code> 时，数学家和大多数编程语言首先计算 <code>2 * 5</code>，因为 <code>*</code> 运算符的优先级高于 <code>+</code>。然后将结果代入表达式，成为 <code>1 + 10</code>，最后得到 <code>11</code>。</p>
</div>
<div class="paragraph">
<p>当用 grammar 的第一个版本解析这样的表达式的时候，解析树的结构表示这个分组：它具有 - 作为最高级 - 单个 sum，操作数是 <code>1</code> 和 <code>2 * 5</code>。</p>
</div>
<div class="paragraph">
<p>这是有代价的：对于每个优先级我们需要一个单独的 rule 和名字，并且所产生的结果匹配对象的嵌套层级, 每个优先级至少有一级。而且，稍后增加更多的优先级并不是微不足道的，而且很难通用。如果您不愿意接受这些成本，则可以使用具有单个 token 的平级模型来解析所有运算符。如果您需要能反映优先级的结构，则可以编写代码将列表转换为树。这通常被称为<a href="https://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析器</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_左递归和其他陷阱">4.3. 左递归和其他陷阱</h3>
<div class="paragraph">
<p>为了避免无限递归，你必须注意，每个可能的递归循环至少将游标位置推进了一个字符。在 <code>MathExpression</code> grammar 中，唯一可能的递归循环是 <code>sum</code>→<code>product</code>→<code>term</code>→<code>group</code>→<code>sum</code>，并且 <code>group</code> 只有在消耗了一个初始开口圆括号 <code>(</code> 时才匹配。</p>
</div>
<div class="paragraph">
<p>如果递归不消耗字符，则它被称为*左递归*，并且需要特殊的语言支持, 这个 Perl 6 并不支持。一个例子是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">token</span><span class="tok-n"> a</span> {<span class="tok-sr"> &lt;a&gt;? &#39;a&#39; </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它本该与正则表达式 <code>a+</code> 匹配相同的输入，但是却无限循环而不前进。</p>
</div>
<div class="paragraph">
<p>避免左递归的一个常用技巧是有一个可以按照从通用（这里是 <code>sum</code>）到特定（<code>number</code>）顺序排序正则表达式的结构。当正则表达式偏离该顺序时（例如 <code>group `调用 `sum</code>），你只需要关心并检查消耗的字符。</p>
</div>
<div class="paragraph">
<p>无限循环的另一个潜在来源是在量词化能匹配空字符串的正则表达式时。在解析允许某些内容为空的语言时可能会发生这种情况。例如，在 UNIX shell 中，你可以在给变量赋值的时候把右侧置空：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">VAR1</span>=<span class="tok-nb">value</span>
<span class="tok-n">VAR2</span>=</code></pre>
</div>
</div>
<div class="paragraph">
<p>在为 UNIX shell 命令编写 grammar 时，编写一个可能匹配空字符串的 <code>token string { \w* }</code> 可能会很冒险。 在允许多于一个字符串字面值的情况下，<code>&lt;string&gt;+</code> 就会挂起，因为实际的正则表达式 <code>[\w*]+</code> 试图无限次地匹配一个零宽度的字符串。</p>
</div>
<div class="paragraph">
<p>一旦你意识到了这个问题，解决方案就变得非常简单：将 token 更改为不允许空字符串（<code>token string { \w+ }</code>），并显式地处理允许空字符串的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">token</span><span class="tok-n"> assignment</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;variable&gt; &#39;=&#39; &lt;string&gt;?</span>
<span class="tok-sr">    </span>}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_始于简单">4.4. 始于简单</h3>
<div class="paragraph">
<p>即使 grammar 是自上而下工作的，但是开发的时候最好开自下而上。 一开始，grammar 的总体结构往往是不明显的，但是你通常知道*末端* token：那些能直接匹配文本而不需要调用其他 subrules 的 token。</p>
</div>
<div class="paragraph">
<p>在前面的解析数学表达式的例子中，你可能一开始不知道如何安排解析 sums 和 products 的 rules，但你很可能知道必须在某个时候解析数字，所以一开始你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">MathExpression</span> {
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这并不是很多，但也不是很复杂，这是程序员有时在遇到新问题领域时克服挑战的一种很好的方式。 当然，一旦你有了 token，就可以开始写一些测试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">MathExpression</span> {
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
}

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(<span class="tok-nb">Bool</span> :<span class="tok-nv">$test</span>!) {
    <span class="tok-k">use</span> <span class="tok-n">Test</span>;
    <span class="tok-nb">plan</span> <span class="tok-mi">2</span>;
    <span class="tok-nb">ok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1234&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;number&gt;</span>),
        <span class="tok-s">&#39;&lt;number&gt; parses 1234&#39;</span>;
    <span class="tok-n">nok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1+4&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;number&gt;</span>),
        <span class="tok-s">&#39;&lt;number&gt; does not parse 1+4&#39;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以以自己的方式创建更复杂的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">MathExpression</span> {
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
    <span class="tok-k">rule</span><span class="tok-n"> product</span> {<span class="tok-sr"> &lt;number&gt;+ % &#39;*&#39; </span>}
}

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(<span class="tok-nb">Bool</span> :<span class="tok-nv">$test</span>!) {
    <span class="tok-k">use</span> <span class="tok-n">Test</span>;
    <span class="tok-nb">plan</span> <span class="tok-mi">5</span>;
    <span class="tok-nb">ok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1234&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;number&gt;</span>),
        <span class="tok-s">&#39;&lt;number&gt; parses 1234&#39;</span>;
    <span class="tok-n">nok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1+4&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;number&gt;</span>),
        <span class="tok-s">&#39;&lt;number&gt; does not parse 1+4&#39;</span>;

    <span class="tok-nb">ok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1234&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;product&gt;</span>),
        <span class="tok-s">&#39;&lt;product&gt; can parse a simple number&#39;</span>;
    <span class="tok-nb">ok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1*3*4&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;product&gt;</span>),
        <span class="tok-s">&#39;&lt;product&gt; can parse three terms&#39;</span>;
    <span class="tok-nb">ok</span> <span class="tok-n">MathExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;1 * 3&#39;</span>, :<span class="tok-k">rule</span><span class="tok-s">&lt;product&gt;</span>),
        <span class="tok-s">&#39;&lt;product&gt; and whitespace&#39;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在测试的早期包含空白是值得的。 上面的例子看起来是无害的，但最后那个测试实际上失败了。 没有 rule 匹配 <code>1</code> 和 <code>*</code> 之间的空格。 在 <code>&lt;number&gt;</code> 和 <code>+</code> 量词之间的正则表达式中添加一个空格使测试再次通过，因为空格插入了一个隐式的 <code>&lt;.ws&gt;</code> 调用。</p>
</div>
<div class="paragraph">
<p>如果你从最简单的开始，尽快抓住这些细节，就很容易理解。 如果不是从上到下写下整个 grammar，你就会花很多时间去调试为什么一些看起来很简单的东西会导致解析失败, 比如额外的空格。</p>
</div>
</div>
<div class="sect2">
<h3 id="_组装完整的_grammars">4.5. 组装完整的 Grammars</h3>
<div class="paragraph">
<p>一旦你为词法分析编写了基本的 tokens，你可以进行合并。 通常，tokens 不会在匹配的边界处解析空白，因此组合它们的 rules 会这样做。</p>
</div>
<div class="paragraph">
<p>在上一节的 <code>MathExpression</code> 示例中，<code>rule product</code> 直接地调用了 <code>number</code>, 即使我们现在知道最终版本使用了一个中间步骤，也就是 rule <code>term</code>，它也可以解析用圆括号围起来的表达式。 引入这个额外的步骤不会使我们为 <code>product</code> 编写的测试失效，因为它在早期版本中匹配的字符串仍然匹配。 从处理语言子集的 grammar 开始，引入更多层是自然发生的，稍后将扩展。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调试_grammars">4.6. 调试 Grammars</h3>
<div class="paragraph">
<p>对于正则表达式或 Grammar，有两种失败模式：它们可以匹配，当它不应该匹配（误报）时，或者它应该匹配（错误否定）时可能匹配失败。通常，误报更容易理解，因为您可以检查生成的匹配对象，并查看哪些正则表达式匹配了字符串的哪一部分。</p>
</div>
<div class="paragraph">
<p>有一个方便的工具来调试误报：<code>Grammar::Tracer</code> 模块。如果将模块加载到包含 grammar 的文件中，则运行该 grammar 会生成诊断信息，以帮助您找出匹配出错的位置。</p>
</div>
<div class="paragraph">
<p>请注意，这只是开发人员的诊断工具; 如果你想给终端用户更好的错误信息，请阅读第 11 章的改进建议。</p>
</div>
<div class="paragraph">
<p>您需要安装 Perl 6 的 <code>Grammar::Debugger</code> 模块，其中还包含 <code>Grammar::Tracer</code>。如果您使用 <code>moritzlenz/perl6-regex-alpine</code> 的 docker 镜像，这已经为您完成了。如果您通过其他方法安装了Perl 6，则需要在命令行上运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Grammar::Debugger</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果尚未安装 <code>zef</code>，请按照 <a href="https://github.com/ugexe/zef#installation">zef GitHub页面</a> 上的安装说明进行操作。</p>
</div>
<div class="paragraph">
<p>让我们来看一下 TadeuszSośnierz 写的 Perl 6 模块 <a href="https://github.com/tadzik/perl6-Config-INI">Config::INI</a>。 它包含以下 <a href="https://github.com/tadzik/perl6-Config-INI/blob/master/lib/Config/INI.pm">grammar</a>（这儿稍微重新格式化了）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">INI</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"></span>
<span class="tok-sr">        ^ &lt;.eol&gt;* &lt;toplevel&gt;?  &lt;sections&gt;* &lt;.eol&gt;* $</span>
<span class="tok-sr">            </span>}
    <span class="tok-k">token</span><span class="tok-n"> toplevel</span> {<span class="tok-sr"> &lt;keyval&gt;* </span>}
    <span class="tok-k">token</span><span class="tok-n"> sections</span> {<span class="tok-sr"> &lt;header&gt; &lt;keyval&gt;* </span>}
    <span class="tok-k">token</span><span class="tok-n"> header</span>   {<span class="tok-sr"> ^^ \h* &#39;[&#39; ~ &#39;]&#39; $&lt;text&gt;=&lt;-[ \] \n ]&gt;+</span>
<span class="tok-sr">                     \h* &lt;.eol&gt;+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> keyval</span>   {<span class="tok-sr"> ^^ \h* &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt;? \h*</span>
<span class="tok-sr">                     &lt;.eol&gt;+ </span>}
    <span class="tok-k">regex</span><span class="tok-n"> key</span>      {<span class="tok-sr"> &lt;![#\[]&gt; &lt;-[;=]&gt;+ </span>}
    <span class="tok-k">regex</span><span class="tok-n"> value</span>    {<span class="tok-sr"> [ &lt;![#;]&gt; \N ]+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> eol</span>      {<span class="tok-sr"> [ &lt;[#;]&gt; \N* ]? \n </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设我们想知道为什么它不解析下面的一段输入文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">a</span> = <span class="tok-n">b</span>
[<span class="tok-n">foo</span>]
<span class="tok-n">c:</span> <span class="tok-n">d</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所以, 在该 grammar 之前, 我们插入下面这一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Grammar::Tracer</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，添加一小段调用该 grammar 的 <code>.parse</code> 方法的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">INI</span>.<span class="tok-n">parse</span>(<span class="tok-s">q:to/EOF/);</span>
<span class="tok-s">a = b</span>
<span class="tok-s">[foo]</span>
<span class="tok-s">c: d</span>
<span class="tok-s">EOF</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生了一个可观的，但相当丰富的输出。</p>
</div>
<div class="paragraph">
<p>每个条目由一个正则表达式的名称组成，比如 <code>TOP</code> 或者 <code>eol</code>（"end of line" 的缩写），后面跟着它调用的正则表达式的缩进后的输出。 每个正则表达式后面都有一个包含星号（<code><strong></code>）和 <code>MATCH</code> 后跟正则表达式匹配到的字符串片段这样的行; 如果正则表达式失败，则 <code></strong></code> 号后面跟的是 <code>FAIL</code>。</p>
</div>
<div class="paragraph">
<p>让我们一块一块地查看输出，即使它成块地出现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">TOP</span>
|  <span class="tok-n">eol</span>
|  * <span class="tok-n">FAIL</span>
|  <span class="tok-n">toplevel</span>
|  |  <span class="tok-n">keyval</span>
|  |  |  <span class="tok-nb">key</span>
|  |  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;a &quot;</span>
|  |  |  <span class="tok-nb">value</span>
|  |  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;b&quot;</span>
|  |  |  <span class="tok-n">eol</span>
|  |  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;\n&quot;</span>
|  |  |  <span class="tok-n">eol</span>
|  |  |  * <span class="tok-n">FAIL</span>
|  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;a = b\n&quot;</span>
|  |  <span class="tok-n">keyval</span>
|  |  |  <span class="tok-nb">key</span>
|  |  |  * <span class="tok-n">FAIL</span>
|  |  * <span class="tok-n">FAIL</span>
|  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;a = b\n&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉我们，<code>TOP</code> 调用了 <code>eol</code>，它没有匹配。 由于 <code>eol</code> 的调用是用 <code>*</code> 量化的，所以这不会导致 <code>TOP</code> 的匹配失败。 <code>TOP</code> 然后调用了 <code>key</code>, 匹配到文本 "a", 调用 <code>value</code>, 匹配到文本 "b"。 然后 <code>eol</code> 正则表达式继续匹配换行符，在第二次尝试时失败（因为在一行中没有两个换行符）。 这会导致初始的 <code>keyval</code> token 匹配成功。 第二次调用 <code>keyval</code> 匹配很快（在调用 <code>key</code> 中）。 然后，<code>toplevel</code> token 的匹配成功进行，消耗了字符串 "a = b \ n"。</p>
</div>
<div class="paragraph">
<p>到目前为止，这一切看起来都和预期的一样。 现在我们来看看第二部分的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>|  <span class="tok-n">sections</span>
|  |  <span class="tok-n">header</span>
|  |  |  <span class="tok-n">eol</span>
|  |  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;\n&quot;</span>
|  |  |  <span class="tok-n">eol</span>
|  |  |  * <span class="tok-n">FAIL</span>
|  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;[foo]\n&quot;</span>
|  |  <span class="tok-n">keyval</span>
|  |  |  <span class="tok-nb">key</span>
|  |  |  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;c: d\n&quot;</span>
|  |  * <span class="tok-n">FAIL</span>
|  * <span class="tok-n">MATCH</span> <span class="tok-s">&quot;[foo]\n&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TOP</code> 接下来调用 <code>sections</code>，其中 token <code>header</code> 成功匹配了字符串 <code>"[foo] \ n"</code>。 然后，<code>keyval</code> 调用 <code>key</code>，它匹配了 <code>"c: d\n"</code> 整行。 等等，这是不对的，是吗？ 我们可能期望 <code>key</code> 只匹配 <code>c</code>。 我当然不希望它匹配最后的换行符。 输入中缺少等号会导致 regex 引擎永远不会调用 regex <code>value</code>。 但是由于 <code>keyval</code> 再次用星号 <code>*</code> 量词进行量化，因此调用正则表达式 <code>sections</code> 的匹配成功地匹配了 header <code>"[foo]\n"</code>。</p>
</div>
<div class="paragraph">
<p><code>Grammar::Tracer</code> 输出的最后一部分如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>|  <span class="tok-n">sections</span>
|  |  <span class="tok-n">header</span>
|  |  * <span class="tok-n">FAIL</span>
|  * <span class="tok-n">FAIL</span>
|  <span class="tok-n">eol</span>
|  * <span class="tok-n">FAIL</span>
* <span class="tok-n">FAIL</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从这里开始都是 <code>FAIL</code>。第二次调用 <code>sections</code> 再次尝试解析 header，但其下一个输入仍然是 <code>"c: d\n"</code>，所以失败了。正如 token <code>TOP</code> 中字符串末尾的锚点 <code>$</code> 一样，在 <code>parse</code> 方法中总体匹配失败。</p>
</div>
<div class="paragraph">
<p>所以我们已经知道正则表达式 <code>key</code> 匹配整行 <code>c: d\n</code>，但是因为没有等号（<code>=</code>）跟在后面，所以 token <code>keyval</code> 解析不了这一行。由于没有其他正则表达式（特别是没有 <code>header</code>）匹配它，这是匹配失败的地方。</p>
</div>
<div class="paragraph">
<p>从这个例子中你可以看到，<code>Grammar::Tracer</code> 使我们能够精确定位解析失败发生的位置，尽管我们必须仔细查看它的输出以找到它。在终端中运行时，会自动获取彩色输出，其中 <code>FAIL</code> 为红色，<code>MATCH</code> 为绿色背景，token 名称以粗体白色（而不是通常的灰色）输出。这样可以更容易地从底部扫描（失败的匹配通常会留下一条红色的 <code>FAIL</code>），直到尾部成功的匹配，然后在匹配和失败之间的边界附近查看。</p>
</div>
<div class="paragraph">
<p>由于调试带来了巨大的精神负担，而且 <code>Grammar::Tracer</code> 的输出趋向于快速增长，所以通常建议将失败的输入减少到最小的样本。在上述情况下，我们可以删除输入字符串的第一行，并保存十行 <code>Grammar::Tracer</code> 输出来查看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析空白和注释">4.7. 解析空白和注释</h3>
<div class="paragraph">
<p>如前所述，解析无关紧要的空格的惯用方法是调用 <code>&lt;.ws&gt;</code>，通常隐式地使用 rule 中的空格。 默认的 <code>ws</code> 实现 <code>&lt;!ww&gt;\s*</code> 对许多语言都适用，但是它有其局限性。</p>
</div>
<div class="paragraph">
<p>在数量惊人的文件格式和计算机语言中，也有 <code>&lt;.ws&gt;</code> 占用的空白是有意义的。 这些包括 INI 文件（换行符通常表示一个新的键/值对），Python 和 YAML（缩进用于分组），CSV（换行符表示新记录）以及 Makefile（缩进要求是制表符）。</p>
</div>
<div class="paragraph">
<p>在这些情况下，最好的做法在你自己的 grammar 中重写 <code>ws</code> 来匹配只有不重要的空格。 让我们来看看第二个简约的 INI 解析器，它是从上一节中描述的独立开发的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">INIFile</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"> &lt;section&gt;* </span>}
    <span class="tok-k">token</span><span class="tok-n"> section</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;header&gt;</span>
<span class="tok-sr">        &lt;keyvalue&gt;*</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> header</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;[&#39;  &lt;-[ \] \n ]&gt;+ &#39;]&#39; &lt;.eol&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> keyvalue</span> {<span class="tok-sr"></span>
<span class="tok-sr">        ^^</span>
<span class="tok-sr">        $&lt;key&gt;=[\w+]</span>
<span class="tok-sr">        &lt;[:=]&gt;</span>
<span class="tok-sr">        $&lt;value&gt;=[&lt;-[\n;#]&gt;*]</span>
<span class="tok-sr">        &lt;.eol&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> ws</span> {<span class="tok-sr"> &lt;!ww&gt; \h* </span>}
    <span class="tok-k">token</span><span class="tok-n"> eol</span> {<span class="tok-sr"></span>
<span class="tok-sr">        \n [\h*\n]*</span>
<span class="tok-sr">    </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它解析简单的 INI 配置文件就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>[<span class="tok-n">db</span>]
<span class="tok-n">driver:</span> <span class="tok-n">mysql</span>
<span class="tok-n">host:</span> <span class="tok-n">db01</span>.<span class="tok-n">example</span>.<span class="tok-n">com</span>
<span class="tok-n">port:</span> <span class="tok-mi">122</span>
<span class="tok-n">username:</span> <span class="tok-n">us123</span>
<span class="tok-n">password:</span> <span class="tok-n">s3kr1t</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这个 grammar 如何使用两条路径来解析空格：自定义的 <code>ws</code> token 只匹配水平空白（空格和制表符），单独的 <code>eol</code> token 匹配(significant)换行符。 <code>eol</code> token 还吞噬了只包含空格的更多行。</p>
</div>
<div class="paragraph">
<p>如果语言支持注释，并且不希望它们出现在解析树中，则可以使用 <code>ws</code> token 或 <code>eol</code>（或其等价物）来解析它们。 哪一个取决于哪里允许注释。 在 INI 文件中，它们只允许出现在键值对之后，或者它们自己单独占一行，所以 <code>eol</code> 将是合适的地方。 相比之下，SQL 允许在每个允许空格的地方进行注释，所以在 <code>ws</code> 中解析它们是很自然的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># comment parsing for SQL:</span>
<span class="tok-k">token</span><span class="tok-n"> ws</span> {<span class="tok-sr"> &lt;!ww&gt; \s* [ &#39;--&#39; \N* \n ]* </span>}

<span class="tok-c1"># comment parsing for INI files:</span>
<span class="tok-k">token</span><span class="tok-n"> eol</span> {<span class="tok-sr"> [ [ &lt;[#;]&gt; \N* ]? \n ]+ </span>}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保存状态">4.8. 保存状态</h3>
<div class="paragraph">
<p>一些更有趣的数据格式和语言要求解析器存储事物（至少暂时）以便能够正确地解析它们。 一个恰当的例子是C编程语言，另一个例子是受其语法启发的（例如C ++和Java）。 这样的语言允许表单类型variable = initial_value的变量声明，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">int</span> <span class="tok-o">x</span> = <span class="tok-mi">42</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是有效的语法，但只有当第一个单词是一个类型名称。 相反，这将是无效的，因为x不是一个类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">int</span> <span class="tok-o">x</span> = <span class="tok-mi">42</span>;
<span class="tok-o">x</span> <span class="tok-n">y</span> = <span class="tok-mi">23</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这些例子中可以清楚地看到，解析器必须有它所知道的所有类型的记录。 由于用户也可以在他们的代码文件中声明类型，解析器必须能够更新这个记录。</p>
</div>
<div class="paragraph">
<p>许多语言还要求在引用符号（变量，类型和函数）之前进行声明。 这也需要语法来跟踪已经声明的内容和没有的内容。 这个已经声明的记录（以及什么是一个类型，也可能不是其他元信息）被称为符号表。</p>
</div>
<div class="paragraph">
<p>我们不考虑解析完整的C语言，而是考虑一种极简主义语言，它只允许分配数字列表和变量给变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">a</span> = <span class="tok-mi">1</span>
<span class="tok-n">b</span> = <span class="tok-mi">2</span>
<span class="tok-n">c</span> = <span class="tok-n">a</span>, <span class="tok-mi">5</span>, <span class="tok-n">b</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们不强加声明规则，写一个语法是很容易的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">VariableLists</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span>        {<span class="tok-sr"> &lt;statement&gt;* </span>}
    <span class="tok-k">rule</span><span class="tok-n">  statement</span>  {<span class="tok-sr"> &lt;identifier&gt; &#39;=&#39; &lt;termlist&gt; \n </span>}
    <span class="tok-k">rule</span><span class="tok-n">  termlist</span>   {<span class="tok-sr"> &lt;term&gt; * % &#39;,&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> term</span>       {<span class="tok-sr"> &lt;identifier&gt; | &lt;number&gt; </span>}
    <span class="tok-k">token</span><span class="tok-n"> number</span>     {<span class="tok-sr"> \d+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> identifier</span> {<span class="tok-sr"> &lt;:alpha&gt; \w* </span>}
    <span class="tok-k">token</span><span class="tok-n"> ws</span>         {<span class="tok-sr"> &lt;!ww&gt; \h* </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们要求变量只能在赋值之后才能使用，所以下面的输入将是无效的，因为在第二行中没有声明b的地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">a</span> = <span class="tok-mi">1</span>
<span class="tok-n">c</span> = <span class="tok-n">a</span>, <span class="tok-mi">5</span>, <span class="tok-n">b</span>
<span class="tok-n">b</span> = <span class="tok-mi">2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了维护一个符号表，我们需要三个新的元素：符号表的声明，一些代码，当赋值语句被解析时，将一个变量名添加到符号表中，最后检查一个变量是否已经被声明 我们在一个术语列表中遇到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">VariableLists</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"></span>
<span class="tok-sr">        :</span><span class="tok-k">my</span> <span class="tok-vg">%*SYMBOLS</span>;<span class="tok-sr"></span>
<span class="tok-sr">        &lt;statement&gt;*</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> ws</span> {<span class="tok-sr"> &lt;!ww&gt; \h* </span>}
    <span class="tok-k">rule</span><span class="tok-n"> statement</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        </span>{ <span class="tok-vg">%*SYMBOLS</span>{ <span class="tok-nv">$&lt;identifier&gt;</span> } = <span class="tok-nb">True</span> }<span class="tok-sr"></span>
<span class="tok-sr">        &#39;=&#39; &lt;termlist&gt;</span>
<span class="tok-sr">        \n</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> termlist</span> {<span class="tok-sr"> &lt;term&gt; * % &#39;,&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> term</span> {<span class="tok-sr"> &lt;variable&gt; | &lt;number&gt; </span>}
    <span class="tok-k">token</span><span class="tok-n"> variable</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        &lt;?</span>{ <span class="tok-vg">%*SYMBOLS</span>{ <span class="tok-nv">$&lt;identifier&gt;</span> } }<span class="tok-sr">&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> identifier</span> {<span class="tok-sr"> &lt;:alpha&gt; \w* </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在令牌TOP中，：my％* SYMBOLS声明一个变量。 正则表达式中的声明以冒号（:)开始，以分号（;）结尾。 在它们之间，它们看起来像Perl 6中的正常声明。％sigil表示该变量是一个散列 - 一个字符串键到值的映射。 *使它成为一个动态变量 - 一个变量，不仅限于当前范围，而且对于从当前范围调用的代码（或正则表达式，也是代码）也是可见的。 由于这是一个非常大的范围，所以在大写字母中选择一个变量是自定义的。</p>
</div>
<div class="paragraph">
<p>第二部分，在符号表中添加一个符号，发生在规则声明中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">rule</span><span class="tok-n"> statement</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        </span>{ <span class="tok-vg">%*SYMBOLS</span>{ <span class="tok-nv">$&lt;identifier&gt;</span> } = <span class="tok-nb">True</span> }<span class="tok-sr"></span>
<span class="tok-sr">        &#39;=&#39; &lt;termlist&gt;</span>
<span class="tok-sr">        \n</span>
<span class="tok-sr">    </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>大括号内是常规的（非正则表达式）Perl 6代码，所以我们可以使用它来操作哈希％* SYMBOLS。 表达式$ &lt;identifier&gt;访问变量name2的捕获。 因此，如果此规则解析变量a，则此语句将设置％* SYMBOLS {'a'} = True。</p>
</div>
<div class="paragraph">
<p>代码块的位置是相关的。 把它放在调用termlist之前意味着当术语列表被解析时变量已经是已知的，所以它接受像a = 2，a这样的输入。 如果我们首先调用termlist，这种输入被拒绝。</p>
</div>
<div class="paragraph">
<p>说到拒绝，这部分发生在令牌变量。 term现在调用新的标记变量（以前它直接称为标识符），并且变量验证该符号是在之前声明的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">token</span><span class="tok-n"> term</span> {<span class="tok-sr"> &lt;variable&gt; | &lt;number&gt; </span>}
    <span class="tok-k">token</span><span class="tok-n"> variable</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        &lt;?</span>{ <span class="tok-vg">%*SYMBOLS</span>{ <span class="tok-nv">$&lt;identifier&gt;</span> } }<span class="tok-sr">&gt;</span>
<span class="tok-sr">    </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能还记得在前面的例子中，&lt;？{&#8230;&#8203;}&gt;执行一段Perl 6代码，如果它返回一个假值，则解析失败。 如果$ &lt;identifier&gt;不在％SYMBOLS中，这正是发生的情况。 在这个时候，令牌的非回溯性是很重要的。 如果被解析的变量是abc，并且变量a在％* SYMBOLS中，则回溯将尝试&lt;identifier&gt;的较短匹配，直到它碰到a，然后成功3。</p>
</div>
<div class="paragraph">
<p>由于在标记TOP中声明了％* SYMBOLS，所以当您尝试从语法外调用除TOP之外的其他规则时，必须复制此声明。 没有像我的％* SYMBOLS ;,一个像这样的调用声明</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">VariableLists</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;abc&#39;</span>, <span class="tok-k">rule</span> =&gt; <span class="tok-s">&#39;variable&#39;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>dies with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Dynamic</span> <span class="tok-n">variable</span> <span class="tok-vg">%*SYMBOLS</span> <span class="tok-nb">not</span> <span class="tok-n">found</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用动态变量实现词法作用域">4.9. 使用动态变量实现词法作用域</h3>
<div class="paragraph">
<p>许多编程语言都有一个词汇范围的概念。 范围是程序中符号可见的区域。 如果范围仅由文本的结构（而不是程序的运行时功能）决定，我们称之为范围词法。</p>
</div>
<div class="paragraph">
<p>范围通常可以嵌套。 在一个作用域中声明的变量在这个作用域中是可见的，在所有的内部嵌套作用域中（除非内部作用域声明了一个名称相同的变量，在这种情况下，内部声明隐藏了外部作用域）。</p>
</div>
<div class="paragraph">
<p>回到列表和作业的玩具语言，我们可以引入一对花括号来表示一个新的范围，所以这是有效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">a</span> = <span class="tok-mi">1</span>
<span class="tok-n">b</span> = <span class="tok-mi">2</span>
{
    <span class="tok-n">c</span> = <span class="tok-n">a</span>, <span class="tok-mi">5</span>, <span class="tok-n">b</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但下一个例子是无效的，因为它只在内部范围内声明b，所以它在外部范围内是不可见的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">a</span> = <span class="tok-mi">1</span>
{
    <span class="tok-n">b</span> = <span class="tok-mi">2</span>
}
<span class="tok-n">c</span> = <span class="tok-n">a</span>, <span class="tok-mi">5</span>, <span class="tok-n">b</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在语法中实现这些规则，我们可以利用一个重要的观察：语法中的动态范围对应于它分析的文本中的词法范围。 如果我们有一个正则表达式块来解析范围的分隔符以及范围内的事物，那么它的动态范围就局限于它所调用的所有正则表达式（直接或间接），这也是它的范围 匹配输入文本。</p>
</div>
<div class="paragraph">
<p>我们来看看如何实现动态范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">VariableLists</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"></span>
<span class="tok-sr">        :</span><span class="tok-k">my</span> <span class="tok-vg">%*SYMBOLS</span>;<span class="tok-sr"></span>
<span class="tok-sr">        &lt;statement&gt;*</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> ws</span> {<span class="tok-sr"> &lt;!ww&gt; \h* </span>}
    <span class="tok-k">token</span><span class="tok-n"> statement</span> {<span class="tok-sr"></span>
<span class="tok-sr">        | &lt;declaration&gt;</span>
<span class="tok-sr">        |  &lt;block&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        </span>{ <span class="tok-vg">%*SYMBOLS</span>{ <span class="tok-nv">$&lt;identifier&gt;</span> } = <span class="tok-nb">True</span>; }<span class="tok-sr"></span>
<span class="tok-sr">        &#39;=&#39; &lt;termlist&gt;</span>
<span class="tok-sr">        \n</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> block</span> {<span class="tok-sr"></span>
<span class="tok-sr">        :</span><span class="tok-k">my</span> <span class="tok-vg">%*SYMBOLS</span> = <span class="tok-n">CALLERS::</span><span class="tok-s">&lt;%*SYMBOLS&gt;</span>;<span class="tok-sr"></span>
<span class="tok-sr">        &#39;{&#39; \n*</span>
<span class="tok-sr">            &lt;statement&gt;*</span>
<span class="tok-sr">        &#39;}&#39; \n*</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> termlist</span> {<span class="tok-sr"> &lt;term&gt; * % &#39;,&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> term</span> {<span class="tok-sr"> &lt;variable&gt; | &lt;number&gt; </span>}
    <span class="tok-k">token</span><span class="tok-n"> variable</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        &lt;?</span>{ <span class="tok-vg">%*SYMBOLS</span>{ <span class="tok-nv">$&lt;identifier&gt;</span> } }<span class="tok-sr">&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> identifier</span> {<span class="tok-sr"> &lt;:alpha&gt; \w* </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法的前一个版本有一些变化：规则语句已被重命名为声明，新的规则语句分析声明或块。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">所有有趣的位都发生在块规则中。 该行：my％* SYMBOLS = CALLERS </dt>
<dd>
<p>&lt;％* SYMBOLS&gt;; 声明一个新的动态变量％* SYMBOLS并用该变量的前一个值初始化它。 CALLERS :: &lt;％* SYMBOLS&gt;通过调用者和调用者的调用者等查找变量％* SYMBOLS，从而查找对应于外部作用域的值。 初始化创建散列的副本，以便对一个副本的更改不会影响其他副本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>让我们来看看当这个语法解析下面的输入时会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">a</span> = <span class="tok-mi">1</span>
<span class="tok-n">b</span> = <span class="tok-mi">2</span>
{
    <span class="tok-n">c</span> = <span class="tok-n">a</span>, <span class="tok-mi">5</span>, <span class="tok-n">b</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前两行之后，％* SYMBOLS的值为{a &#8658; True，b &#8658; True}。 当规则块解析第三行的开放大括号时，它会创建％* SYMBOLS的副本。 第四行的c的声明将对c &#8658; True插入到％* SYMBOLS的副本中。 在规则块解析最后一行的结束大括号之后，它将成功退出，并且％* SYMBOLS的副本将超出范围。 这给我们留下了早期版本的％* SYMBOLS（只有键a和b），当TOP退出时，它们超出了范围。</p>
</div>
<div class="paragraph">
<p>通过显式符号表进行范围确定</p>
</div>
<div class="paragraph">
<p>使用动态变量来管理符号表通常工作得很好，但是有一些边缘情况下更明确的方法效果更好。 这样的边缘情况包括那些符号太多以至于复制变得非常昂贵的情况，或者必须检查多于最顶端的范围的情况，或者复制符号表是不切实际的。</p>
</div>
<div class="paragraph">
<p>因此，可以为符号表编写一个类（在最简单的情况下，它使用一个数组作为范围的堆栈），在进入和离开范围时，在声明一个变量时，以及为了检查一个变量是否为 在一个范围内已知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">SymbolTable</span> {
    <span class="tok-k">has</span> <span class="tok-nv">@!scopes</span> = {}, ;
    <span class="tok-k">method</span> <span class="tok-n">enter-scope</span>() {
        <span class="tok-nv">@!scopes</span>.<span class="tok-nb">push</span>({})
    }
    <span class="tok-k">method</span> <span class="tok-n">leave-scope</span>() {
        <span class="tok-nv">@!scopes</span>.<span class="tok-nb">pop</span>();
    }
    <span class="tok-k">method</span> <span class="tok-n">declare</span>(<span class="tok-nv">$variable</span>) {
        <span class="tok-nv">@!scopes</span>[*-<span class="tok-mi">1</span>]{<span class="tok-nv">$variable</span>} = <span class="tok-nb">True</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">check-declared</span>(<span class="tok-nv">$variable</span>) {
        <span class="tok-k">for</span> <span class="tok-nv">@!scopes</span>.<span class="tok-nb">reverse</span> -&gt; <span class="tok-nv">%scope</span> {
            <span class="tok-k">return</span> <span class="tok-nb">True</span> <span class="tok-k">if</span> <span class="tok-nv">%scope</span>{<span class="tok-nv">$variable</span>};
        }
        <span class="tok-k">return</span> <span class="tok-nb">False</span>;
    }
}

<span class="tok-k">grammar</span> <span class="tok-n">VariableLists</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"></span>
<span class="tok-sr">        :</span><span class="tok-k">my</span> <span class="tok-vg">$*ST</span> = <span class="tok-n">SymbolTable</span>.<span class="tok-nb">new</span>();<span class="tok-sr"></span>
<span class="tok-sr">        &lt;statement&gt;*</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> ws</span> {<span class="tok-sr"> &lt;!ww&gt; \h* </span>}
    <span class="tok-k">token</span><span class="tok-n"> statement</span> {<span class="tok-sr"></span>
<span class="tok-sr">        | &lt;declaration&gt;</span>
<span class="tok-sr">        |  &lt;block&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        </span>{ <span class="tok-vg">$*ST</span>.<span class="tok-n">declare</span>( <span class="tok-nv">$&lt;identifier&gt;</span> ) }<span class="tok-sr"></span>
<span class="tok-sr">        &#39;=&#39; &lt;termlist&gt;</span>
<span class="tok-sr">        \n</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> block</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;{&#39; \n*</span>
<span class="tok-sr">            </span>{ <span class="tok-vg">$*ST</span>.<span class="tok-n">enter-scope</span>() }<span class="tok-sr"></span>
<span class="tok-sr">            &lt;statement&gt;*</span>
<span class="tok-sr">            </span>{ <span class="tok-vg">$*ST</span>.<span class="tok-n">leave-scope</span>() }<span class="tok-sr"></span>
<span class="tok-sr">        &#39;}&#39; \n*</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">rule</span><span class="tok-n"> termlist</span> {<span class="tok-sr"> &lt;term&gt; * % &#39;,&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> term</span> {<span class="tok-sr"> &lt;variable&gt; | &lt;number&gt; </span>}
    <span class="tok-k">token</span><span class="tok-n"> variable</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;identifier&gt;</span>
<span class="tok-sr">        &lt;?</span>{ <span class="tok-vg">$*ST</span>.<span class="tok-n">check-declared</span>(<span class="tok-nv">$&lt;identifier&gt;</span>) }<span class="tok-sr">&gt;</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> number</span> {<span class="tok-sr"> \d+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> identifier</span> {<span class="tok-sr"> &lt;:alpha&gt; \w* </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>SymbolTable类具有私有数组属性@！作用域，它使用包含单个空散列的列表进行初始化。输入一个作用域意味着在这个数组的顶部推一个空的散列，当离开这个作用域的时候，它会通过pop方法调用再次被删除。变量声明将其名称添加到最顶端的散列@ @ scopes [* - 1]。</p>
</div>
<div class="paragraph">
<p>检查变量的存在不能只考虑最顶端的散列，因为变量被继承到内部作用域。在这里，我们以相反的顺序遍历所有的范围，从最内层到最外层的范围。遍历的顺序与简单的布尔检查无关，但是如果您需要查找与该变量相关的信息，则遵守此顺序以引用正确的顺序非常重要。</p>
</div>
<div class="paragraph">
<p>令牌TOP创建类SymbolTable的新对象，声明调用声明方法，令牌变量调用方法检查声明。规则块在解析语句列表之前调用进入范围，之后保留范围。这个工作，但只有当语句列表可以被成功解析;如果不是，规则块在管理调用离开范围之前失败。</p>
</div>
<div class="paragraph">
<p>对于这种情况，Perl 6有一个安全特性：如果在LEAVE语句前添加一个语句，那么在例程退出时，Perl 6可以在所有可能的情况下调用它（即使抛出异常）。由于LEAVE相位器只能在正则代码中使用，而不能在正则表达式中使用，所以我们需要将正则表达式包装在一个方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">method</span> <span class="tok-n">block</span> {
        <span class="tok-vg">$*ST</span>.<span class="tok-n">enter-scope</span>();
        <span class="tok-k">LEAVE</span> <span class="tok-vg">$*ST</span>.<span class="tok-n">leave-scope</span>();
        <span class="tok-k">self</span>.<span class="tok-n">block_wrapped</span>();
    }
    <span class="tok-k">rule</span><span class="tok-n"> block_wrapped</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;{&#39; \n*</span>
<span class="tok-sr">            &lt;statement&gt;*</span>
<span class="tok-sr">        &#39;}&#39; \n*</span>
<span class="tok-sr">    </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们拥有与动态变量相同的鲁棒性，并且以更多的代码和更多的努力为代价，可以更灵活地向符号表添加额外的代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">4.10. 总结</h3>
<div class="paragraph">
<p>Perl 6 的 Grammar 是编写递归下降解析器的一种声明方式。 如果没有回溯，他们就是可预测的; 在每一个时刻，我们都知道我们想要的 token 列表。</p>
</div>
<div class="paragraph">
<p>Grammar 的递归性带来了左递归的风险，即递归路径不消耗任何字符的情况，从而导致无限循环。</p>
</div>
<div class="paragraph">
<p>尽管 Grammar 是自上而下的，但是他们通常是从下到上写出来的：从词法分析开始，然后转向解析更大的结构。</p>
</div>
<div class="paragraph">
<p>复杂语言成功和精确的解析需要额外的状态。 我们已经看到了如何在 grammar 中使用动态变量来保存状态，它们的作用域如何对应于输入的词法作用域，以及如何将符号表写入并集成到 grammars 中。</p>
</div>
<div class="paragraph">
<p>1、就像一把瑞士军刀一样，但是功能更强大。
2、在这一点上，<code>identifier</code> 不会解析其周围的空白是至关重要的。 因此，token 不关心空白的原则和调用这些 token 的 rules 解析空白。
3、在这种情况下，这将是无害的，因为没有其他 rule 可以匹配变量的其余部分，导致解析错误。 但是在更复杂的情况下，这种无意的回溯会导致语法维护人员非常困惑的错误。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.wordpress.com/2017/12/04/day-08-parsing-with-grammars-book-extract/">Day 4 – Parsing with Grammars</a>
== 第五天 - 使用 Perl 6 签名解构参数</p>
</div>
<div class="paragraph">
<p>在许多其他关键的 Perl 6 特性中，我认为 <a href="https://docs.perl6.org/type/Signature">Signatures</a> 是众多"杀手级"特性之一。 它们的功能如此丰富而强大，我怀疑关于如何使用它们可以写一整本书。 我想探索一下我原来忽略但是非常珍惜的一些特定功能。</p>
</div>
<div class="paragraph">
<p>您可能已经看到了基本的子程序签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nv">$x</span>, <span class="tok-nv">$y</span>, <span class="tok-nv">$z</span>) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它给函数声明了 3 个标量参数, 并在函数体里面给了它们 <strong>$x</strong>, <strong>$y</strong>, <strong>$z</strong> 的名字。</p>
</div>
<div class="paragraph">
<p>太简单了。</p>
</div>
<div class="paragraph">
<p>你可以更有爱心, 给它们加上指定的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nb">Str</span> <span class="tok-nv">$x</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$y</span>, <span class="tok-nb">Rat</span> <span class="tok-nv">$z</span>) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用笑脸符号 <code>:D</code> 让参数值是有定义的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nb">Str:D</span> <span class="tok-nv">$x</span>, <span class="tok-nb">Int:D</span> <span class="tok-nv">$y</span>, <span class="tok-nb">Rat:D</span> <span class="tok-nv">$z</span>) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有很多其它花哨的说明符你可以使用，在这里我不深入了。</p>
</div>
<div class="paragraph">
<p>但是如果你的参数更复杂呢？ （不是 <a href="https://docs.perl6.org/type/Complex">Complex</a> - 虽然它也起作用..）</p>
</div>
<div class="paragraph">
<p>For example, you might want to restrict a specific parameter to a Positional argument like an Array, or an Associative one like a Hash using the respective sigils, @ or %.
例如，你可能想要将特定的参数限制为像 Array 这样的 Positional 参数，或者使用相应的 @ 或 ％ 符号将这个参数限制为像 Hash 这样的关联参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nv">%h</span>) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我可以使用一个散列来调用该函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">myfunc</span>(%( <span class="tok-n">a</span> =&gt; <span class="tok-mi">1</span>, <span class="tok-n">b</span> =&gt; <span class="tok-s">&#39;this&#39;</span>, <span class="tok-n">c</span> =&gt; <span class="tok-mf">2.2</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我想验证那些特定的字段是否存在，我可以把代码放在函数的顶部来做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nv">%h</span>) {
    <span class="tok-k">die</span> <span class="tok-s">&quot;a must be an Int&quot;</span> <span class="tok-k">unless</span> <span class="tok-nv">%h&lt;a&gt;</span> ~~ <span class="tok-nb">Int</span>;
    <span class="tok-k">die</span> <span class="tok-s">&quot;b must be a Str&quot;</span>  <span class="tok-k">unless</span> <span class="tok-nv">%h&lt;b&gt;</span> ~~ <span class="tok-nb">Str</span>;
    <span class="tok-k">die</span> <span class="tok-s">&quot;c must be a Rat&quot;</span>  <span class="tok-k">unless</span> <span class="tok-nv">%h&lt;c&gt;</span> ~~ <span class="tok-nb">Rat</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我还想简化引用那些字段的方式，我可以将它们赋值给其他变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nv">%h</span>) {
    <span class="tok-k">die</span> <span class="tok-s">&quot;a must be an Int&quot;</span> <span class="tok-k">unless</span> <span class="tok-nv">%h&lt;a&gt;</span> ~~ <span class="tok-nb">Int</span>;
    <span class="tok-k">die</span> <span class="tok-s">&quot;b must be a Str&quot;</span>  <span class="tok-k">unless</span> <span class="tok-nv">%h&lt;b&gt;</span> ~~ <span class="tok-nb">Str</span>;
    <span class="tok-k">die</span> <span class="tok-s">&quot;c must be a Rat&quot;</span>  <span class="tok-k">unless</span> <span class="tok-nv">%h&lt;c&gt;</span> ~~ <span class="tok-nb">Rat</span>;

    <span class="tok-k">my</span> <span class="tok-nv">$a</span> = <span class="tok-nv">%h&lt;a&gt;</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$b</span> = <span class="tok-nv">%h&lt;b&gt;</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$c</span> = <span class="tok-nv">%h&lt;c&gt;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有点无聊，对吗？</p>
</div>
<div class="paragraph">
<p>Perl 签名参数解构来拯救你了！ 我们可以在子例程签名自身中做所有的事情 - 只要放一个子签名(sub-signature)在后面即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(<span class="tok-nv">%h</span> (<span class="tok-nb">Int</span> :<span class="tok-nv">$a</span>, <span class="tok-nb">Str</span> :<span class="tok-nv">$b</span>, <span class="tok-nb">Rat</span> :<span class="tok-nv">$c</span>)) {...}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解构_json">4.11. 解构 JSON</h3>
<div class="paragraph">
<p>相当不错，但如果你有<strong>更</strong>复杂的东西呢？</p>
</div>
<div class="paragraph">
<p>假如说一块儿有嵌套结构的 JSON，某些部分可能缺失了, 它们需要默认值, 等等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">JSON::Fast</span>;
<span class="tok-k">my</span> <span class="tok-nv">$item</span> = <span class="tok-n">from-json</span>(<span class="tok-s">q:to/END/);</span>
<span class="tok-s">    {</span>
<span class="tok-s">        &quot;book&quot; : {</span>
<span class="tok-s">            &quot;title&quot;  : &quot;A Christmas Carol&quot;,</span>
<span class="tok-s">            &quot;author&quot; : &quot;Charles Dickens&quot;</span>
<span class="tok-s">        },</span>
<span class="tok-s">        &quot;count&quot; : 12,</span>
<span class="tok-s">        &quot;tags&quot; : [ &quot;christmas&quot;, &quot;santa&quot;]</span>
<span class="tok-s">    }</span>
<span class="tok-s">    END</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>q:to/END/</code> 是一个 Perl 6 <a href="https://docs.perl6.org/language/quoting#index-entry-quote_heredocs_%3Ato-Heredocs%3A_%3Ato">heredoc</a>，它直接在文本中直到 END，然后我们可以使用 <a href="https://github.com/timo/json_fast">JSON::Fast</a> 的 <code>from-json()</code> 将其解析为 perl 中的数据结构。 你可以在函数签名中描述整个 JSON 结构，以便接收以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">myfunc</span>(% (:<span class="tok-nv">%book</span> (<span class="tok-nb">Str:D</span> :<span class="tok-nv">$title</span>, <span class="tok-nb">Str:D</span> :<span class="tok-nv">$author</span>), <span class="tok-nb">Int</span> :<span class="tok-nv">$count</span>,
              :<span class="tok-nv">@tags</span> (<span class="tok-nv">$first-tag</span>, *<span class="tok-nv">@other-tags</span>)) )
{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在函数体中，我可以将这些部分引用为 <code>$title</code>，<code>$author</code>，<code>$count`和 `@tags</code>。 为了方便起见，我还将标签分成了 <code>$first-tag</code> 和 <code>@other-tags</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在块儿中使用签名">4.12. 在块儿中使用签名</h3>
<div class="paragraph">
<p>当然，签名对于子程序来说是幻想的，但是你也可以在块儿(Block)中使用签名和解构。 假设你有一个上面的 JSON 条目的数组，并希望通过一个 <code>for</code> 循环遍历它们？ 只需在 <code>for</code> 的尖号块中使用解构签名即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">for</span> <span class="tok-nv">@itemlist</span> -&gt; % (:<span class="tok-nv">%book</span> (<span class="tok-nb">Str:D</span> :<span class="tok-nv">$title</span>, <span class="tok-nb">Str:D</span> :<span class="tok-nv">$author</span>), <span class="tok-nb">Int</span> :<span class="tok-nv">$count</span>,
                    :<span class="tok-nv">@tags</span> (<span class="tok-nv">$first-tag</span>, *<span class="tok-nv">@other-tags</span>))
{
    <span class="tok-nb">say</span> <span class="tok-s">&quot;$title, $author, $count, @tags[], $first-tag, @other-tags[]&quot;</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在这种情况下，我甚至不需要散列本身，所以我省略了散列的名称，仅使用 <code>％</code> 作为匿名散列（关联）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_你甚至可以解构对象">4.13. 你甚至可以解构对象!</h3>
<div class="paragraph">
<p>你有没有试过遍历一组对象，你所做的第一件事是调用一些访问器来获取一些属性？ 当然，你可以使用 <code>.attribute</code> 和 主题化的迭代器，但是使用子签名，你可以做更多。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">Book</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$.title</span>;
    <span class="tok-k">has</span> <span class="tok-nv">$.author</span>;
    <span class="tok-k">has</span> <span class="tok-nv">$.count</span>;
    <span class="tok-k">has</span> <span class="tok-nv">@.tags</span>;
}

<span class="tok-k">my</span> <span class="tok-nv">@booklist</span> =
    <span class="tok-n">Book</span>.<span class="tok-nb">new</span>(<span class="tok-n">title</span> =&gt; <span class="tok-s">&#39;A Christmas Carol&#39;</span>,
             <span class="tok-n">author</span> =&gt; <span class="tok-s">&#39;Charles Dickens&#39;</span>,
             <span class="tok-nb">count</span> =&gt; <span class="tok-mi">12</span>,
             <span class="tok-n">tags</span> =&gt; <span class="tok-s">&lt;ghost christmas&gt;</span>),

    <span class="tok-n">Book</span>.<span class="tok-nb">new</span>(<span class="tok-n">title</span> =&gt; <span class="tok-s">&#39;A Visit from St. Nicholas&#39;</span>,
             <span class="tok-n">author</span> =&gt; <span class="tok-s">&#39;Clement Clarke Moore&#39;</span>,
             <span class="tok-nb">count</span> =&gt; <span class="tok-mi">4</span>,
             <span class="tok-n">tags</span> =&gt; <span class="tok-s">&lt;santa christmas&gt;</span>);

<span class="tok-k">for</span> <span class="tok-nv">@booklist</span> -&gt; <span class="tok-n">Book</span> <span class="tok-nv">$b</span> (:<span class="tok-nv">$title</span>,:<span class="tok-nv">$author</span>, :<span class="tok-nv">$count</span>, :<span class="tok-nv">@tags</span>) {
    <span class="tok-nb">say</span> <span class="tok-s">&quot;$title, $author, $count, @tags[]&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想检查类型或定义，或设置默认值，您都可以在签名中正确地执行。 如果您不喜欢对象属性的名称，则可以使用别名来重命名它们, 你开心就行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_3">4.14. 结论</h3>
<div class="paragraph">
<p>我发现解构参数在与数据库查询结果和 JSON 交互中非常有用。 您可以使用任何其他签名特性，包括指定类型，定义，可选性，默认值，使用别名重命名，使用子集约束或“where”从句，slurpies等。</p>
</div>
<div class="paragraph">
<p>节日快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_perl_6_书籍">5. 第六天-Perl 6 书籍</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://perl6advent.wordpress.com/2017/12/06/" class="bare">https://perl6advent.wordpress.com/2017/12/06/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_测试所有的东西">6. 第七天 – 测试所有的东西</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Perl 6 与其大姐姐 Perl 5一样，具有很悠久的测试传统。当您安装任何 Perl 模块时，安装程​​序通常会运行该模块的测试套件。当然，作为新兴的 Perl 6 模块作者，您需要创建自己的测试套件。或者，也许你会在创建模块<strong>之前</strong>勇于创建测试套件。这实际上有几个好处，其中最主要的是你的第一个用户，甚至在它被写之前。</p>
</div>
<div class="paragraph">
<p>但在实际代码之前，我想提一下我经常使用的两个 shell 别名 -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span><span class="tok-nb">alias</span> <span class="tok-nv">6</span><span class="tok-o">=</span><span class="tok-s1">&#39;perl6 -Ilib&#39;</span>
<span class="tok-nb">alias</span> <span class="tok-nv">6p</span><span class="tok-o">=</span><span class="tok-s2">&quot;prove -e&#39;perl6 -Ilib&#39;&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些别名使我可以快速运行测试文件，而不必去安装我的代码。如果我在项目目录中，我可以运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ <span class="tok-m">6</span> t/01-core.t
ok <span class="tok-m">1</span> - call with number
ok <span class="tok-m">2</span> - call with text
ok <span class="tok-m">3</span> - call with formatted string
<span class="tok-m">1</span>..3</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会告诉我我运行了哪些测试以及它们是否全部通过。就像它的大姐姐Perl 5一样，Perl 6使用&#8217;t /'目录作为测试文件，并按照惯例使用后缀'.t&#8217;来区分测试文件和软件包或脚本。它还有一个内置的单元测试模块，我们在上面使用。如果我们正在测试sprintf（）内部，它可能看起来像</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Test</span>;

<span class="tok-nb">ok</span> <span class="tok-nb">sprintf</span>(<span class="tok-mi">1</span>), <span class="tok-s">&#39;call with number&#39;</span>;
<span class="tok-nb">ok</span> <span class="tok-nb">sprintf</span>(<span class="tok-s">&quot;text&quot;</span>), <span class="tok-s">&#39;call with text&#39;</span>;
<span class="tok-nb">ok</span> <span class="tok-nb">sprintf</span>(<span class="tok-s">&quot;%d&quot;</span>,<span class="tok-mi">1</span>), <span class="tok-s">&#39;call with formatted string&#39;</span>;

<span class="tok-n">done-testing</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ok和done-testing功能会自动导出给我们。我在这里使用规范的Perl 6风格，而不是太依赖括号。在这种情况下，我确实需要使用圆括号来确保sprintf（）不会“认为”“空调用”是它的参数。</p>
</div>
<div class="paragraph">
<p>OK只需要两个参数，你想要测试的真实性，以及一个可选的消息。如果第一个参数是任何评估为True的东西，则测试通过。否则&#8230;&#8203;&#8230;&#8203;你知道。该消息只是描述测试的文本。它纯粹是可选的，但当测试失败时它可以很方便，因为您可以在测试文件中搜索该字符串并快速找到问题。不过，如果你像作者一样，行号更有价值，所以当你看到的时候</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">not</span> <span class="tok-nb">ok</span> <span class="tok-mi">1</span> - <span class="tok-n">call</span> <span class="tok-n">with</span> <span class="tok-n">number</span>
<span class="tok-c1"># Failed test &#39;call with number&#39;</span>
<span class="tok-c1"># at test.t line 4</span>
<span class="tok-nb">ok</span> <span class="tok-mi">2</span> - <span class="tok-n">call</span> <span class="tok-n">with</span> <span class="tok-n">text</span>
<span class="tok-nb">ok</span> <span class="tok-mi">3</span> - <span class="tok-n">call</span> <span class="tok-n">with</span> <span class="tok-n">formatted</span> <span class="tok-n">string</span>
<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在您的测试中，您可以立即跳转到测试文件的第4行并开始编辑以找出问题所在。当你的测试文件变得越来越大时，这会变得更有用，例如我正在编写的Common Lisp版本（格式）的测试，每个测试文件超过200个测试并且不断增长。</p>
</div>
<div class="paragraph">
<p>最后，完成测试只是告诉测试模块我们已经完成了测试，没有更多的测试来了。当你刚刚开始时，这很方便，你不断尝试你的API，添加和更新测试。没有测试计数器来更新每次或任何其他机制来跟踪。</p>
</div>
<div class="paragraph">
<p>当然，这是可选的，但其他工具可能会在最后使用'1..3&#8217;来证明您的测试实际上已经完成。 Jenkins的单元测试和其他系统也可能需要这个工具。</p>
</div>
<div class="sect2">
<h3 id="_it_depends">6.1. It depends…</h3>
<div class="paragraph">
<p>你对&#8217;是&#8217;的定义是什么。如果你只关心某件事情的真实性，好的测试是好的，但有时你需要深入一点。 Perl 6就像它的大姐姐一样可以帮助你。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">is</span> <span class="tok-mi">1</span> + <span class="tok-mi">1</span>, <span class="tok-mi">2</span>, <span class="tok-s">&#39;prop. 54.43, Principia Mathematica&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不只是检查你的测试的真实性，它会检查它的价值。虽然你可以很容易地写这个</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">ok</span> <span class="tok-mi">1</span> + <span class="tok-mi">1</span> == <span class="tok-mi">2</span>, <span class="tok-s">&#39;prop. 54.43, Principia Mathematica&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用是使你的意图明确，你关注的是表达式1 + 1是否等于2;与同一语句的ok版本一样，目前还不清楚您是在测试'1 + 1&#8217;部分还是'=='运算符。</p>
</div>
<div class="paragraph">
<p>这两个测试本身可能占据您测试需求的80％，处理基本列表和哈希时相对安全，如果您真的需要复杂的测试，那么它的大姐姐正在站在脚边，准备处理复杂的哈希阵列组合。</p>
</div>
</div>
<div class="sect2">
<h3 id="_懒惰和不耐烦">6.2. 懒惰和不耐烦</h3>
<div class="paragraph">
<p>有时你会有一个巨大的字符串，你只需要检查一下它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">ok</span> <span class="tok-s">&#39;Lake Char­gogg­a­gogg­man­chaugg­a­gogg­chau­bun­a­gung­a­maugg&#39;</span> ~~ <span class="tok-s">&#39;manchau&#39;</span>, <span class="tok-s">&#39;my side&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你当然可以在这里使用~~运算符。就像'1 + 1 == 2&#8217;一样，但是你的意图可能并不明确。你可以使用类似的方法来明确你的意图。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">like</span> <span class="tok-s">&#39;Lake Char­gogg­a­gogg­man­chaugg­a­gogg­chau­bun­a­gung­a­maugg&#39;</span>,<span class="tok-sr"></span>
<span class="tok-sr">     /manchau/</span>, <span class="tok-s">&#39;my side&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并没有~~悬在你的船边。</p>
</div>
</div>
<div class="sect2">
<h3 id="_晾干">6.3. 晾干</h3>
<div class="paragraph">
<p>在美丽的Lake Chargoggagoggmanchauggagoggchaubunagungamaugg度过一段时间后，你可能想把你的衣服拧干。测试文件往往会增长，特别是回归测试。你可能会发现自己写作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;1&#39;</span> ), <span class="tok-s">&#39;1&#39;</span>, <span class="tok-s">&quot;%s formats numbers&quot;</span>;
<span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;⅑&#39;</span> ), <span class="tok-s">&#39;⅑&#39;</span>, <span class="tok-s">&quot;%s formats fractions&quot;</span>;
<span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;Ⅷ&#39;</span> ), <span class="tok-s">&#39;Ⅷ&#39;</span>, <span class="tok-s">&quot;%s formats graphemes&quot;</span>;
<span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;三&#39;</span> ), <span class="tok-s">&#39;三&#39;</span>, <span class="tok-s">&quot;%s formats CJKV&quot;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好，复制和粘贴（特别是从StackOverflow）是一个悠久的传统，没有错。不过考虑一下，当你使用“％d”而不是“％s”添加更多测试时会发生什么情况，并且由于所有这些字符串都是数字，因此您只需复制并粘贴该块，将“％s”更改为“％d”，然后继续。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;1&#39;</span> ), <span class="tok-s">&#39;1&#39;</span>, <span class="tok-s">&quot;%s formats numbers&#39;;</span>
<span class="tok-s"># ...</span>

<span class="tok-s">is sprintf( &quot;</span><span class="tok-nv">%d</span>, <span class="tok-s">&#39;1&#39;</span> ), <span class="tok-s">&#39;1&#39;</span>, &quot;<span class="tok-nv">%d</span> <span class="tok-n">formats</span> <span class="tok-n">numbers&#39;</span>;
<span class="tok-c1"># ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在你已经有了两组测试，名称相同。而不是编辑所有新的“％d”测试，如果我们不必首先重复自己的话，这会不会很好？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">subtest</span> <span class="tok-s">&#39;%s&#39;</span>, {
    <span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;1&#39;</span> ), <span class="tok-s">&#39;1&#39;</span>, <span class="tok-s">&quot;formats numbers&quot;</span>;
    <span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;⅑&#39;</span> ), <span class="tok-s">&#39;⅑&#39;</span>, <span class="tok-s">&quot;formats fractions&quot;</span>;
    <span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;Ⅷ&#39;</span> ), <span class="tok-s">&#39;Ⅷ&#39;</span>, <span class="tok-s">&quot;formats graphemes&quot;</span>;
    <span class="tok-k">is</span> <span class="tok-nb">sprintf</span>( <span class="tok-s">&quot;%s&quot;</span>, <span class="tok-s">&#39;三&#39;</span> ), <span class="tok-s">&#39;三&#39;</span>, <span class="tok-s">&quot;formats CJKV&quot;</span>;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在你只需要在两个地方而不是三个地方进行编辑。如果这激发了您对测试的兴趣，我鼓励您在我的个人网站上查看<a href="http://theperlfisher.blogspot.cz/2017/11/test-all-things.html">测试所有事情</a>以获得更高级的测试范例和更高级的 Perl 6 代码。另外不要忘记关注明天的 Perl 6 Advent 发布！</p>
</div>
<div class="paragraph">
<p>谢谢你，快乐的黑客！</p>
</div>
<div class="paragraph">
<p>DrForr 又名 Jeff Goff，<a href="http://theperlfisher.blogspot.cz/">Perl Fisher</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_adventures_in_nqp_land_hacking_the_rakudo_compiler">7. 第八天 - Adventures in NQP Land: Hacking the Rakudo Compiler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对旧圣诞节经典“圣诞节十二天”的道歉，我给你一个 Perl 6 版本的第一行：</p>
</div>
<div class="paragraph">
<p>在圣诞节的第一天，我真正的爱给了 pod 树上的 Perl 表格&#8230;&#8203;&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>但是我得到的表格不是很漂亮！</p>
</div>
<div class="sect2">
<h3 id="_背景">7.1. 背景</h3>
<div class="paragraph">
<p>我与 Perl 6 的第一次真正联系是在 2015 年春天，当时我决定检查它的状态，发现它已经准备好迎接黄金时段。在获得了该语言的一些经验之后，我开始在我可以提供帮助的地方贡献文档。我对文档的第一个贡献是清理其中没有很好呈现的表格。在我对本地主机上的 pod 表进行实验期间，我尝试了下表格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-cm">=begin table</span>
<span class="tok-cm">-r0c0  r0c1</span>
<span class="tok-cm">=end table</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致 Perl 6 抛出一个丑陋的, LTA（非常搓）的异常消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-s">&quot;===SORRY!=== Cannot iterate object with P6opaque representation&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我解决了这个问题，但它让我感觉不爽，所以我开始调查 pod 和 tables 的内部。这导致我在 <a href="https://github.com/rakudo/rakudo/blob/master/src/Perl6/Pod.nqp">github.com/rakudo/src/Perl6/Pod.nqp</a> 中发现了问题的根源。</p>
</div>
<div class="paragraph">
<p>事实上，许多 pod 表格问题的真正问题最终都出现在该文件中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_not_quite_perl_nqp">7.2. Not Quite Perl (NQP)</h3>
<div class="paragraph">
<p>nqp 是用于构建 Rakudo Perl 6 编译器的中间语言。它的 git 仓库在<a href="https://github.com/perl6/nqp">这里</a>。本文的其余部分是关于修改 rakudo 编译器中的 nqp 代码，其仓库地址在<a href="https://github.com/rakudo/rakudo">这里</a>。 Rakudo 在<a href="http://rakudo.org/">这里</a>也有一个网站。</p>
</div>
<div class="paragraph">
<p>在走得太远之前，我首先阅读有关 Rakudo 和 NQP 的可用信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jonathan Worthington’s (JWs) 的幻灯片课程 <a href="http://edumentab.github.io/rakudo-and-nqp-internals-course/">Rakudo and NQP Internals</a></p>
</li>
<li>
<p><a href="https://github.com/perl6/nqp/blob/master/docs/ops.markdown">NQP opcodes</a></p>
</li>
<li>
<p><a href="https://github.com/perl6/nqp/blob/master/docs/built-ins.md">NQP built-in routines</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后我开始通过编写和运行一些这样的小型 nqp 文件来练习nqp编码（文件 “hello.nqp”）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="nqp"><span></span>say(&quot;Hello, world!&quot;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当它被执行时，会给出预期的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ nqp hello.nqp
Hello, world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>say()</code> 是不需要 <code>nqp::</code> 前缀的少数 nqp opcodes 之一。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进入战壕">7.3. 进入战壕</h3>
<div class="paragraph">
<p><code>rakudo/src/Perl6/Pod.nqp</code> 文件中包含的 <code>Perl6::Pod</code> 类的用途是将 pod grammar 匹配并将它们转换为 <code>rakudo/src/core/Pod.pm</code> 中的 Perl 6 pod 类定义，供 Perl 6 领地上的渲染者进一步处理。对于表格，表示以 Perl 6 文档设计中描述的任何合法 pod 格式表示的内容概要 S26，Perl 6 测试套件规范和 Perl 6 文档必须转换为 Perl 6 <strong>Pod::Block::Table</strong> 类如文件 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Pod.pm">rakudo/src/core/Pod.pm</a> 中所述，使用此格式的对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">configuration</span> <span class="tok-n">information</span>
<span class="tok-n">a</span> <span class="tok-n">header</span> <span class="tok-n">line</span> <span class="tok-n">with</span> <span class="tok-n">N</span> <span class="tok-n">cells</span>
<span class="tok-n">M</span> <span class="tok-n">content</span> <span class="tok-nb">lines</span>, <span class="tok-nb">each</span> <span class="tok-n">with</span> <span class="tok-n">N</span> <span class="tok-n">cells</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我希望 nqp 表格 pod 处理功能非常强大，能够自动修复某些格式问题（给作者一个警告），或者抛出一个异常（优雅）并提供问题的详细信息，以便作者修复 pod 输入。</p>
</div>
</div>
<div class="sect2">
<h3 id="_工作区和工具">7.4. 工作区和工具</h3>
<div class="paragraph">
<p>我需要两个克隆版本库：rakudo 和 roast。我还需要在 github 上复刻那些相同的git 仓库，所以我可以为我的更改创建 pull 请求（PR）。我在 CPAN 模块 <a href="https://metacpan.org/pod/distribution/App-GitGot/bin/got">App::GitGot</a> 中找到了非常方便的 Perl 5 工具。使用 <strong>got</strong> 允许我轻松设置所有四个仓库。 （请注意，got 得要求其目标 repo 不存在于所需的本地目录或用户的github 帐户中。）配置完成后，我去了一个合适的目录以包含两个 repos 并执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">got</span> <span class="tok-nb">fork</span> <span class="tok-n">https:</span>//<span class="tok-n">github</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">rakudo</span><span class="tok-o">/</span><span class="tok-n">rakudo</span>.<span class="tok-n">git</span>
<span class="tok-n">got</span> <span class="tok-nb">fork</span> <span class="tok-n">https:</span>//<span class="tok-n">github</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">perl6</span><span class="tok-o">/</span><span class="tok-n">roast</span>.<span class="tok-n">git</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致了一个子目录rakudo和 roast 包含克隆仓库和 rakudo 和 roast github 帐户上的新复刻。在 rakudo 目录中，可以看到用于轻松创建 PR 的默认设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ git remote -v
origin  git@github.com:tbrowder/rakudo.git <span class="tok-o">(</span>fetch<span class="tok-o">)</span>
origin  git@github.com:tbrowder/rakudo.git <span class="tok-o">(</span>push<span class="tok-o">)</span>
upstream    https://github.com/rakudo/rakudo.git <span class="tok-o">(</span>fetch<span class="tok-o">)</span>
upstream    https://github.com/rakudo/rakudo.git <span class="tok-o">(</span>push<span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 roast 仓库中有类似的结果。</p>
</div>
<div class="paragraph">
<p>接下来，我将 roast 仓库作为 rakudo 的子目录（“rakudo/t/spec”）重命名，所以它作为本地 rakudo 的一个子集。</p>
</div>
<div class="paragraph">
<p>最后，我创建了几个 bash 脚本，以便于在本地 repo 目录中配置 rakudo 进行安装，设置环境并运行测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>rakudo-local-config.sh</p>
</li>
<li>
<p>run-table-tests.sh</p>
</li>
<li>
<p>set-rakudo-envvars.sh</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>（请参阅 <a href="https://github.com/tbrowder/nqp-tools">https://github.com/tbrowder/nqp-tools</a> 上提到的所有脚本。）</p>
</div>
<div class="paragraph">
<p>要完成本地工作环境，您需要安装一些本地模块，以便您必须更改路径并安装 zef 安装程序的本地副本。在 rakudo 目录中执行以下步骤（来自 <a href="https://perl6advent.wordpress.com/mentions/zoffix/">@Zoffix</a> 的建议）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>git clone https://github.com/ugexe/zef
<span class="tok-nb">export</span> <span class="tok-nv">PATH</span><span class="tok-o">=</span><span class="tok-sb">`</span><span class="tok-nb">pwd</span><span class="tok-sb">`</span>/install/bin:<span class="tok-nv">$PATH</span>
<span class="tok-nb">cd</span> zef<span class="tok-p">;</span> perl6 -Ilib bin/zef install .
<span class="tok-nb">cd</span> ..
<span class="tok-nb">export</span> <span class="tok-nv">PATH</span><span class="tok-o">=</span><span class="tok-sb">`</span><span class="tok-nb">pwd</span><span class="tok-sb">`</span>/install/share/perl6/site/bin:<span class="tok-nv">$PATH</span>
zef install Inline::Perl5</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后安装您需要的其他模块，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>zef install Debugger::UI::CommandLine
zef install Grammar::Debugger</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hacking">7.5. Hacking</h3>
<div class="paragraph">
<p>现在开始黑客入侵。准备好构建时，执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>make
make install</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>make install</code> 步骤非常关键，否则，在我们设置的本地环境中，将不会找到新的 Perl 6 可执行文件。</p>
</div>
<div class="paragraph">
<p>调试于我来说很费力，每次重建需要大约三分钟。调试器（perl6-debug-m）会非常有用，但我无法安装所需的 <code>Debbugger::UI::CommandLine</code> 模块，因此它可以被本地安装的 <code>perl6-debug-m</code> 识别。我使用的主要方法是插入print 语句，并使用 perl6 的 <code>--ll-exception</code> 选项。值得注意的是，这位作者是一位 Perl 6 新手，犯了很多错误，并且并不总是记得修复，因此有了这篇文章。 （注意我可能会使用调试工具，但在我开始的时候，我没有要求帮助，也没有提供上面提供的建议。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试">7.6. 测试</h3>
<div class="paragraph">
<p>不言而喻，一个好的 PR 将包括对变化的测试。我总是创建一个与我的 rakudo 分支同名的 roast 分支。然后我提交了两个 PR，我指的是 rakudo PR 中的 toast PR，反之亦然。我注意到 toast PR，它需要伴生 rakudo PR 通过所有测试。</p>
</div>
<div class="paragraph">
<p>见参考文献5 了解更多有关专门测试脚本的详细信息，以进行欺骗和其他深奥测试事宜。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">7.7. 文档</h3>
<div class="paragraph">
<p>我尝试将我的修复程序保留在最新的 <a href="https://docs.perl6.org/language/tables">Perl 6 pod 表格文档</a>中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_nqp_经验教训">7.8. NQP 经验教训</h3>
<div class="ulist">
<ul>
<li>
<p>LTA 错误消息是生活中的事实，例如，“无法调用此对象&#8230;&#8203;”，这可能是由很多事情造成的，包括拼写错误的标识符（提交 NQP 问题，早期报告可能不会很快修复）。</p>
</li>
<li>
<p>确保所有 nqp 操作码都有 <code>nqp::</code> 前缀（除了少数内置函数）</p>
</li>
<li>
<p>在 nqp 专用沙箱中练习新代码。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_成功">7.9. 成功！</h3>
<div class="paragraph">
<p>现在我已经接受并合并了两个主要的Perl 6 POD（和 toast）PR，并且我正在研究一个更“容易”的，我将在本周完成。 这些 PR 是：</p>
</div>
<div class="paragraph">
<p>1.Rakudo PR＃1240
这个 <a href="https://github.com/rakudo/rakudo/pull/1240">Rakudo PR</a>  为 RT＃124403，＃128221，＃132341，＃13248和＃129862提供了修复程序。它伴随着 toast <a href="https://github.com/perl6/roast/pull/353">PR＃353</a>。</p>
</div>
<div class="paragraph">
<p>这个 PR 允许上面的问题表格被正确渲染。它还添加了有问题的表的警告，添加了 Rakudo 环境变量RAKUDO_POD6_TABLE_DEBUG 以帮助用户调试表（请参阅文档，<a href="https://docs.perl6.org/programs/00-running#Environment_Variables">用户调试</a>），并允许具有空列的短行正确呈现。</p>
</div>
<div class="paragraph">
<p>2.Rakudo PR＃1287
这个 <a href="https://github.com/rakudo/rakudo/pull/1287">Rakudo PR</a> 为 Rakudo repo 问题＃1282提供了一个解决方案。它伴随着 roast <a href="https://github.com/perl6/roast/pull/361">PR＃361</a>。 （请注意，roast PR＃361 尚未合并。）</p>
</div>
<div class="paragraph">
<p>这个 PR 允许表格视觉列分隔符（'|'）和（'+'）作为单元格数据通过在 pod 源中转义它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">7.10. 总结</h3>
<div class="ulist">
<ul>
<li>
<p>Perl 6 pod相对于Perl 5来说是一个很大的改进，但它还没有完全实现。</p>
</li>
<li>
<p>在 Rakudo Perl的内部工作是有益的（并且很有趣），但是准备让你的手变脏！</p>
</li>
<li>
<p>Perl 6 社区是一个很好的团队。</p>
</li>
<li>
<p>我喜欢 Rakudo Perl 6。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>圣诞快乐，Hacking 快乐！</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考">7.11. 参考</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>JWs Perl 6 debugger <a href="https://perl6advent.wordpress.com/2012/12/05/a-perl-6-debugger/">Advent article</a></p>
</li>
<li>
<p>JWs Rakudo debugger module <a href="https://github.com/jnthn/rakudo-debugger">Debugger::UI::CommandLine</a></p>
</li>
<li>
<p>JWs grammar debugger module <a href="https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a></p>
</li>
<li>
<p><a href="https://github.com/perl6/roast/blob/master/README.md">Testing Rakudo</a></p>
</li>
<li>
<p><a href="https://github.com/perl6/roast/blob/master/CONTRIBUTING.md">Contributing to roast</a></p>
</li>
<li>
<p><a href="https://help.github.com/categories/collaborating-with-issues-and-pull-requests/">Github guide to pull requests (PRs)</a></p>
</li>
<li>
<p><a href="https://docs.perl6.org/">Perl 6 documentation (<strong>docs</strong>)</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_附录">7.12. 附录</h3>
<div class="paragraph">
<p>POD 工具</p>
</div>
<div class="ulist">
<ul>
<li>
<p>perl6 –doc=MODULE # where ‘MODULE’ is ‘HTML’, ‘Text’, 或其它合适的模块</p>
</li>
<li>
<p>p6doc</p>
</li>
<li>
<p>perl6 –ll-exception</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_主要的_perl_6_pod_渲染器">7.13. 主要的 Perl 6 POD 渲染器</h3>
<div class="ulist">
<ul>
<li>
<p>Pod::To::Text (part of the rakudo core)</p>
</li>
<li>
<p><a href="https://github.com/perl6/Pod-To-HTML">Pod::To::HTML</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_http_and_web_sockets_with_cro">8. 第九天 – HTTP and Web Sockets with Cro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>礼物不仅仅是圣诞节的时候才有。今年夏天，在瑞士 Perl 工作室 - 精美地坐落在阿尔卑斯山 - 我有幸透露了 <a href="http://cro.services/">Cro</a>。 Cro 是一组用于在 Perl 6 中构建服务的库，以及一些用于 stub，run 和跟踪服务的开发工具。 Cro 主要关注使用 HTTP（包括HTTP/2.0）和 Web 套接字构建服务，但可以提供对 ZeroMQ 的早期支持，并计划在未来推出一系列其他选项。</p>
</div>
<div class="sect2">
<h3 id="_响应式管道">8.1. 响应式管道</h3>
<div class="paragraph">
<p>Cro 遵循 Perl 的设计原则，使简单的事情变得简单，并且让困难的事情变得可能。就像 Git 一样，Cro 可以被认为是具有瓷器（使简单的事情变得简单）和管道（使困难的事情成为可能）。管道水平由组成管道的组件组成。这些组件具有不同的形状，例如源，传输和下沉。这是一个将 HTTP 请求转换为 HTTP 响应的转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Cro</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Request</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Response</span>;

<span class="tok-k">class</span> <span class="tok-n">MuskoxApp</span> <span class="tok-nb">does</span> <span class="tok-n">Cro::Transform</span> {
    <span class="tok-k">method</span> <span class="tok-n">consumes</span>() { <span class="tok-n">Cro::HTTP::Request</span> }
    <span class="tok-k">method</span> <span class="tok-n">produces</span>() { <span class="tok-n">Cro::HTTP::Response</span> }
    <span class="tok-k">method</span> <span class="tok-n">transformer</span>(<span class="tok-n">Supply</span> <span class="tok-nv">$pipeline</span> --&gt; <span class="tok-n">Supply</span>) {
        <span class="tok-n">supply</span> <span class="tok-n">whenever</span> <span class="tok-nv">$pipeline</span> -&gt; <span class="tok-nv">$request</span> {
            <span class="tok-k">given</span> <span class="tok-n">Cro::HTTP::Response</span>.<span class="tok-nb">new</span>(:<span class="tok-nv">$request</span>, :<span class="tok-mi">200</span><span class="tok-n">status</span>) {
                .<span class="tok-n">append-header:</span> <span class="tok-s">&quot;Content-type&quot;</span>, <span class="tok-s">&quot;text/html&quot;</span>;
                .<span class="tok-n">set-body:</span> <span class="tok-s">&quot;Muskox Rocks!\n&quot;</span>.<span class="tok-n">encode</span>(<span class="tok-s">&#39;ascii&#39;</span>);
                .<span class="tok-n">emit</span>;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们用一个 TCP 监听器，一个 HTTP 请求解析器和一个 HTTP 响应序列化器来编写它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Cro::TCP</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::RequestParser</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::ResponseSerializer</span>;

<span class="tok-k">my</span> <span class="tok-nv">$server</span> = <span class="tok-n">Cro</span>.<span class="tok-n">compose:</span>
    <span class="tok-n">Cro::TCP::Listener</span>.<span class="tok-nb">new</span>(:<span class="tok-n">port</span>(<span class="tok-mi">4242</span>)),
    <span class="tok-n">Cro::HTTP::RequestParser</span>.<span class="tok-nb">new</span>,
    <span class="tok-n">MuskoxApp</span>,
    <span class="tok-n">Cro::HTTP::ResponseSerializer</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这将返回一个Cro </dt>
<dd>
<p>Service，我们现在可以启动，并在Ctrl + C时停止：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nv">$server</span>.<span class="tok-n">start</span>;
<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) {
    <span class="tok-nv">$server</span>.<span class="tok-n">stop</span>;
    <span class="tok-k">exit</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行。然后 <code>curl</code> 它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">curl</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:4242</span>/
<span class="tok-n">Muskox</span> <span class="tok-n">Rocks</span>!</code></pre>
</div>
</div>
<div class="paragraph">
<p>不错。但是如果我们想要一个HTTPS服务器呢？如果我们有方便的关键和证书文件，这只是一个用TLS监听器替换TCP监听器的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Cro::TLS</span>;

<span class="tok-k">my</span> <span class="tok-nv">$server</span> = <span class="tok-n">Cro</span>.<span class="tok-n">compose:</span>
    <span class="tok-n">Cro::TLS::Listener</span>.<span class="tok-nb">new</span>(
        :<span class="tok-n">port</span>(<span class="tok-mi">4242</span>),
        :<span class="tok-n">certificate-file</span>(<span class="tok-s">&#39;certs-and-keys/server-crt.pem&#39;</span>),
        :<span class="tok-n">private-key-file</span>(<span class="tok-s">&#39;certs-and-keys/server-key.pem&#39;</span>)
    ),
    <span class="tok-n">Cro::HTTP::RequestParser</span>.<span class="tok-nb">new</span>,
    <span class="tok-n">MuskoxApp</span>,
    <span class="tok-n">Cro::HTTP::ResponseSerializer</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行。然后 <code>curl -k</code> 它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">curl</span> -<span class="tok-n">k</span> <span class="tok-n">https:</span>//<span class="tok-n">localhost:4242</span>/
<span class="tok-n">Muskox</span> <span class="tok-n">Rocks</span>!</code></pre>
</div>
</div>
<div class="paragraph">
<p>和中间件？这只是构成管道的另一个组成部分。或者，从另一个角度来看，对于Cro，一切都是中间件。即使请求解析器或响应序列化器可以很容易地被替换，如果需要的话（这听起来像是一件奇怪的事情需要，但这实际上是实现FastCGI会涉及的）。</p>
</div>
<div class="paragraph">
<p>所以，这就是克罗的方式。它还需要大量的样板才能在此级别上工作。带上瓷器！</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_服务器简单的方法">8.2. HTTP 服务器，简单的方法</h3>
<div class="paragraph">
<p>Cro::HTTP::Server 类摆脱了构建 HTTP 处理管道的样板。从前面的例子变成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Cro</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Server</span>;

<span class="tok-k">class</span> <span class="tok-n">MuskoxApp</span> <span class="tok-nb">does</span> <span class="tok-n">Cro::Transform</span> {
    <span class="tok-k">method</span> <span class="tok-n">consumes</span>() { <span class="tok-n">Cro::HTTP::Request</span> }
    <span class="tok-k">method</span> <span class="tok-n">produces</span>() { <span class="tok-n">Cro::HTTP::Response</span> }
    <span class="tok-k">method</span> <span class="tok-n">transformer</span>(<span class="tok-n">Supply</span> <span class="tok-nv">$pipeline</span> --&gt; <span class="tok-n">Supply</span>) {
        <span class="tok-n">supply</span> <span class="tok-n">whenever</span> <span class="tok-nv">$pipeline</span> -&gt; <span class="tok-nv">$request</span> {
            <span class="tok-k">given</span> <span class="tok-n">Cro::HTTP::Response</span>.<span class="tok-nb">new</span>(:<span class="tok-nv">$request</span>, :<span class="tok-mi">200</span><span class="tok-n">status</span>) {
                .<span class="tok-n">append-header:</span> <span class="tok-s">&quot;Content-type&quot;</span>, <span class="tok-s">&quot;text/html&quot;</span>;
                .<span class="tok-n">set-body:</span> <span class="tok-s">&quot;Muskox Rocks!\n&quot;</span>.<span class="tok-n">encode</span>(<span class="tok-s">&#39;ascii&#39;</span>);
                .<span class="tok-n">emit</span>;
            }
        }
    }
}

<span class="tok-k">my</span> <span class="tok-nv">$server</span> = <span class="tok-n">Cro::HTTP::Server</span>.<span class="tok-n">new:</span> :<span class="tok-n">port</span>(<span class="tok-mi">4242</span>), :<span class="tok-n">application</span>(<span class="tok-n">MuskoxApp</span>);
<span class="tok-nv">$server</span>.<span class="tok-n">start</span>;
<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) {
    <span class="tok-nv">$server</span>.<span class="tok-n">stop</span>;
    <span class="tok-k">exit</span>;
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这里没有魔法;它真的只是一个更方便的方式来组成一条管线。虽然这只是对HTTP / 1. *的节省，但HTTP / 2.0管道涉及更多的组件，而支持这两者的管道仍然更为复杂。相比之下，配置Cro </dt>
<dd>
<p>HTTP :: Server可以轻松地完成支持HTTP / 1.1和HTTP / 2.0的HTTPS：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">%tls</span> =
    :<span class="tok-n">certificate-file</span>(<span class="tok-s">&#39;certs-and-keys/server-crt.pem&#39;</span>),
    :<span class="tok-n">private-key-file</span>(<span class="tok-s">&#39;certs-and-keys/server-key.pem&#39;</span>);
<span class="tok-k">my</span> <span class="tok-nv">$server</span> = <span class="tok-n">Cro::HTTP::Server</span>.<span class="tok-n">new:</span> :<span class="tok-n">port</span>(<span class="tok-mi">4242</span>), :<span class="tok-n">application</span>(<span class="tok-n">MuskoxApp</span>),
    :<span class="tok-nv">%tls</span>, :<span class="tok-n">http</span><span class="tok-s">&lt;1.1 2&gt;</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_通向幸福的途径">8.3. 通向幸福的途径</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Cro中的Web应用程序最终总是将HTTP请求转换为HTTP响应的转换。然而，想要以完全相同的方式处理所有请求的情况非常罕见。通常，不同的URL应该路由到不同的处理程序。输入Cro </dt>
<dd>
<p>HTTP :: Router：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Router</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Server</span>;

<span class="tok-k">my</span> <span class="tok-nv">$application</span> = <span class="tok-n">route</span> {
    <span class="tok-n">get</span> -&gt; {
        <span class="tok-n">content</span> <span class="tok-s">&#39;text/html&#39;</span>, <span class="tok-s">&#39;Do you like dugongs?&#39;</span>;
    }
}

<span class="tok-k">my</span> <span class="tok-nv">$server</span> = <span class="tok-n">Cro::HTTP::Server</span>.<span class="tok-n">new:</span> :<span class="tok-n">port</span>(<span class="tok-mi">4242</span>), :<span class="tok-nv">$application</span>;
<span class="tok-nv">$server</span>.<span class="tok-n">start</span>;
<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) {
    <span class="tok-nv">$server</span>.<span class="tok-n">stop</span>;
    <span class="tok-k">exit</span>;
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">路由块返回的对象执行Cro </dt>
<dd>
<p>Transform角色，这意味着它可以很好地与Cro.compose（&#8230;&#8203;）配合使用。然而，使用路由器编写应用程序会更方便一些！让我们看看更仔细一点：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; {
    <span class="tok-n">content</span> <span class="tok-s">&#39;text/html&#39;</span>, <span class="tok-s">&#39;Do you like dugongs?&#39;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，get是说这个处理程序只处理HTTP GET请求。尖头块的空签名意味着不需要URL段，所以该路由仅适用于/。然后，而不是必须做一个响应对象实例，添加一个头，并编码一个字符串，内容函数完成这一切。</p>
</div>
<div class="paragraph">
<p>路由器是为了利用Perl 6签名而建立的，同时也可以让Perl 6程序员感觉自然。路由段通过声明参数来建立，而文字串段恰好匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;product&#39;</span>, <span class="tok-nv">$id</span> {
    <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, {
        <span class="tok-n">id</span> =&gt; <span class="tok-nv">$id</span>,
        <span class="tok-nb">name</span> =&gt; <span class="tok-s">&#39;Arctic fox photo on canvas&#39;</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用curl进行快速检查表明，它还负责为我们序列化JSON：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">curl</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:4242</span><span class="tok-o">/</span><span class="tok-n">product</span><span class="tok-o">/</span><span class="tok-mi">42</span>
{<span class="tok-s">&quot;name&quot;</span>: <span class="tok-s">&quot;Arctic fox photo on canvas&quot;</span>,<span class="tok-s">&quot;id&quot;</span>: <span class="tok-s">&quot;42&quot;</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON正文序列化程序由内容类型激活。这是可能的，也很简单，可以实现并插入自己的身体序列器。</p>
</div>
<div class="paragraph">
<p>想要捕获多个网址段？ Slurpy参数也可以工作，这对于服务静态资产时可以很方便地与静态结合使用，也许深层次的多级目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;css&#39;</span>, *<span class="tok-nv">@path</span> {
    <span class="tok-n">static</span> <span class="tok-s">&#39;assets/css&#39;</span>, <span class="tok-nv">@path</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可选参数适用于可能提供或可能不提供的段。使用子集类型来限制允许的值也可以。 Int只接受URL段中的值以整数形式解析的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;product&#39;</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$id</span> {
    <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, {
        <span class="tok-n">id</span> =&gt; <span class="tok-nv">$id</span>,
        <span class="tok-nb">name</span> =&gt; <span class="tok-s">&#39;Arctic fox photo on canvas&#39;</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数用于接收查询字符串参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;search&#39;</span>, :<span class="tok-nv">$query</span> {
    <span class="tok-n">content</span> <span class="tok-s">&#39;text/plain&#39;</span>, <span class="tok-s">&quot;You searched for $query&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将填充在这样的请求中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">curl</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:4242</span><span class="tok-o">/</span><span class="tok-n">search</span><span class="tok-o">?</span><span class="tok-n">query</span>=<span class="tok-n">llama</span>
<span class="tok-n">You</span> <span class="tok-n">searched</span> <span class="tok-k">for</span> <span class="tok-n">llama</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些也可以是类型约束和/或需要的（命名参数在Perl 6中默认是可选的）。 Cro路由器试图帮助你做好HTTP，方法是给出一个404错误来匹配一个URL段，405（方法不允许），当段匹配但是使用了错误的方法时，400当方法和段很好时，但查询字符串有问题。通过使用is标头并且是cookie特征的命名参数也可以用于接受和/或限制标头和cookie。</p>
</div>
<div class="paragraph">
<p>路由器将所有路由编译成Perl 6语法，而不是一次一个地浏览路由。这意味着路线将使用NFA进行匹配，而不是一次一个地突破。此外，这意味着应用Perl 6最长的文字前缀规则，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;product&#39;</span>, <span class="tok-s">&#39;index&#39;</span> { ... }
<span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;product&#39;</span>, <span class="tok-nv">$what</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使您按照相反的顺序编写了这些请求，它们总是会优先选择这两项中的第一项作为/ product / index的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;product&#39;</span>, <span class="tok-nv">$what</span> { ... }
<span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;product&#39;</span>, <span class="tok-s">&#39;index&#39;</span> { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_中间件变得更容易">8.4. 中间件变得更容易</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">有趣的是，HTTP中间件只是一个Cro </dt>
<dd>
<p>Transform，但如果Cro是所有产品的话，那么写起来会不太有趣。令人高兴的是，有一些更简单的选择。路径块可以包含块之前和之后的块，这些块将在块中的任何路由处理之前和之后运行。因此，可以将HSTS标头添加到所有响应中：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$application</span> = <span class="tok-n">route</span> {
    <span class="tok-o">after</span> {
        <span class="tok-n">header</span> <span class="tok-s">&#39;Strict-transport-security&#39;</span>, <span class="tok-s">&#39;max-age=31536000; includeSubDomains&#39;</span>;
    }
    <span class="tok-c1"># Routes here...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者对没有授权标头的所有请求使用HTTP 403 Forbidden进行响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$application</span> = <span class="tok-n">route</span> {
    <span class="tok-o">before</span> {
        <span class="tok-k">unless</span> .<span class="tok-n">has-header</span>(<span class="tok-s">&#39;Authorization&#39;</span>) {
            <span class="tok-n">forbidden</span> <span class="tok-s">&#39;text/plain&#39;</span>, <span class="tok-s">&#39;Missing authorization&#39;</span>;
        }
    }
    <span class="tok-c1"># Routes here...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其行为如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">curl</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:4242</span>/
<span class="tok-n">Missing</span> <span class="tok-n">authorization</span>
$ <span class="tok-n">curl</span> -<span class="tok-n">H</span><span class="tok-s">&quot;Authorization: Token 123&quot;</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:4242</span>/
<span class="tok-s">&lt;strong&gt;</span><span class="tok-n">Do</span> <span class="tok-n">you</span> <span class="tok-nb">like</span> <span class="tok-n">dugongs</span>?<span class="tok-s">&lt;/strong&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_这只是一个供应链supply_chain">8.5. 这只是一个供应链(Supply chain)</h3>
<div class="paragraph">
<p>所有的Cro实际上只是构建一系列Perl 6 Supply对象的一种方式。尽管中间件块之前和之后都很方便，但将中间件作为转换编写，无论何时使用语法，都可以访问Perl 6电源的全部功能。因此，如果您需要使用会话令牌进行请求并对会话数据库进行异步调用，并且只有发出请求才能进行进一步处理（或者重定向到登录页面），则可以这样做 - 阻止其他请求（包括同一连接上的请求）。</p>
</div>
<div class="paragraph">
<p>事实上，Cro完全是根据更高级别的Perl 6并发功能构建的。没有明确的线程，也没有明确的锁定。相反，所有并发都是以Perl 6 Supply和Promise的形式表示的，并且由Perl 6运行时库决定，以便在多个线程上扩展应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_哦和websockets">8.6. 哦，和WebSockets？</h3>
<div class="paragraph">
<p>事实证明，Perl 6提供的地图非常适合网络套接字。事实上，很好，Cro在API方面的增加相对较少。以下是一个（过度）简单的聊天服务器后端的外观：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$chat</span> = <span class="tok-n">Supplier</span>.<span class="tok-nb">new</span>;
<span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;chat&#39;</span> {
    <span class="tok-c1"># For each request for a web socket...</span>
    <span class="tok-n">web-socket</span> -&gt; <span class="tok-nv">$incoming</span> {
        <span class="tok-c1"># We start this bit of reactive logic...</span>
        <span class="tok-n">supply</span> {
            <span class="tok-c1"># Whenever we get a message on the socket, we emit it into the</span>
            <span class="tok-c1"># $chat Supplier</span>
            <span class="tok-n">whenever</span> <span class="tok-nv">$incoming</span> -&gt; <span class="tok-nv">$message</span> {
                <span class="tok-nv">$chat</span>.<span class="tok-n">emit</span>(<span class="tok-n">await</span> <span class="tok-nv">$message</span>.<span class="tok-n">body-text</span>);
            }
            <span class="tok-c1"># Whatever is emitted on the $chat Supplier (shared between all)</span>
            <span class="tok-c1"># web sockets), we send on this web socket.</span>
            <span class="tok-n">whenever</span> <span class="tok-nv">$chat</span> -&gt; <span class="tok-nv">$text</span> {
                <span class="tok-n">emit</span> <span class="tok-nv">$text</span>;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">请注意，这样做需要使用Cro </dt>
<dd>
<p>HTTP :: Router :: WebSocket;导入提供网络套接字功能的模块。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_综上所述">8.7. 综上所述</h3>
<div class="paragraph">
<p>这只是对Cro所提供的内容的一瞥。没有空间讨论HTTP和Web套接字客户端，用于存根和运行项目的cro命令行工具，提供用于执行相同操作的Web UI的Cro Web工具，或者如果您将CRO_TRACE = 1粘贴到您的环境中，您可以获得大量有关请求和响应处理的多汁调试细节。</p>
</div>
<div class="paragraph">
<p>要了解更多信息，请查看Cro文档，其中包括关于构建单页应用程序的教程。如果你有更多的问题，最近在Freenode上创建了#cro IRC频道</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_wrapping_rats">9. 第十天 – Wrapping Rats</h2>
<div class="sectionbody">
<div class="paragraph">
<p>沿着烟囱向下是一件危险的事情。</p>
</div>
<div class="paragraph">
<p>烟囱可能很窄，很高，有时候建造得不够好。</p>
</div>
<div class="paragraph">
<p>今年，圣诞老人想要做好准备。因此，他正在将烟囱检查与交付礼物结合起来。</p>
</div>
<div class="paragraph">
<p>烟囱检查涉及确保每层砖都处于正确的高度; 即砂浆层的高度是一致的，并且砖的高度也是一致的。</p>
</div>
<div class="paragraph">
<p>例如，对于 2¼” 高的砖和厚度为 ⅜” 的砂浆，测量序列应该如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>                       🎅
                      ─██─
                       ||
 <span class="tok-n">layer</span>                                      <span class="tok-n">total</span>
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
   <span class="tok-n">⅜</span>                                        ‾‾???
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
   <span class="tok-n">⅜</span>                                        ‾‾<span class="tok-mi">5</span><span class="tok-n">⅝</span>
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
   <span class="tok-n">⅜</span>                                        ‾‾<span class="tok-mi">3</span>
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
   <span class="tok-n">⅜</span>   <span class="tok-n">_____________________________________</span>‾‾<span class="tok-n">⅜</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个计划是让精灵们下降到烟囱的底部，手中拿着卷尺，然后回来，确保每个砖块的顶部恰好位于卷尺上的正确位置。</p>
</div>
<div class="paragraph">
<p>一个名叫猫王的特殊精灵已经自己写了一个程序来帮助完成计算这个高度序列的任务。</p>
</div>
<div class="paragraph">
<p>因为懒惰，猫王甚至不想添加上述任何分数，并希望程序完成所有工作。他也不想花费精力去找出每层高度的公式。幸运的是，他正在使用 Perl 6，它将 unicode 分数转换为有理数（类型为 <code>Rat</code>），并且还有一个序列运算符（<code>&#8230;&#8203;</code>），它根据前几项计算出算术序列。</p>
</div>
<div class="paragraph">
<p>所以，猫王在程序中的第一个片段看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@heights</span> = <span class="tok-mi">0</span>, <span class="tok-n">⅜</span>, <span class="tok-mi">3</span>, <span class="tok-mi">5</span><span class="tok-o">+</span><span class="tok-n">⅝</span> ... *;

<span class="tok-nb">say</span> <span class="tok-nv">@heights</span>[^<span class="tok-mi">10</span>].<span class="tok-nb">join</span>(<span class="tok-s">&#39;, &#39;</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了他需要的前10个高度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">0</span>, <span class="tok-mf">0.375</span>, <span class="tok-mi">3</span>, <span class="tok-mf">5.625</span>, <span class="tok-mf">8.25</span>, <span class="tok-mf">10.875</span>, <span class="tok-mf">13.5</span>, <span class="tok-mf">16.125</span>, <span class="tok-mf">18.75</span>, <span class="tok-mf">21.375</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这是正确的，但很难使用。卷尺只有几分之一英寸，而不是小数。猫王真正想要的输出是分数。</p>
</div>
<div class="paragraph">
<p>幸运的是，他知道使用 <code>join</code> 将 <code>Rat`s 转换为字符串，通过调用 `Rat</code> 类的 <code>Str</code> 方法完成将 <code>Rat</code> 转换为 <code>Str</code>。因此，通过修改 <code>Rat.Str</code> 的行为，他认为可以使输出更漂亮。</p>
</div>
<div class="paragraph">
<p>他决定这样做的方式是包装(<code>wrap</code>) <code>Str</code> 方法（又名使用装饰器模式），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">Rat</span>.^<span class="tok-n">find_method</span>(<span class="tok-s">&#39;Str&#39;</span>).<span class="tok-n">wrap:</span>
  <span class="tok-k">sub</span> (<span class="tok-nv">$r</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$whole</span> = <span class="tok-nv">$r</span>.<span class="tok-nb">Int</span> || <span class="tok-s">&quot;&quot;</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$frac</span> = <span class="tok-nv">$r</span> - <span class="tok-nv">$whole</span>;
    <span class="tok-k">return</span> <span class="tok-s">&quot;$whole&quot;</span> <span class="tok-k">unless</span> <span class="tok-nv">$frac</span> &gt; <span class="tok-mi">0</span>;
    <span class="tok-k">return</span> <span class="tok-s">&quot;$whole&quot;</span> ~ <span class="tok-s">&lt;⅛ ¼ ⅜ ½ ⅝ ¾ ⅞&gt;</span>[<span class="tok-nv">$frac</span> * <span class="tok-mi">8</span> - <span class="tok-mi">1</span>];
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，当把 <code>Rat</code> 字符串化时，除非有小数部分，否则返回整个部分。然后将小数部分视为八分之一数，并将其用作数组中的索引以查找正确的 unicode 分数。</p>
</div>
<div class="paragraph">
<p>他将这一点与他的第一个程序结合起来，以获得这样的高度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">0</span>, <span class="tok-n">⅜</span>, <span class="tok-mi">3</span>, <span class="tok-mi">5</span><span class="tok-n">⅝</span>, <span class="tok-mi">8</span><span class="tok-n">¼</span>, <span class="tok-mi">10</span><span class="tok-n">⅞</span>, <span class="tok-mi">13</span><span class="tok-n">½</span>, <span class="tok-mi">16</span><span class="tok-n">⅛</span>, <span class="tok-mi">18</span><span class="tok-n">¾</span>, <span class="tok-mi">21</span><span class="tok-n">⅜</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>“万岁!” 他想。 “正是我需要的。”</p>
</div>
<div class="paragraph">
<p>圣诞老人看了看这个程序，并说：“猫王，这很聪明，但还不够。虽然大多数砖块的尺寸是 ⅛ 的倍数，但砂浆水平可能并非如此。你也可以让你的程序处理这些情况吗？“</p>
</div>
<div class="paragraph">
<p>“当然”，猫王苦笑着说。然后他将这一行添加到他的包装函数中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">return</span> <span class="tok-s">&quot;$whole {$frac.numerator}⁄{$frac.denominator}&quot;</span>
   <span class="tok-k">unless</span> <span class="tok-nv">$frac</span> %% <span class="tok-n">⅛</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用“可被整除”操作符（<code>%%</code>），以确保分数可以平分为八分之一，并且如果不是只显式地打印分子和分母。然后，对于 ⅕” 厚的砂浆，序列为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@heights</span> = <span class="tok-mi">0</span>, <span class="tok-n">⅕</span>,
                 <span class="tok-n">⅕</span> + <span class="tok-mi">2</span><span class="tok-o">+</span><span class="tok-n">¼</span> + <span class="tok-n">⅕</span>,
                 <span class="tok-n">⅕</span> + <span class="tok-mi">2</span><span class="tok-o">+</span><span class="tok-n">¼</span> + <span class="tok-n">⅕</span>
                   + <span class="tok-mi">2</span><span class="tok-o">+</span><span class="tok-n">¼</span> + <span class="tok-n">⅕</span> ... *;
<span class="tok-nb">say</span> <span class="tok-nv">@heights</span>[^<span class="tok-mi">10</span>].<span class="tok-nb">join</span>(<span class="tok-s">&#39;, &#39;</span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">0</span>,  <span class="tok-mi">1</span>⁄<span class="tok-mi">5</span>, <span class="tok-mi">2</span> <span class="tok-mi">13</span>⁄<span class="tok-mi">20</span>, <span class="tok-mi">5</span> <span class="tok-mi">1</span>⁄<span class="tok-mi">10</span>, <span class="tok-mi">7</span> <span class="tok-mi">11</span>⁄<span class="tok-mi">20</span>, <span class="tok-mi">10</span>, <span class="tok-mi">12</span> <span class="tok-mi">9</span>⁄<span class="tok-mi">20</span>, <span class="tok-mi">14</span> <span class="tok-mi">9</span>⁄<span class="tok-mi">10</span>, <span class="tok-mi">17</span> <span class="tok-mi">7</span>⁄<span class="tok-mi">20</span>, <span class="tok-mi">19</span> <span class="tok-mi">4</span>⁄<span class="tok-mi">5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>“实际上”，圣诞老人说，“现在在我看来，也许这没有用 - 卷尺只有十六分之一英寸，所以最好四舍五入到十六分之一英寸。”</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2017/12/tape-measure.jpg?w=1570">img</a></p>
</div>
<div class="paragraph">
<p>猫王加了一个 <code>round</code> 调用来结束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">Rat</span>.^<span class="tok-n">find_method</span>(<span class="tok-s">&#39;Str&#39;</span>).<span class="tok-n">wrap:</span>
  <span class="tok-k">sub</span> (<span class="tok-nv">$r</span>) {
        <span class="tok-k">my</span> <span class="tok-nv">$whole</span> = <span class="tok-nv">$r</span>.<span class="tok-nb">Int</span> || <span class="tok-s">&#39;&#39;</span>;
        <span class="tok-k">my</span> <span class="tok-nv">$frac</span> = <span class="tok-nv">$r</span> - <span class="tok-nv">$whole</span>;
        <span class="tok-k">return</span> <span class="tok-s">&quot;$whole&quot;</span> <span class="tok-k">unless</span> <span class="tok-nv">$frac</span> &gt; <span class="tok-mi">0</span>;
        <span class="tok-k">my</span> <span class="tok-nv">$rounded</span> = (<span class="tok-nv">$frac</span> * <span class="tok-mi">16</span>).<span class="tok-nb">round</span><span class="tok-o">/</span><span class="tok-mi">16</span>;
        <span class="tok-k">return</span> <span class="tok-s">&quot;$whole&quot;</span> ~ <span class="tok-s">&lt;⅛ ¼ ⅜ ½ ⅝ ¾ ⅞&gt;</span>[<span class="tok-nv">$frac</span> * <span class="tok-mi">8</span> - <span class="tok-mi">1</span>] <span class="tok-k">if</span> <span class="tok-nv">$rounded</span> %% <span class="tok-n">⅛</span>;
        <span class="tok-k">return</span> <span class="tok-s">&quot;$whole {$rounded.numerator}⁄{$rounded.denominator}&quot;</span>;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了他：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">0</span>,  <span class="tok-mi">3</span>⁄<span class="tok-mi">16</span>, <span class="tok-mi">2</span><span class="tok-n">⅝</span>, <span class="tok-mi">5</span><span class="tok-n">⅛</span>, <span class="tok-mi">7</span> <span class="tok-mi">9</span>⁄<span class="tok-mi">16</span>, <span class="tok-mi">10</span>, <span class="tok-mi">12</span> <span class="tok-mi">7</span>⁄<span class="tok-mi">16</span>, <span class="tok-mi">14</span><span class="tok-n">⅞</span>, <span class="tok-mi">17</span><span class="tok-n">¼</span>, <span class="tok-mi">19</span> <span class="tok-mi">13</span>⁄<span class="tok-mi">16</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>他向 Elvira 精灵展示了他的程序，他说：“真是巧合，我写了一个几乎完全一样的程序！除此之外，我也想知道砖层的底部在哪里。我无法使用序列运算符来完成此操作，因为它不是算术级数，但是我可以使用 lazy gather 和匿名有状态变量！就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> \<span class="tok-n">brick</span> = <span class="tok-mi">2</span> + <span class="tok-n">¼</span>;
<span class="tok-k">my</span> \<span class="tok-n">mortar</span> = <span class="tok-n">⅜</span>;
<span class="tok-k">my</span> <span class="tok-nv">@heights</span> = <span class="tok-nb">lazy</span> <span class="tok-k">gather</span> {
    <span class="tok-k">take</span> <span class="tok-mi">0</span>;
    <span class="tok-k">loop</span> { <span class="tok-k">take</span> $ += <span class="tok-nv">$_</span> <span class="tok-k">for</span> <span class="tok-n">mortar</span>, <span class="tok-n">brick</span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elvira 的程序产生了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">0</span>, <span class="tok-n">⅜</span>, <span class="tok-mi">2</span><span class="tok-n">⅝</span>, <span class="tok-mi">3</span>, <span class="tok-mi">5</span><span class="tok-n">¼</span>, <span class="tok-mi">5</span><span class="tok-n">⅝</span>, <span class="tok-mi">7</span><span class="tok-n">⅞</span>, <span class="tok-mi">8</span><span class="tok-n">¼</span>, <span class="tok-mi">10</span><span class="tok-n">½</span>, <span class="tok-mi">10</span><span class="tok-n">⅞</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>即砖层的顶部和底部：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>                     \ 🎅 /
                       ██
                       ||
 <span class="tok-n">layer</span>                                      <span class="tok-n">total</span>
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
   <span class="tok-n">⅜</span>                                        ‾‾<span class="tok-mi">8</span><span class="tok-n">¼</span>
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░‾‾<span class="tok-mi">7</span><span class="tok-n">⅞</span>
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
   <span class="tok-n">⅜</span>                                        ‾‾<span class="tok-mi">5</span><span class="tok-n">⅝</span>
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░‾‾<span class="tok-mi">5</span><span class="tok-n">¼</span>
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
   <span class="tok-n">⅜</span>                                        ‾‾<span class="tok-mi">3</span>
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░‾‾<span class="tok-mi">2</span><span class="tok-n">⅝</span>
  <span class="tok-mi">2</span><span class="tok-n">¼</span>   ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
   <span class="tok-n">⅜</span>   <span class="tok-n">_____________________________________</span>‾‾<span class="tok-n">⅜</span>
                                            ‾‾<span class="tok-mi">0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有了他们的程序在手，精灵检查了烟囱，圣诞老人在另一个节日期间没有受伤。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_perl_6_中所有的星号">10. 第十一天-Perl 6 中所有的星号</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在今年的 Perl 6 Advent Calendar 中, 雪花被今天的博客文章承包了。 我们将检阅使用了 <code><strong></code> 字符的结构。 在 Perl 6 中，根据上下文的不同，您可以叫它星星（或者，如果你愿意的话，可以叫它星号）或者 *whatever</strong>。</p>
</div>
<div class="paragraph">
<p>Perl 6 不是一个隐秘的编程语言， 在许多方面它的语法比 Perl 5 更加一致。另一方面，有些地方需要花时间来开启对语法的信心。</p>
</div>
<div class="paragraph">
<p>让我们看看 <code><strong></code> 的不同用法，从最简单的开始，旨在了解最烧脑的例如 <code></strong> ** *</code>。</p>
</div>
<div class="paragraph">
<p>前两种用法很简单，不需要太多的讨论：</p>
</div>
<div class="sect2">
<h3 id="_1_乘法">10.1. 1. 乘法</h3>
<div class="paragraph">
<p>单个星号用于乘法。严格来讲, 这是一个中缀操作符 <code>infix:&lt;*&gt;</code>, 它的返回值为 <code>Numeric</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-mi">20</span> <span class="tok-o">*</span> <span class="tok-mi">18</span><span class="tok-p">;</span> <span class="tok-c1"># 360</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_幂">10.2. 2. 幂</h3>
<div class="paragraph">
<p>两个星号 <code><strong></code> 是幂操作符。再次, 这是一个中缀操作符 <code>infix:&lt;</strong>&gt;</code>, 它返回 <code>Numeric</code> 结果, 计算两个给定值点幂。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-n">pi</span> <span class="tok-o">**</span> <span class="tok-n">e</span><span class="tok-p">;</span> <span class="tok-c1"># 22.4591577183611</span></code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>正则表达式中同样也使用了两个标记（<code><strong></code> 或 <code></strong>*</code>），它们表示不同的东西。 Perl 6 的一个特点是它可以很容易地在不同的语言之间切换。 正则表达式和 grammar 都是这样的内部语言的例子，其中同样的符号在 Perl 6 中可能意味着不同的含义。</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_零或多次重复">10.3. 3. 零或多次重复</h3>
<div class="paragraph">
<p><code>*</code> 号量词这个语法条目和 Perl 5 中点行为类似: 允许原子的零次或多次重复。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">$weather</span> <span class="tok-o">=</span> <span class="tok-s">&#39;*****&#39;</span><span class="tok-p">;</span>
<span class="tok-k">my</span> <span class="tok-nv">$snow</span> <span class="tok-o">=</span> <span class="tok-nv">$weather</span> <span class="tok-o">~~</span> <span class="tok-sr">/ (&#39;*&#39;*) /</span><span class="tok-p">;</span>
<span class="tok-n">say</span> <span class="tok-s">&#39;Snow level is &#39;</span> <span class="tok-o">~</span> <span class="tok-nv">$snow</span><span class="tok-o">.</span><span class="tok-n">chars</span><span class="tok-p">;</span> <span class="tok-c1"># Snow level is 5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 我们还在这儿看到了同一个字符的另一种用法, <code>*</code> 字面量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_min_到_max_次重复">10.4. 4. Min 到 Max 次重复</h3>
<div class="paragraph">
<p>两个 <code>**</code> 号是另一个量词的一部分，它指定了最小和最大重复次数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">$operator</span> <span class="tok-o">=</span> <span class="tok-s">&#39;..&#39;</span><span class="tok-p">;</span>
<span class="tok-n">say</span> <span class="tok-s">&quot;&#39;$operator&#39; is a valid Perl 6 operator&quot;</span>
    <span class="tok-k">if</span> <span class="tok-nv">$operator</span> <span class="tok-o">~~</span> <span class="tok-sr">/^ &#39;.&#39; ** 1..3 $/</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，预计这个点会被重复一次，两次或三次; 不多也不少。</p>
</div>
<div class="paragraph">
<p>让我们超前一点儿，以 <code>Whatever</code> 符号的角色（剧场中的角色，而不是 Perl 6 的面向对象编程）使用星号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">$phrase</span> <span class="tok-o">=</span> <span class="tok-s">&#39;I love you......&#39;</span><span class="tok-p">;</span>
<span class="tok-n">say</span> <span class="tok-s">&#39;You are so uncertain...&#39;</span>
    <span class="tok-k">if</span> <span class="tok-nv">$phrase</span> <span class="tok-o">~~</span> <span class="tok-sr">/ &#39;.&#39; ** 4..* /</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>范围的第二个端点是打开的，这个正则表达式接受所有其中包含四个点以上的短语。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_吞噬参数">10.5. 5. 吞噬参数</h3>
<div class="paragraph">
<p>在子例程签名的数组参数之前的星号意味着吞噬参数 - 将单独的标量参数吞噬进单个数组中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">list</span><span class="tok-o">-</span><span class="tok-n">gifts</span><span class="tok-p">(</span><span class="tok-s">&#39;chocolade&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;ipad&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;camelia&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;perl6&#39;</span><span class="tok-p">);</span>

<span class="tok-k">sub</span> <span class="tok-nf">list</span><span class="tok-p">-gifts(*@items) {</span>
    <span class="tok-n">say</span> <span class="tok-s">&#39;Look at my gifts this year:&#39;</span><span class="tok-p">;</span>
    <span class="tok-o">.</span><span class="tok-n">say</span> <span class="tok-k">for</span> <span class="tok-nv">@items</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>哈希也允许吞噬参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-nb">dump</span><span class="tok-p">(</span><span class="tok-n">alpha</span> <span class="tok-o">=&gt;</span> <span class="tok-s">&#39;a&#39;</span><span class="tok-p">,</span> <span class="tok-n">beta</span> <span class="tok-o">=&gt;</span> <span class="tok-s">&#39;b&#39;</span><span class="tok-p">);</span> <span class="tok-c1"># Prints:</span>
                                 <span class="tok-c1"># alpha = a</span>
                                 <span class="tok-c1"># beta = b</span>

<span class="tok-k">sub</span> <span class="tok-nf">dump</span><span class="tok-p">(*%data) {</span>
    <span class="tok-k">for</span> <span class="tok-nv">%data</span><span class="tok-o">.</span><span class="tok-n">kv</span> <span class="tok-p">{</span><span class="tok-n">say</span> <span class="tok-s">&quot;$^a = $^b&quot;</span><span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，与 Perl 5 不同的是，如果您省略函数签名中的星号，代码将无法编译，因为 Perl 6 就是说一不二：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Too</span> <span class="tok-n">few</span> <span class="tok-n">positionals</span> <span class="tok-n">passed</span>; <span class="tok-n">expected</span> <span class="tok-mi">1</span> <span class="tok-n">argument</span> <span class="tok-k">but</span> <span class="tok-n">got</span> <span class="tok-mi">0</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_吨吨吨吨吨吨吨">10.6. 6. 吨吨吨吨吨吨吨</h3>
<div class="paragraph">
<p><code>**@</code> 也能工作，但是当你传递数组或列表的时候请注意其中的区别。</p>
</div>
<div class="paragraph">
<p>带一颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">@a</span> <span class="tok-o">=</span> <span class="tok-o">&lt;</span> <span class="tok-n">chocolade</span> <span class="tok-n">ipad</span> <span class="tok-o">&gt;</span><span class="tok-p">;</span>
<span class="tok-k">my</span> <span class="tok-nv">@b</span> <span class="tok-o">=</span> <span class="tok-o">&lt;</span> <span class="tok-n">camelia</span> <span class="tok-n">perl6</span> <span class="tok-o">&gt;</span><span class="tok-p">;</span>

<span class="tok-n">all</span><span class="tok-o">-</span><span class="tok-n">together</span><span class="tok-p">(</span><span class="tok-nv">@a</span><span class="tok-p">,</span> <span class="tok-nv">@b</span><span class="tok-p">);</span>
<span class="tok-n">all</span><span class="tok-o">-</span><span class="tok-n">together</span><span class="tok-p">([</span><span class="tok-s">&#39;chocolade&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;ipad&#39;</span><span class="tok-p">],</span> <span class="tok-p">[</span><span class="tok-s">&#39;camelia&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;perl6&#39;</span><span class="tok-p">]);</span>
<span class="tok-n">all</span><span class="tok-o">-</span><span class="tok-n">together</span><span class="tok-p">(</span><span class="tok-o">&lt;</span> <span class="tok-n">chocolade</span> <span class="tok-n">ipad</span> <span class="tok-o">&gt;</span><span class="tok-p">,</span> <span class="tok-o">&lt;</span> <span class="tok-n">camelia</span> <span class="tok-n">perl6</span> <span class="tok-o">&gt;</span><span class="tok-p">);</span>

<span class="tok-k">sub</span> <span class="tok-nf">all</span><span class="tok-p">-together(*@items) {</span>
    <span class="tok-o">.</span><span class="tok-n">say</span> <span class="tok-k">for</span> <span class="tok-nv">@items</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>目前，无论参数列表传递的方式如何，每个礼物都被单独打印了出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">chocolade</span>
<span class="tok-n">ipad</span>
<span class="tok-n">camelia</span>
<span class="tok-n">perl6</span>
<span class="tok-n">chocolade</span>
<span class="tok-n">ipad</span>
<span class="tok-n">camelia</span>
<span class="tok-n">perl6</span>
<span class="tok-n">chocolade</span>
<span class="tok-n">ipad</span>
<span class="tok-n">camelia</span>
<span class="tok-n">perl6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>带俩颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">keep</span><span class="tok-o">-</span><span class="tok-n">groupped</span><span class="tok-p">(</span><span class="tok-nv">@a</span><span class="tok-p">,</span> <span class="tok-nv">@b</span><span class="tok-p">);</span>
<span class="tok-n">keep</span><span class="tok-o">-</span><span class="tok-n">groupped</span><span class="tok-p">([</span><span class="tok-s">&#39;chocolade&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;ipad&#39;</span><span class="tok-p">],</span> <span class="tok-p">[</span><span class="tok-s">&#39;camelia&#39;</span><span class="tok-p">,</span> <span class="tok-s">&#39;perl6&#39;</span><span class="tok-p">]);</span>
<span class="tok-n">keep</span><span class="tok-o">-</span><span class="tok-n">groupped</span><span class="tok-p">(</span><span class="tok-o">&lt;</span> <span class="tok-n">chocolade</span> <span class="tok-n">ipad</span> <span class="tok-o">&gt;</span><span class="tok-p">,</span> <span class="tok-o">&lt;</span> <span class="tok-n">camelia</span> <span class="tok-n">perl6</span> <span class="tok-o">&gt;</span><span class="tok-p">);</span>

<span class="tok-k">sub</span> <span class="tok-nf">keep</span><span class="tok-p">-groupped(**@items) {</span>
    <span class="tok-o">.</span><span class="tok-n">say</span> <span class="tok-k">for</span> <span class="tok-nv">@items</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，<code>@items</code> 数组只有两个元素，反映了参数的结构类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>[<span class="tok-n">chocolade</span> <span class="tok-n">ipad</span>]
[<span class="tok-n">camelia</span> <span class="tok-n">perl6</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>(<span class="tok-n">chocolade</span> <span class="tok-n">ipad</span>)
(<span class="tok-n">camelia</span> <span class="tok-n">perl6</span>)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_动态作用域">10.7. 7. 动态作用域</h3>
<div class="paragraph">
<p><code>*</code> twigil，引入了动态作用域。 动态变量和全局变量很容易搞混淆，所以最好测试下面的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">sub</span> <span class="tok-nf">happy</span><span class="tok-p">-new-year() {</span>
    <span class="tok-s">&quot;Happy new $*year year!&quot;</span>
<span class="tok-p">}</span>

<span class="tok-k">my</span> <span class="tok-nv">$</span><span class="tok-err">*</span><span class="tok-nv">year</span> <span class="tok-o">=</span> <span class="tok-mi">2018</span><span class="tok-p">;</span>
<span class="tok-n">say</span> <span class="tok-n">happy</span><span class="tok-o">-</span><span class="tok-k">new</span><span class="tok-o">-</span><span class="tok-n">year</span><span class="tok-p">();</span> <span class="tok-c1"># 输出 Happy new 2018 year!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你省略了星号, 那么代码就运行不了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">Variable</span> <span class="tok-s">&#39;$year&#39;</span> <span class="tok-n">is</span> <span class="tok-ow">not</span> <span class="tok-n">declared</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>更正它的唯一方法是将 <code>$year</code> 的定义移到函数定义的上面。 使用动态变量 <code>$*year</code>，函数被调用的地方定义了结果。 <code>$*year</code> 变量在子例程的外部作用域中是不可见的，但是在动态作用域内是可见的。</p>
</div>
<div class="paragraph">
<p>对于动态变量，将新值赋给现有变量还是创建新变量并不重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">sub</span> <span class="tok-nf">happy</span><span class="tok-p">-new-year() {</span>
    <span class="tok-s">&quot;Happy new $*year year!&quot;</span>
<span class="tok-p">}</span>

<span class="tok-k">my</span> <span class="tok-nv">$</span><span class="tok-err">*</span><span class="tok-nv">year</span> <span class="tok-o">=</span> <span class="tok-mi">2018</span><span class="tok-p">;</span>
<span class="tok-n">say</span> <span class="tok-n">happy</span><span class="tok-o">-</span><span class="tok-k">new</span><span class="tok-o">-</span><span class="tok-n">year</span><span class="tok-p">();</span>

<span class="tok-p">{</span>
    <span class="tok-nv">$</span><span class="tok-err">*</span><span class="tok-nv">year</span> <span class="tok-o">=</span> <span class="tok-mi">2019</span><span class="tok-p">;</span>        <span class="tok-c1"># New value</span>
    <span class="tok-n">say</span> <span class="tok-n">happy</span><span class="tok-o">-</span><span class="tok-k">new</span><span class="tok-o">-</span><span class="tok-n">year</span><span class="tok-p">();</span> <span class="tok-c1"># 2019</span>
<span class="tok-p">}</span>

<span class="tok-p">{</span>
    <span class="tok-k">my</span> <span class="tok-nv">$</span><span class="tok-err">*</span><span class="tok-nv">year</span> <span class="tok-o">=</span> <span class="tok-mi">2020</span><span class="tok-p">;</span>     <span class="tok-c1"># New variable</span>
    <span class="tok-n">say</span> <span class="tok-n">happy</span><span class="tok-o">-</span><span class="tok-k">new</span><span class="tok-o">-</span><span class="tok-n">year</span><span class="tok-p">();</span> <span class="tok-c1"># 2020</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_编译变量">10.8. 8. 编译变量</h3>
<div class="paragraph">
<p>Perl 6 提供了许多伪动态常量, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-nv">$</span><span class="tok-err">*</span><span class="tok-nv">PERL</span><span class="tok-p">;</span>      <span class="tok-c1"># Perl 6 (6.c)</span>
<span class="tok-n">say</span> <span class="tok-nv">@</span><span class="tok-err">*</span><span class="tok-nv">ARGS</span><span class="tok-p">;</span>      <span class="tok-c1"># Prints command-line arguments</span>
<span class="tok-n">say</span> <span class="tok-nv">%</span><span class="tok-err">*</span><span class="tok-nv">ENV</span><span class="tok-sr">&lt;HOME&gt;</span><span class="tok-p">;</span> <span class="tok-c1"># Prints home directory</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_all_methods">10.9. 9. All methods</h3>
<div class="paragraph">
<p><code>.*</code> postfix 伪操作符调用给定名称的所有方法，名称可以在给定的对象中找到，并返回一个结果列表。 在微不足道的情况下，你会得到一个学术上荒诞不羁的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-mi">6</span><span class="tok-o">.*</span><span class="tok-n">perl</span><span class="tok-o">.*</span><span class="tok-n">say</span><span class="tok-p">;</span> <span class="tok-c1"># (6 Int.new)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>带星号的代码与不带星号代码有些不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">pi</span><span class="tok-o">.</span><span class="tok-n">perl</span><span class="tok-o">.</span><span class="tok-n">say</span><span class="tok-p">;</span> <span class="tok-c1"># 3.14159265358979e0 (notice the scientific</span>
             <span class="tok-c1"># format, unlike pi.say)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.*</code> postfix 的真正威力来自于继承。 它有时有助于揭示真相：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">class</span> <span class="tok-n">Present</span> <span class="tok-p">{</span>
    <span class="tok-n">method</span> <span class="tok-n">giver</span><span class="tok-p">()</span> <span class="tok-p">{</span>
        <span class="tok-s">&#39;parents&#39;</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-n">class</span> <span class="tok-n">ChristmasPresent</span> <span class="tok-n">is</span> <span class="tok-n">Present</span> <span class="tok-p">{</span>
    <span class="tok-n">method</span> <span class="tok-n">giver</span><span class="tok-p">()</span> <span class="tok-p">{</span>
        <span class="tok-s">&#39;Santa Claus&#39;</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-k">my</span> <span class="tok-n">ChristmasPresent</span> <span class="tok-nv">$present</span><span class="tok-p">;</span>

<span class="tok-nv">$present</span><span class="tok-o">.</span><span class="tok-n">giver</span><span class="tok-o">.</span><span class="tok-n">say</span><span class="tok-p">;</span>             <span class="tok-c1"># Santa Claus</span>
<span class="tok-nv">$present</span><span class="tok-o">.*</span><span class="tok-n">giver</span><span class="tok-o">.</span><span class="tok-nb">join</span><span class="tok-p">(</span><span class="tok-s">&#39;, &#39;</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-n">say</span><span class="tok-p">;</span> <span class="tok-c1"># Santa Claus, parents</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个星号就差别很大!</p>
</div>
<hr>
<div class="paragraph">
<p>现在，到了 Perl 6 最神秘的部分。接下来的两个概念，<code>Whatever</code> 和 <code>WhateverCode</code> 类，很容易混淆在一起。 让我们试着做对吧。</p>
</div>
</div>
<div class="sect2">
<h3 id="_10_whatever">10.10. 10. Whatever</h3>
<div class="paragraph">
<p>单个星号 <code>*</code> 能表示任何东西(<code>Whatever</code>)。 <code>Whatever</code> 在 Perl 6 中是一个预定义好的类, 它在某些有用的场景下引入了一些规定好的行为。</p>
</div>
<div class="paragraph">
<p>例如，在范围和序列中，最后的 <code>*</code> 表示无穷大。 我们今天已经看到了一个例子。 这是另一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-o">.</span><span class="tok-n">say</span> <span class="tok-k">for</span> <span class="tok-mi">1</span> <span class="tok-o">..</span> <span class="tok-o">*</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个单行程序具有非常高的能量转换效率，因为它产生了一个递增整数的无限列表。 如果你要继续，请按 <code>Ctrl + C</code>。</p>
</div>
<div class="paragraph">
<p>范围 <code>1 .. *</code> 与 <code>1 .. Inf</code> 相同。 您可以清楚地看到，如果您跳转到 Rakudo Perl 6 源文件并在 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Range.pm">src/core/Range.pm</a> 文件的 <code>Range</code> 类的实现中找到如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-k">new</span><span class="tok-p">(</span><span class="tok-n">Whatever</span> <span class="tok-o">\</span><span class="tok-n">min</span><span class="tok-p">,</span><span class="tok-n">Whatever</span> <span class="tok-o">\</span><span class="tok-n">max</span><span class="tok-p">,:</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">min</span><span class="tok-p">,:</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">max</span><span class="tok-p">){</span>
    <span class="tok-nn">nqp::</span><span class="tok-n">create</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-p">)</span><span class="tok-o">!</span><span class="tok-n">SET</span><span class="tok-o">-</span><span class="tok-n">SELF</span><span class="tok-p">(</span><span class="tok-o">-</span><span class="tok-n">Inf</span><span class="tok-p">,</span><span class="tok-n">Inf</span><span class="tok-p">,</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">min</span><span class="tok-p">,</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">max</span><span class="tok-p">,</span><span class="tok-mi">1</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
<span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-k">new</span><span class="tok-p">(</span><span class="tok-n">Whatever</span> <span class="tok-o">\</span><span class="tok-n">min</span><span class="tok-p">,</span> <span class="tok-o">\</span><span class="tok-n">max</span><span class="tok-p">,</span> <span class="tok-p">:</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">min</span><span class="tok-p">,</span> <span class="tok-p">:</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">max</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nn">nqp::</span><span class="tok-n">create</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-p">)</span><span class="tok-o">!</span><span class="tok-n">SET</span><span class="tok-o">-</span><span class="tok-n">SELF</span><span class="tok-p">(</span><span class="tok-o">-</span><span class="tok-n">Inf</span><span class="tok-p">,</span><span class="tok-n">max</span><span class="tok-p">,</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">min</span><span class="tok-p">,</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">max</span><span class="tok-p">,</span><span class="tok-mi">1</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
<span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-k">new</span><span class="tok-p">(</span><span class="tok-o">\</span><span class="tok-n">min</span><span class="tok-p">,</span> <span class="tok-n">Whatever</span> <span class="tok-o">\</span><span class="tok-n">max</span><span class="tok-p">,</span> <span class="tok-p">:</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">min</span><span class="tok-p">,</span> <span class="tok-p">:</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">max</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nn">nqp::</span><span class="tok-n">create</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-p">)</span><span class="tok-o">!</span><span class="tok-n">SET</span><span class="tok-o">-</span><span class="tok-n">SELF</span><span class="tok-p">(</span><span class="tok-n">min</span><span class="tok-p">,</span><span class="tok-n">Inf</span><span class="tok-p">,</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">min</span><span class="tok-p">,</span><span class="tok-nv">$excludes</span><span class="tok-o">-</span><span class="tok-n">max</span><span class="tok-p">,</span><span class="tok-mi">1</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个 multi 构造函数描述了三种情况：<code>* .. <strong></code>，<code></strong> .. $n</code> 和 <code>$n .. *</code>，它们被立即转换为 <code>-Inf .. Inf</code>，<code>-Inf .. $n</code> 和 <code>$n .. Inf</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>作为一个圣诞故事，这里有一个小小的插曲，表明 <code>*</code> 不仅仅是一个 <code>Inf</code>。 有两个到 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Whatever.pm">src/core/Whatever.pm</a> 的提交：</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>首先，2015年9月16日，"<a href="https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07" class="bare">https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07</a>:"</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { '*' }
+     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>几周之后, 在2015年10月23日，"<a href="https://github.com/rakudo/rakudo/commit/4e35e807c5f0c8ac134e1ed87b4b9343966d0d8d#diff-ac169f9e5137f98d305f3cae4c0c4d07">* no longer defaults to Inf</a>"，这是为了保护其他 dwimmy 情况下的扩展性:</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { '*' }
-     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="paragraph">
<p>回到我们更实际的问题，让我们创建自己的使用 whatever 符号 <code>*</code> 的类，。 下面是一个简单的例子，它带有一个接收 <code>Int</code> 值或者 <code>Whatever</code> 的 multi-方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">class</span> <span class="tok-n">N</span> <span class="tok-p">{</span>
    <span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">Int</span> <span class="tok-nv">$n</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">say</span> <span class="tok-nv">$n</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>

    <span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">Whatever</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">say</span> <span class="tok-mi">2000</span> <span class="tok-o">+</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，该方法只是打印该值。 第二种方法是打印一个在 2000 到 2100 之间的随机数。 因为第二种方法的唯一参数是 <code>Whatever</code>，所以签名中不需要变量。</p>
</div>
<div class="paragraph">
<p>下面是你如何使用这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">$n</span> <span class="tok-o">=</span> <span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-k">new</span><span class="tok-p">;</span>
<span class="tok-nv">$n</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-mi">2018</span><span class="tok-p">);</span>
<span class="tok-nv">$n</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个调用回显它的参数，而第二个调用打印某些随机的东西。</p>
</div>
<div class="paragraph">
<p><code>Whatever</code> 符号可以作为一个裸的 <code>Whatever</code>。 假如，你创建一个 <code>echo</code> 函数，并将 <code>*</code> 传递给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">sub</span> <span class="tok-nf">echo</span><span class="tok-p">($x) {</span>
    <span class="tok-n">say</span> <span class="tok-nv">$x</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-n">echo</span><span class="tok-p">(</span><span class="tok-mi">2018</span><span class="tok-p">);</span> <span class="tok-c1"># 2018</span>
<span class="tok-n">echo</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-p">);</span>    <span class="tok-c1"># *</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，没有魔术发生，该程序打印一个星号。</p>
</div>
<div class="paragraph">
<p>现在我们正处在一个四两拨千斤的节骨眼上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_whatevercode">10.11. 11. WhateverCode</h3>
<div class="paragraph">
<p>最后, 我们来谈谈 <code>WhateverCode</code>。</p>
</div>
<div class="paragraph">
<p>取一个数组然后打印出它的最后一个元素。如果你使用 Perl 5 的风格来做, 你会键入 <code>@a[-1]</code> 那样的东西。在 Perl 6 中, 那会产生错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Unsupported</span> <span class="tok-k">use</span> <span class="tok-k">of</span> <span class="tok-n">a</span> <span class="tok-n">negative</span> -<span class="tok-mi">1</span> <span class="tok-n">subscript</span>
<span class="tok-nb">to</span> <span class="tok-nb">index</span> <span class="tok-nb">from</span> <span class="tok-n">the</span> <span class="tok-nb">end</span>; <span class="tok-n">in</span> <span class="tok-n">Perl</span> <span class="tok-mi">6</span> <span class="tok-n">please</span>
<span class="tok-k">use</span> <span class="tok-n">a</span> <span class="tok-n">function</span> <span class="tok-n">such</span> <span class="tok-k">as</span> *-<span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编译器建议使用一个函数, 例如 <code>*-1</code>。它是函数吗？是的, 更准确的说, 它是一个 <code>WhateverCode</code> 块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-p">(</span><span class="tok-o">*-</span><span class="tok-mi">1</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-n">WHAT</span><span class="tok-p">;</span> <span class="tok-c1"># (WhateverCode)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 打印数组的后半部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">@a</span> <span class="tok-o">=</span> <span class="tok-o">&lt;</span> <span class="tok-n">one</span> <span class="tok-n">two</span> <span class="tok-n">three</span> <span class="tok-n">four</span> <span class="tok-n">five</span> <span class="tok-n">six</span> <span class="tok-o">&gt;</span><span class="tok-p">;</span>
<span class="tok-n">say</span> <span class="tok-nv">@a</span><span class="tok-p">[</span><span class="tok-mi">3</span><span class="tok-o">..*</span><span class="tok-p">];</span> <span class="tok-c1"># (four five six)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>数组的索引的范围是 <code>3 .. *</code>。 <code>Whatever</code> 作为 range 的右端意味着从数组中取出所有剩余的元素。 <code>3 .. *</code> 的类型是 <code>Range</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-p">(</span><span class="tok-mi">3</span><span class="tok-o">..*</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-n">WHAT</span><span class="tok-p">;</span> <span class="tok-c1"># (Range)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，减少一个元素。 我们已经看到，要指定最后一个元素，必须要使用诸如 <code>*-1</code> 的函数。 在 range 的右端可以做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-nv">@a</span><span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-o">..</span> <span class="tok-o">*-</span><span class="tok-mi">2</span><span class="tok-p">];</span> <span class="tok-c1"># (four five)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个时候，发生了所谓的 <code>Whatever-柯里化</code>，<code>Range</code> 变成了 <code>WhateverCode</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-p">(</span><span class="tok-mi">3</span> <span class="tok-o">..</span> <span class="tok-o">*-</span><span class="tok-mi">2</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-n">WHAT</span><span class="tok-p">;</span> <span class="tok-c1"># (WhateverCode)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WhateverCode</code> 是一个内置的 Perl 6 类名称; 它可以很容易地用于方法分派。 让我们更新上一节中的代码，并添加一个方法变体，它需要一个 <code>WhateverCode</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">class</span> <span class="tok-n">N</span> <span class="tok-p">{</span>
    <span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">Int</span> <span class="tok-nv">$n</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">say</span> <span class="tok-nv">$n</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>

    <span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">Whatever</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">say</span> <span class="tok-mi">2000</span> <span class="tok-o">+</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>

    <span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">WhateverCode</span> <span class="tok-nv">$code</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">say</span> <span class="tok-nv">$code</span><span class="tok-p">(</span><span class="tok-mi">2000</span> <span class="tok-o">+</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，参数列表中的星号要么落入 <code>display(Whatever)</code>, 要么落入 <code>display(WhateverCode)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-mi">2018</span><span class="tok-p">);</span>     <span class="tok-c1"># display(Int $n)</span>

<span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-p">);</span>        <span class="tok-c1"># display(Whatever)</span>

<span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-o">*</span> <span class="tok-o">/</span> <span class="tok-mi">2</span><span class="tok-p">);</span>    <span class="tok-c1"># display(WhateverCode $code)</span>
<span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-o">*</span> <span class="tok-o">-</span> <span class="tok-mi">1000</span><span class="tok-p">);</span> <span class="tok-c1"># display(WhateverCode $code)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再来看看 <code>display</code> 方法中的签名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">WhateverCode</span> <span class="tok-nv">$code</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$code</code> 参数被用作方法内的函数引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">say</span> <span class="tok-nv">$code</span><span class="tok-p">(</span><span class="tok-mi">2000</span> <span class="tok-o">+</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数需要一个参数，但它会去哪里？ 或者换句话说，函数体是什么，在哪里？ 我们将该方法调用为 <code>N.display(* / 2)</code> 或 <code>N.display(* - 1000)</code>。 答案是 <code>* / 2</code> 和 <code>* - 1000</code> 都是函数！ 还记得编译器关于使用诸如 <code>*-1</code> 之类的函数的提示吗？</p>
</div>
<div class="paragraph">
<p>这里的星号成为第一个函数参数，因此 <code>* / 2</code> 相当于 <code>{$^a / 2}</code>，而 <code>*-1000</code> 相当于 <code>{$^a - 1000}</code>。</p>
</div>
<div class="paragraph">
<p>这是否意味着可以在 <code>$^a</code> 的旁边使用 <code>$^b</code>? 当然！ 使 <code>WhateverCode</code> 块接受两个参数。 你如何指出其中的第二个？ 毫不惊喜，再用一个星号！ 让我们将 <code>display</code> 方法的第四个变体添加到我们的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">multi</span> <span class="tok-n">method</span> <span class="tok-n">display</span><span class="tok-p">(</span><span class="tok-n">WhateverCode</span> <span class="tok-nv">$code</span>
                     <span class="tok-n">where</span> <span class="tok-p">{</span><span class="tok-nv">$code</span><span class="tok-o">.</span><span class="tok-n">arity</span> <span class="tok-o">==</span> <span class="tok-mi">2</span><span class="tok-p">})</span> <span class="tok-p">{</span>
    <span class="tok-n">say</span> <span class="tok-nv">$code</span><span class="tok-p">(</span><span class="tok-mi">2000</span><span class="tok-p">,</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，使用 <code>where</code> 块来缩小调度范围，只选择那些有两个参数的 <code>WhateverCode</code> 块。 完成此操作后，方法调用中将允许含有两个雪花：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span> <span class="tok-o">*</span> <span class="tok-o">+</span> <span class="tok-o">*</span> <span class="tok-p">);</span>
<span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span> <span class="tok-o">*</span> <span class="tok-o">-</span> <span class="tok-o">*</span> <span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些调用定义了用于计算结果的函数 <code>$code</code>。 所以，<code>N.display(* + *)</code> 背后的实际操作如下：<code>2000 + 100.rand.Int</code>。</p>
</div>
<div class="paragraph">
<p>需要更多的雪花吗？ 多添加点星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-p">);</span>
<span class="tok-n">N</span><span class="tok-o">.</span><span class="tok-n">display</span><span class="tok-p">(</span> <span class="tok-o">*</span> <span class="tok-o">**</span> <span class="tok-o">*</span> <span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地, 里面实际的计算是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-mi">2000</span> <span class="tok-o">*</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-mi">2000</span> <span class="tok-o">**</span> <span class="tok-mi">100</span><span class="tok-o">.</span><span class="tok-nb">rand</span><span class="tok-o">.</span><span class="tok-n">Int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜！ 你现在可以像编译器那样毫不费力地解析 <code>* ** *</code> 结构了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_作业">10.12. 作业</h3>
<div class="paragraph">
<p>到目前为止，Perl 6 给了我们很多圣诞礼物。 让我们回过头来做一下练习并回答一下问题：下面代码中的每个星号在意味着什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">@n</span> <span class="tok-o">=</span>
    <span class="tok-p">((</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-o">*</span> <span class="tok-o">+</span> <span class="tok-o">*</span> <span class="tok-o">...</span> <span class="tok-o">*</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">grep</span><span class="tok-p">:</span> <span class="tok-o">*.</span><span class="tok-n">is</span><span class="tok-o">-</span><span class="tok-n">prime</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">:</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span><span class="tok-p">;</span>
<span class="tok-o">.</span><span class="tok-n">say</span> <span class="tok-k">for</span> <span class="tok-nv">@n</span><span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-mi">5</span><span class="tok-p">];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>D&#8217;哦。 我建议我们从转换代码开始来摆脱所有的星号，并使用不同的语法。</p>
</div>
<div class="paragraph">
<p>序列运算符 <code>&#8230;&#8203;</code> 之后的 <code>*</code> 意味着无限地生成序列，所以用 <code>Inf</code> 来代替它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-p">((</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-o">*</span> <span class="tok-o">+</span> <span class="tok-o">*</span> <span class="tok-o">...</span> <span class="tok-n">Inf</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">grep</span><span class="tok-p">:</span> <span class="tok-o">*.</span><span class="tok-n">is</span><span class="tok-o">-</span><span class="tok-n">prime</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">:</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>生成器函数中的两个星号 <code>* + *</code> 可以用一个带有两个显式参数的 lambda 函数来替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-p">((</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-o">-&gt;</span> <span class="tok-nv">$x</span><span class="tok-p">,</span> <span class="tok-nv">$y</span> <span class="tok-p">{</span><span class="tok-nv">$x</span> <span class="tok-o">+</span> <span class="tok-nv">$y</span><span class="tok-p">}</span> <span class="tok-o">...</span> <span class="tok-n">Inf</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">grep</span><span class="tok-p">:</span>
    <span class="tok-o">*.</span><span class="tok-n">is</span><span class="tok-o">-</span><span class="tok-n">prime</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">:</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，简单的语法交替。 用带圆括号的方法调用替换 <code>.grep</code>。 它的参数 <code><strong>.is-prime</code> 变成一个代码块，并且星号被替换为默认变量 <code>$_</code>。 请注意，代码使用 <code></strong></code> 时不需要花括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-o">-&gt;</span> <span class="tok-nv">$x</span><span class="tok-p">,</span> <span class="tok-nv">$y</span> <span class="tok-p">{</span><span class="tok-nv">$x</span> <span class="tok-o">+</span> <span class="tok-nv">$y</span><span class="tok-p">}</span> <span class="tok-o">...</span> <span class="tok-n">Inf</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">grep</span><span class="tok-p">({</span>
    <span class="tok-nv">$_</span><span class="tok-o">.</span><span class="tok-n">is</span><span class="tok-o">-</span><span class="tok-n">prime</span>
<span class="tok-p">})</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">:</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span> <span class="tok-o">*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，与 <code>.map</code> 相同的技巧：但是这次这个方法有三个参数，因此，你可以编写 <code>{$^a * $^b * $^c}</code> 而不是 <code>* * * * *</code>，这里是新的 完整程序的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">my</span> <span class="tok-nv">@n</span> <span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-o">-&gt;</span> <span class="tok-nv">$x</span><span class="tok-p">,</span> <span class="tok-nv">$y</span> <span class="tok-p">{</span><span class="tok-nv">$x</span> <span class="tok-o">+</span> <span class="tok-nv">$y</span><span class="tok-p">}</span> <span class="tok-o">...</span> <span class="tok-n">Inf</span><span class="tok-p">)</span><span class="tok-o">.</span><span class="tok-nb">grep</span><span class="tok-p">({</span>
        <span class="tok-nv">$_</span><span class="tok-o">.</span><span class="tok-n">is</span><span class="tok-o">-</span><span class="tok-n">prime</span>
    <span class="tok-p">})</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">({</span>
        <span class="tok-nv">$</span><span class="tok-err">^</span><span class="tok-nv">a</span> <span class="tok-o">*</span> <span class="tok-nv">$</span><span class="tok-err">^</span><span class="tok-nv">b</span> <span class="tok-o">*</span> <span class="tok-nv">$</span><span class="tok-err">^</span><span class="tok-nv">c</span>
    <span class="tok-p">});</span>
<span class="tok-o">.</span><span class="tok-n">say</span> <span class="tok-k">for</span> <span class="tok-nv">@n</span><span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-mi">5</span><span class="tok-p">];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在很明显，代码打印了三个斐波那契素数组积的前五个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_附加题">10.13. 附加题</h3>
<div class="paragraph">
<p>在教科书中，最具挑战性的任务是用 <code>*</code> 标记的。 这里有几个由你自己来解决。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. Perl 6 中的 <code>chdir('/')</code> 和 <code>＆*chdir('/')</code> 有什么区别？</p>
</li>
<li>
<p>2. 解释下面的 Perl 6 代码并修改它以展示其优点：<code>.say for 1 &#8230;&#8203; **</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>❄❄❄</p>
</div>
<div class="paragraph">
<p>今天就这样了。 我希望你喜欢 Perl 6 的强大功能和表现力。今天，我们只谈到了一个 ASCII 字符。 想象一下，如果考虑到该语言在当今编程语言中提供了最好的 Unicode 支持，Perl 6 的 Universe 是多么的庞大。</p>
</div>
<div class="paragraph">
<p>今天享受 Perl 6，并传播这个词！ 请继续关注 Perl 6 Advent Calendar; 更多的文章正在等待你的关注，明天就要来了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_the_year_of_perl_6_books">11. <a href="https://perl6advent.wordpress.com/2017/12/12/day-12-the-year-of-perl-6-books/">第十二天 – The Year of Perl 6 Books</a></h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_第十三天_使用_perl_6_挖掘维基百科">12. 第十三天 - 使用 Perl 6 挖掘维基百科</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍">12.1. 介绍</h3>
<div class="paragraph">
<p>大家好!</p>
</div>
<div class="paragraph">
<p>今天，让我介绍一下如何用 Perl 6 挖掘维基百科的 Infobox。</p>
</div>
<div class="paragraph">
<p>维基百科信息框在自然语言处理中扮演着非常重要的角色，并且有许多应用程序可以利用维基百科信息框：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构建知识库（例如 DBpedia[0]）</p>
</li>
<li>
<p>排名属性的重要性[1]</p>
</li>
<li>
<p>问答[2]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中，我将重点讨论信息框提取问题，并演示如何使用 Grammars 和 Actions 解析信息框的复杂结构。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_和_actions_难学吗">12.2. Grammar 和 Actions 难学吗?</h3>
<div class="paragraph">
<p>不，他们不是！</p>
</div>
<div class="paragraph">
<p>你只需要知道五件事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Grammar</p>
</li>
<li>
<p><strong>token</strong> 是最基础的一个。你通常使用它。</p>
</li>
<li>
<p><strong>rule</strong> 让空白符有意义。</p>
</li>
<li>
<p><strong>regex</strong> 让匹配引擎回溯。</p>
</li>
<li>
<p>Actions</p>
</li>
<li>
<p><strong>make</strong> 准备一个对象用于返回当 made calls on it。</p>
</li>
<li>
<p><strong>made</strong> 在它的调用者身上调用并返回准备好的对象。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>欲了解更多信息, 请查看: <a href="https://docs.perl6.org/language/grammars">https://docs.perl6.org/language/grammars</a></p>
</div>
<div class="sect3">
<h4 id="_什么是_infobox">12.2.1. 什么是 Infobox?</h4>
<div class="paragraph">
<p>你有没有听过 "Infobox" 这个词?</p>
</div>
<div class="paragraph">
<p>对于那些没听说过的人，我会简单地解释一下。</p>
</div>
<div class="paragraph">
<p>理解信息框的一个简单方法是使用一个真实的例子：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2017/11/perl6infobox.png">img</a></p>
</div>
<div class="paragraph">
<p>你可以看到，信息框会在页面的右上方显示页面主题的属性-值对儿。例如, 在这个例子中, 它说 Perl 6 的设计者 (ja: 設計者)是 Larry Wall(ja: ラリー・ウォール)。</p>
</div>
<div class="paragraph">
<p>欲了解更多信息, 请查看: <a href="https://en.wikipedia.org/wiki/Help:Infobox">https://en.wikipedia.org/wiki/Help:Infobox</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_第一个例子_perl_6">12.2.2. 第一个例子: Perl 6</h4>
<div class="paragraph">
<p>首先要说的是，我将使用日文维基百科而不是英文维基百科演示解析技术。</p>
</div>
<div class="paragraph">
<p>主要原因是解析日文维基百科是我的$ dayjob :)</p>
</div>
<div class="paragraph">
<p>第二个原因是我想要展示 Perl 6 如何轻松地处理 Unicode 字符串。</p>
</div>
<div class="paragraph">
<p>然后，让我们开始解析 <a href="https://ja.wikipedia.org/wiki/Perl_6">Perl 6 文章</a>中的信息框！</p>
</div>
<div class="paragraph">
<p>用 wiki 标记写的文章的代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{{<span class="tok-n">Comp-stub</span>}}

{{<span class="tok-n">Infobox</span> <span class="tok-n">プログラミング言語</span>
|<span class="tok-n">名前</span>             = <span class="tok-n">Perl</span> <span class="tok-mi">6</span>
|<span class="tok-n">ロゴ</span>             = [[<span class="tok-n">Image:Camelia</span>.<span class="tok-n">svg</span><span class="tok-o">|</span><span class="tok-mi">250</span><span class="tok-n">px</span>]]
|<span class="tok-n">パラダイム</span>       = [[<span class="tok-n">マルチパラダイムプログラミング言語</span><span class="tok-o">|</span><span class="tok-n">マルチパラダイム</span>]]
|<span class="tok-n">登場時期</span>         = [[<span class="tok-mi">2015</span><span class="tok-n">年</span>]]<span class="tok-mi">12</span><span class="tok-n">月25日</span>
|<span class="tok-n">設計者</span>           = [[<span class="tok-n">ラリー</span>・<span class="tok-n">ウォール</span>]]
|<span class="tok-n">最新リリース</span>     = <span class="tok-n">Rakudo</span> <span class="tok-n">Star</span> <span class="tok-mf">2016.04</span>
|<span class="tok-n">型付け</span>           = [[<span class="tok-n">動的型付け</span>]], [[<span class="tok-n">静的型付け</span>]]
|<span class="tok-n">処理系</span>           = [[<span class="tok-n">Rakudo</span>]]
|<span class="tok-n">影響を受けた言語</span> = [[<span class="tok-n">Perl</span><span class="tok-o">|</span><span class="tok-n">Perl</span> <span class="tok-mi">5</span>]], [[<span class="tok-n">Smalltalk</span>]], [[<span class="tok-n">Haskell</span>]], [[<span class="tok-n">Ruby</span>]]
|<span class="tok-n">ライセンス</span>       = [[<span class="tok-n">Artistic</span> <span class="tok-n">License</span> <span class="tok-mi">2</span>]]
|<span class="tok-n">ウェブサイト</span>     = [<span class="tok-n">https:</span>//<span class="tok-n">perl6</span>.<span class="tok-n">org</span>/ <span class="tok-n">Perl6</span>.<span class="tok-n">org</span>]
}}
{{<span class="tok-n">プログラミング言語</span>}}

<span class="tok-s">&#39;&#39;&#39;Perl 6&#39;&#39;&#39;</span>（<span class="tok-n">パールシックス</span>）<span class="tok-n">は</span>、[[<span class="tok-n">ラリー</span>・<span class="tok-n">ウォール</span>]]<span class="tok-n">により設計された</span>[[<span class="tok-n">オブジェクト指向</span>]][[<span class="tok-n">スクリプト言語</span>]]<span class="tok-n">である</span>。

<span class="tok-n">Perl</span> <span class="tok-mi">6</span><span class="tok-n">は</span>、[[<span class="tok-mi">2000</span><span class="tok-n">年</span>]]<span class="tok-n">に</span>[[<span class="tok-n">Perl</span>]]<span class="tok-n">の次期メジャーバージョンとして設計が始められ</span>、[[<span class="tok-mi">2015</span><span class="tok-n">年</span>]]<span class="tok-mi">12</span><span class="tok-n">月25日に公式のPerl</span> <span class="tok-mi">6</span><span class="tok-n">正式安定版がリリースされた</span>。<span class="tok-n">しかし</span>、<span class="tok-n">言語仕様は現在のPerl</span> (<span class="tok-n">Perl</span> <span class="tok-mi">5</span>)<span class="tok-n">と互換性がなく</span>、<span class="tok-n">既存のPerl</span> <span class="tok-mi">5</span><span class="tok-n">のソフトウェアをPerl</span> <span class="tok-mi">6</span><span class="tok-n">用に</span>「<span class="tok-n">アップグレ</span>
<span class="tok-n">ード</span>」<span class="tok-n">するのは極めて困難である</span>。<span class="tok-n">したがって現在はPerl</span> <span class="tok-mi">5</span><span class="tok-n">とPerl</span> <span class="tok-mi">6</span><span class="tok-n">は別の言語であると考えられており</span>、<span class="tok-n">Perl</span> <span class="tok-mi">6</span><span class="tok-n">はPerl</span> <span class="tok-mi">5</span><span class="tok-n">の次期バージョンではないとされている</span>。<span class="tok-n">換言すれば</span>、<span class="tok-n">Perl</span> <span class="tok-mi">6</span><span class="tok-n">はPerl</span> <span class="tok-mi">5</span><span class="tok-n">から移行対象とはみなされていない</span>。</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码有三个有问题的部分：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>信息框块后面有多余的元素，例如模板 <code>{{プログラミング言語}}</code> 和以 <code>'''Perl 6'''</code> 开头的主句。</p>
</li>
<li>
<p>我们必须区分三种类型的 token: 锚点文本（例如: <code><a id="Rakudo"></a></code>）, 原始文本（例如： <code>Rakudo Star 2016.04</code>）, 网站链接
（例如： <code>[<a href="https://perl6.org/" class="bare">https://perl6.org/</a> Perl6.org]</code>）。</p>
</li>
<li>
<p>信息框不从文章的顶部位置开始。在这个例子中, <code>{{Comb-stub}}</code> 在文章的顶部。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>好的，接下来我将演示如何按照 Grammar，Actions，Caller（即调用 Grammar 和 Actions 的代码部分）的顺序来解决上述问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar">12.2.3. Grammar</h4>
<div class="paragraph">
<p>解析信息框的 Grammar 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">Infobox::Grammar</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"> &lt;infobox&gt; .+ </span>} <span class="tok-c1"># (#1)</span>
    <span class="tok-k">token</span><span class="tok-n"> infobox</span> {<span class="tok-sr"> &#39;{{Infobox&#39; &lt;.ws&gt; &lt;name&gt; \n &lt;propertylist&gt; &#39;}}&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> name</span> {<span class="tok-sr"> &lt;-[\n]&gt;+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> propertylist</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;property&gt; \n</span>
<span class="tok-sr">            | \n</span>
<span class="tok-sr">        ]+</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> property</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; &lt;value=.value-content-list&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">token</span><span class="tok-n"> key-content</span> {<span class="tok-sr"> &lt;-[=\n]&gt;+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> value-content-list</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;value-content&gt;+</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> value-content</span> {<span class="tok-sr"> </span><span class="tok-c1"># (#6)</span><span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;anchortext&gt;</span>
<span class="tok-sr">            | &lt;weblink&gt;</span>
<span class="tok-sr">            | &lt;rawtext&gt;</span>
<span class="tok-sr">            | &lt;delimiter&gt;</span>
<span class="tok-sr">        ]+</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> anchortext</span> {<span class="tok-sr"> &#39;[[&#39; &lt;-[\n]&gt;+? &#39;]]&#39;        </span>} <span class="tok-c1"># (#2)</span>
    <span class="tok-k">token</span><span class="tok-n"> weblink</span>    {<span class="tok-sr"> &#39;[&#39; &lt;-[\n]&gt;+? &#39;]&#39;          </span>} <span class="tok-c1"># (#3)</span>
    <span class="tok-k">token</span><span class="tok-n"> rawtext</span>    {<span class="tok-sr"> &lt;-[\|\[\]\n、\,\&lt;\&gt;\}\{]&gt;+ </span>} <span class="tok-c1"># (#4)</span>
    <span class="tok-k">token</span><span class="tok-n"> delimiter</span>  {<span class="tok-sr"> [ &#39;、&#39; | &#39;,&#39; ]             </span>} <span class="tok-c1"># (#5)</span>
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 1 的答案:</p>
</li>
<li>
<p>使用 <code>.+</code> 来匹配多余的部分。(#1)</p>
</li>
<li>
<p>问题 2 的答案:</p>
</li>
<li>
<p>准备 3 种类型的 tokens: 锚文本(#2), 网站链接(#2), 和原始文本(#4)。</p>
</li>
<li>
<p>tokens 可能被分隔符（例如: <code>,</code>）分割, 所以准备分割符 token。(#5)</p>
</li>
<li>
<p>将 token 值-内容表示为四个 token 的任意长度序列（即，锚点文本，网站链接，原始文本，分隔符）。(#6)</p>
</li>
<li>
<p>问题 3 的答案:</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actions">12.2.4. Actions</h4>
<div class="paragraph">
<p>Actions 的代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">Infobox::Actions</span> {
    <span class="tok-k">method</span> <span class="tok-n">TOP</span>(<span class="tok-vg">$/</span>) { <span class="tok-k">make</span> <span class="tok-nv">$&lt;infobox&gt;</span>.<span class="tok-n">made</span> }
    <span class="tok-k">method</span> <span class="tok-n">infobox</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> %( <span class="tok-nb">name</span> =&gt; <span class="tok-nv">$&lt;name&gt;</span>.<span class="tok-n">made</span>, <span class="tok-n">propertylist</span> =&gt; <span class="tok-nv">$&lt;propertylist&gt;</span>.<span class="tok-n">made</span> )
    }
    <span class="tok-k">method</span> <span class="tok-nb">name</span>(<span class="tok-vg">$/</span>) { <span class="tok-k">make</span> ~<span class="tok-vg">$/</span>.<span class="tok-nb">trim</span> }
    <span class="tok-k">method</span> <span class="tok-n">propertylist</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> <span class="tok-nv">$&lt;property&gt;</span>&gt;&gt;.<span class="tok-n">made</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">property</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> <span class="tok-nv">$&lt;key&gt;</span>.<span class="tok-n">made</span> =&gt; <span class="tok-nv">$&lt;value&gt;</span>.<span class="tok-n">made</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">key-content</span>(<span class="tok-vg">$/</span>) { <span class="tok-k">make</span> <span class="tok-vg">$/</span>.<span class="tok-nb">trim</span> }
    <span class="tok-k">method</span> <span class="tok-n">value-content-list</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> <span class="tok-nv">$&lt;value-content&gt;</span>&gt;&gt;.<span class="tok-n">made</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">value-content</span>(<span class="tok-vg">$/</span>) { <span class="tok-c1"># (#1)</span>
        <span class="tok-k">my</span> <span class="tok-nv">$rawtext</span> = <span class="tok-nv">$&lt;rawtext&gt;</span>&gt;&gt;.<span class="tok-n">made</span>&gt;&gt;.<span class="tok-nb">trim</span>.<span class="tok-nb">grep</span>({ <span class="tok-nv">$_</span> <span class="tok-o">ne</span> <span class="tok-s">&quot;&quot;</span> });

        <span class="tok-k">make</span> %(
            <span class="tok-n">anchortext</span> =&gt; <span class="tok-nv">$&lt;anchortext&gt;</span>&gt;&gt;.<span class="tok-n">made</span>,
            <span class="tok-n">weblink</span> =&gt; <span class="tok-nv">$&lt;weblink&gt;</span>&gt;&gt;.<span class="tok-n">made</span>,
            <span class="tok-n">rawtext</span> =&gt; <span class="tok-nv">$rawtext</span>.<span class="tok-nb">elems</span> == <span class="tok-mi">0</span> ?? $[] !! <span class="tok-nv">$rawtext</span>.<span class="tok-nb">Array</span>
        );
    }
    <span class="tok-k">method</span> <span class="tok-n">anchortext</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> ~<span class="tok-vg">$/</span>;
    }
    <span class="tok-k">method</span> <span class="tok-n">weblink</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> ~<span class="tok-vg">$/</span>;
    }
    <span class="tok-k">method</span> <span class="tok-n">rawtext</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> ~<span class="tok-vg">$/</span>;
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 2 的解决方法:</p>
</li>
<li>
<p>使 token value-content 由三个键组成：anchortext，weblink 和 rawtext。</p>
</li>
<li>
<p>问题 1 和 3的解决方法:</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_caller">12.2.5. Caller</h4>
<div class="paragraph">
<p>Caller 部分的代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@lines</span> = <span class="tok-vg">$*IN</span>.<span class="tok-nb">lines</span>;
<span class="tok-k">while</span> <span class="tok-nv">@lines</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$chunk</span> = <span class="tok-nv">@lines</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot;\n&quot;</span>); <span class="tok-c1"># (#1)</span>
    <span class="tok-k">my</span> <span class="tok-nv">$result</span> = <span class="tok-n">Infobox::Grammar</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$chunk</span>, <span class="tok-n">actions</span> =&gt; <span class="tok-n">Infobox::Actions</span>).<span class="tok-n">made</span>; <span class="tok-c1"># (#2)</span>
    <span class="tok-k">if</span> <span class="tok-nv">$result&lt;name&gt;</span>:<span class="tok-n">exists</span> {
        <span class="tok-nv">$result&lt;name&gt;</span>.<span class="tok-nb">say</span>;
        <span class="tok-k">for</span> @(<span class="tok-nv">$result&lt;propertylist&gt;</span>) -&gt; (:<span class="tok-nv">$key</span>, :<span class="tok-n">value</span>(<span class="tok-nv">$content-list</span>)) { <span class="tok-c1"># (#3)</span>
            <span class="tok-nv">$key</span>.<span class="tok-nb">say</span>;
            <span class="tok-k">for</span> @(<span class="tok-nv">$content-list</span>) -&gt; <span class="tok-nv">$content</span> {
                <span class="tok-nv">$content</span>.<span class="tok-nb">say</span>;
            }
        }
    }
    <span class="tok-nb">shift</span> <span class="tok-nv">@lines</span>;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 3 的解决方法:</p>
</li>
<li>
<p>逐行阅读文章并制作一个包含当前行和最后一行之间的行的块。 （＃1）</p>
</li>
<li>
<p>如果解析器确定：</p>
</li>
<li>
<p>该块不包含信息框，它返回一个未定义的值。接收未定义值的好方法之一是使用 <code>$</code> 符号。(#2)</p>
</li>
<li>
<p>该块包含信息框，它返回一个定义的值。使用 <code>@()</code> contextualizer 并迭代结果。(#3)</p>
</li>
<li>
<p>问题 1 和 2 的解决方法：</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_运行解析器">12.2.6. 运行解析器</h4>
<div class="paragraph">
<p>你准备好了吗？
是时候运行第一个例子了！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">perl6</span> <span class="tok-n">parser</span>.<span class="tok-n">p6</span> &lt; <span class="tok-n">perl6</span>.<span class="tok-n">txt</span>
<span class="tok-n">プログラミング言語</span>
<span class="tok-n">名前</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [<span class="tok-n">Perl</span> <span class="tok-mi">6</span>], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">ロゴ</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">Image:Camelia</span>.<span class="tok-n">svg</span><span class="tok-o">|</span><span class="tok-mi">250</span><span class="tok-n">px</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">パラダイム</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">マルチパラダイムプログラミング言語</span><span class="tok-o">|</span><span class="tok-n">マルチパラダイム</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">登場時期</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-mi">2015</span><span class="tok-n">年</span>]]], <span class="tok-n">rawtext</span> =&gt; [<span class="tok-mi">12</span><span class="tok-n">月25日</span>], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">設計者</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">ラリー</span>・<span class="tok-n">ウォール</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">最新リリース</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [<span class="tok-n">Rakudo</span> <span class="tok-n">Star</span> <span class="tok-mf">2016.04</span>], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">型付け</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">動的型付け</span>]] [[<span class="tok-n">静的型付け</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">処理系</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">Rakudo</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">影響を受けた言語</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">Perl</span><span class="tok-o">|</span><span class="tok-n">Perl</span> <span class="tok-mi">5</span>]] [[<span class="tok-n">Smalltalk</span>]] [[<span class="tok-n">Haskell</span>]] [[<span class="tok-n">Ruby</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">ライセンス</span>
{<span class="tok-n">anchortext</span> =&gt; [[[<span class="tok-n">Artistic</span> <span class="tok-n">License</span> <span class="tok-mi">2</span>]]], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">ウェブサイト</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; [[<span class="tok-n">https:</span>//<span class="tok-n">perl6</span>.<span class="tok-n">org</span>/ <span class="tok-n">Perl6</span>.<span class="tok-n">org</span>]]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到的例子可能对您来说太简单了。让我们挑战更难的！</p>
</div>
</div>
<div class="sect3">
<h4 id="_第二个例子_阿尔伯特爱因斯坦">12.2.7. 第二个例子: 阿尔伯特爱因斯坦</h4>
<div class="paragraph">
<p>作为第二个例子，我们来解析<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%AB%E3%83%99%E3%83%AB%E3%83%88%E3%83%BB%E3%82%A2%E3%82%A4%E3%83%B3%E3%82%B7%E3%83%A5%E3%82%BF%E3%82%A4%E3%83%B3">阿尔伯特爱因斯坦</a>的信息框。</p>
</div>
<div class="paragraph">
<p>用 wiki 标记写的文章的代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{{<span class="tok-n">Infobox</span> <span class="tok-n">Scientist</span>
|<span class="tok-nb">name</span> = <span class="tok-n">アルベルト</span>・<span class="tok-n">アインシュタイン</span>
|<span class="tok-n">image</span> = <span class="tok-n">Einstein1921</span> <span class="tok-nb">by</span> <span class="tok-n">F</span> <span class="tok-n">Schmutzer</span> <span class="tok-mi">2</span>.<span class="tok-n">jpg</span>
|<span class="tok-n">caption</span> = [[<span class="tok-mi">1921</span><span class="tok-n">年</span>]]、[[<span class="tok-n">ウィーン</span>]]<span class="tok-n">での</span>[[<span class="tok-n">講義</span>]]<span class="tok-n">中</span>
|<span class="tok-n">birth_date</span> = {{<span class="tok-n">生年月日と年齢</span><span class="tok-o">|</span><span class="tok-mi">1879</span><span class="tok-o">|</span><span class="tok-mi">3</span><span class="tok-o">|</span><span class="tok-mi">14</span><span class="tok-o">|</span><span class="tok-n">no</span>}}
|<span class="tok-n">birth_place</span> = {{<span class="tok-n">DEU1871</span>}}<span class="tok-s">&lt;br&gt;</span>[[<span class="tok-n">ヴュルテンベルク王国</span>]][[<span class="tok-n">ウルム</span>]]
|<span class="tok-n">death_date</span> = {{<span class="tok-n">死亡年月日と没年齢</span><span class="tok-o">|</span><span class="tok-mi">1879</span><span class="tok-o">|</span><span class="tok-mi">3</span><span class="tok-o">|</span><span class="tok-mi">14</span><span class="tok-o">|</span><span class="tok-mi">1955</span><span class="tok-o">|</span><span class="tok-mi">4</span><span class="tok-o">|</span><span class="tok-mi">18</span>}}
|<span class="tok-n">death_place</span> = {{<span class="tok-n">USA1912</span>}}<span class="tok-s">&lt;br /&gt;</span>[[<span class="tok-n">ニュージャージー州</span>]][[<span class="tok-n">プリンストン</span> (<span class="tok-n">ニュージャージー州</span>)|<span class="tok-n">プリンストン</span>]]
|<span class="tok-n">residence</span> = {{<span class="tok-n">DEU</span>}}<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">ITA</span>}}<span class="tok-s">&lt;br&gt;</span>{{<span class="tok-n">CHE</span>}}<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">AUT</span>}}(<span class="tok-n">現在の</span>[[<span class="tok-n">チェコ</span>]])<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">BEL</span>}}<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">USA</span>}}
|<span class="tok-n">nationality</span> = {{<span class="tok-n">DEU1871</span>}}、<span class="tok-n">ヴュルテンベルク王国</span>（<span class="tok-mi">1879</span><span class="tok-o">-</span><span class="tok-mi">96</span>）<span class="tok-s">&lt;br /&gt;</span>[[<span class="tok-n">無国籍</span>]]（<span class="tok-mi">1896</span><span class="tok-o">-</span><span class="tok-mi">1901</span>）<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">CHE</span>}}（<span class="tok-mi">1901</span><span class="tok-o">-</span><span class="tok-mi">55</span>）<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">AUT1867</span>}}（<span class="tok-mi">1911</span><span class="tok-o">-</span><span class="tok-mi">12</span>）<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">DEU1871</span>}}、{{<span class="tok-n">DEU1919</span>}}（<span class="tok-mi">1914</span><span class="tok-o">-</span><span class="tok-mi">33</span>）<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">USA1912</span>}}（<span class="tok-mi">1940</span><span class="tok-o">-</span><span class="tok-mi">55</span>）
| <span class="tok-n">spouse</span>      = [[<span class="tok-n">ミレヴァ</span>・<span class="tok-n">マリッチ</span>]]<span class="tok-nv">&amp;nbsp</span>;(<span class="tok-mi">1903</span><span class="tok-o">-</span><span class="tok-mi">1919</span>)<span class="tok-s">&lt;br /&gt;</span>{{<span class="tok-n">nowrap</span>|{{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">エルザ</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Elsa</span> <span class="tok-n">Einstein</span><span class="tok-o">|</span><span class="tok-n">label</span>=<span class="tok-n">エルザ</span>・<span class="tok-n">レーベンタール</span>}}<span class="tok-nv">&amp;nbsp</span>;(<span class="tok-mi">1919</span><span class="tok-o">-</span><span class="tok-mi">1936</span>)}}
| <span class="tok-n">children</span>    = [[<span class="tok-n">リーゼル</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">リーゼル</span>]] (<span class="tok-mi">1902</span><span class="tok-o">-</span><span class="tok-mi">1903</span>?)<span class="tok-s">&lt;br /&gt;</span>[[<span class="tok-n">ハンス</span>・<span class="tok-n">アルベルト</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">ハンス</span>
・<span class="tok-n">アルベルト</span>]] (<span class="tok-mi">1904</span><span class="tok-o">-</span><span class="tok-mi">1973</span>)<span class="tok-s">&lt;br /&gt;</span>[[<span class="tok-n">エドゥアルト</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">エドゥアルト</span>]] (<span class="tok-mi">1910</span><span class="tok-o">-</span><span class="tok-mi">1965</span>)
|<span class="tok-n">field</span> = [[<span class="tok-n">物理学</span>]]<span class="tok-s">&lt;br /&gt;</span>[[<span class="tok-n">哲学</span>]]
|<span class="tok-n">work_institution</span> = {{<span class="tok-n">Plainlist</span>|
* [[<span class="tok-n">スイス特許庁</span>]] ([[<span class="tok-n">ベルン</span>]]) (<span class="tok-mi">1902</span><span class="tok-o">-</span><span class="tok-mi">1909</span>)
* {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">ベルン大学</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">University</span> <span class="tok-k">of</span> <span class="tok-n">Bern</span>}} (<span class="tok-mi">1908</span><span class="tok-o">-</span><span class="tok-mi">1909</span>)
* [[<span class="tok-n">チューリッヒ大学</span>]] (<span class="tok-mi">1909</span><span class="tok-o">-</span><span class="tok-mi">1911</span>)
* [[<span class="tok-n">プラハ</span>・<span class="tok-n">カレル大学</span>]] (<span class="tok-mi">1911</span><span class="tok-o">-</span><span class="tok-mi">1912</span>)
* [[<span class="tok-n">チューリッヒ工科大学</span>]] (<span class="tok-mi">1912</span><span class="tok-o">-</span><span class="tok-mi">1914</span>)
* [[<span class="tok-n">プロイセン科学アカデミー</span>]] (<span class="tok-mi">1914</span><span class="tok-o">-</span><span class="tok-mi">1933</span>)
* [[<span class="tok-n">フンボルト大学ベルリン</span>]] (<span class="tok-mi">1914</span><span class="tok-o">-</span><span class="tok-mi">1917</span>)
* {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">カイザー</span>・<span class="tok-n">ヴィルヘルム協会</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Kaiser</span> <span class="tok-n">Wilhelm</span> <span class="tok-n">Society</span><span class="tok-o">|</span><span class="tok-n">label</span>=<span class="tok-n">カイザー</span>・<span class="tok-n">ヴィルヘルム研究所</span>}} (<span class="tok-n">化学</span>・<span class="tok-n">物理学研究所長</span>, <span class="tok-mi">1917</span><span class="tok-o">-</span><span class="tok-mi">1933</span>)
* [[<span class="tok-n">ドイツ物理学会</span>]] (<span class="tok-n">会長</span>, <span class="tok-mi">1916</span><span class="tok-o">-</span><span class="tok-mi">1918</span>)
* [[<span class="tok-n">ライデン大学</span>]] (<span class="tok-n">客員</span>, <span class="tok-mi">1920</span>-)
* [[<span class="tok-n">プリンストン高等研究所</span>]] (<span class="tok-mi">1933</span><span class="tok-o">-</span><span class="tok-mi">1955</span>)
* [[<span class="tok-n">カリフォルニア工科大学</span>]] (<span class="tok-n">客員</span>, <span class="tok-mi">1931</span><span class="tok-o">-</span><span class="tok-mi">33</span>)
}}
|<span class="tok-n">alma_mater</span> = [[<span class="tok-n">チューリッヒ工科大学</span>]]<span class="tok-s">&lt;br /&gt;</span>[[<span class="tok-n">チューリッヒ大学</span>]]
|<span class="tok-n">doctoral_advisor</span> = {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">アルフレート</span>・<span class="tok-n">クライナー</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Alfred</span> <span class="tok-n">Kleiner</span>}}
|<span class="tok-n">academic_advisors</span> = {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">ハインリヒ</span>・<span class="tok-n">フリードリヒ</span>・<span class="tok-n">ウェーバー</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Heinrich</span> <span class="tok-n">Friedrich</span> <span class="tok-n">Weber</span>}}
|<span class="tok-n">doctoral_students</span> =
|<span class="tok-n">known_for</span> = {{<span class="tok-n">Plainlist</span>|
*[[<span class="tok-n">一般相対性理論</span>]]
*[[<span class="tok-n">特殊相対性理論</span>]]
*[[<span class="tok-n">光電効果</span>]]
*[[<span class="tok-n">ブラウン運動</span>]]
*<span class="tok-n">link:E</span>=<span class="tok-n">mc</span><span class="tok-s">&lt;sup&gt;</span><span class="tok-mi">2</span><span class="tok-s">&lt;/sup&gt;</span>[[<span class="tok-n">E</span>=<span class="tok-n">mc2</span><span class="tok-o">|</span><span class="tok-n">質量とエネルギーの等価性</span>]]
*[[<span class="tok-n">アインシュタイン方程式</span>]]
*[[<span class="tok-n">ボース分布関数</span>]]
*[[<span class="tok-n">宇宙定数</span>]]
*[[<span class="tok-n">ボース</span>＝<span class="tok-n">アインシュタイン凝縮</span>]]
*[[<span class="tok-n">EPRパラドックス</span>]]
*{{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">古典統一場論</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Classical</span> <span class="tok-n">unified</span> <span class="tok-n">field</span> <span class="tok-n">theories</span>}}
}}
| <span class="tok-n">influenced</span>  = {{<span class="tok-n">Plainlist</span>|
* {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">エルンスト</span>・<span class="tok-n">G</span>・<span class="tok-n">シュトラウス</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Ernst</span> <span class="tok-n">G</span>. <span class="tok-n">Straus</span>}}
* [[<span class="tok-n">ネイサン</span>・<span class="tok-n">ローゼン</span>]]
* [[<span class="tok-n">レオ</span>・<span class="tok-n">シラード</span>]]
}}
|<span class="tok-n">prizes</span> = {{<span class="tok-n">Plainlist</span>|
*{{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">バーナード</span>・<span class="tok-n">メダル</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Barnard</span> <span class="tok-n">Medal</span> <span class="tok-k">for</span> <span class="tok-n">Meritorious</span> <span class="tok-n">Service</span> <span class="tok-nb">to</span> <span class="tok-n">Science</span>}}(<span class="tok-mi">1920</span>)
*<span class="tok-n">link:1921</span>[[<span class="tok-n">ノーベル物理学賞</span>]]
*<span class="tok-n">link:1921</span>[[<span class="tok-n">マテウチ</span>・<span class="tok-n">メダル</span>]]
*<span class="tok-n">link:1925</span>[[<span class="tok-n">コプリ</span>・<span class="tok-n">メダル</span>]]
*<span class="tok-n">link:1926</span>[[<span class="tok-n">王立天文学会ゴールドメダル</span>]]
*<span class="tok-n">link:1929</span>[[<span class="tok-n">マックス</span>・<span class="tok-n">プランク</span>・<span class="tok-n">メダル</span>]]
}}
|<span class="tok-n">religion</span> =
|<span class="tok-nb">signature</span> = <span class="tok-n">Albert</span> <span class="tok-n">Einstein</span> <span class="tok-nb">signature</span> <span class="tok-mi">1934</span>.<span class="tok-n">svg</span>
|<span class="tok-n">footnotes</span> =
}}
{{<span class="tok-n">thumbnail:begin</span>}}
{{<span class="tok-n">thumbnail:ノーベル賞受賞者</span><span class="tok-o">|</span><span class="tok-mi">1921</span><span class="tok-n">年</span><span class="tok-o">|</span><span class="tok-n">ノーベル物理学賞</span><span class="tok-o">|</span><span class="tok-n">光電効果の法則の発見等</span>}}
{{<span class="tok-n">thumbnail:end</span>}}
<span class="tok-s">&#39;&#39;&#39;アルベルト・アインシュタイン&#39;&#39;&#39;&lt;ref group=&quot;†&quot;&gt;</span>[[<span class="tok-n">日本語</span>]]<span class="tok-n">における表記には</span>、<span class="tok-n">他に</span>「<span class="tok-n">アル</span>{{<span class="tok-n">Underline</span><span class="tok-o">|</span><span class="tok-n">バー</span>}}<span class="tok-n">ト</span>・<span class="tok-n">アインシュine</span><span class="tok-o">|</span><span class="tok-n">バー</span>}}<span class="tok-n">ト</span>・<span class="tok-n">アイン</span>{{<span class="tok-n">Underline</span><span class="tok-o">|</span><span class="tok-n">ス</span>}}<span class="tok-n">タイン</span>」（[[<span class="tok-n">英語</span>]]<span class="tok-n">の発音由来</span>）<span class="tok-n">がある</span>。<span class="tok-s">&lt;/ref&gt;</span>（{{<span class="tok-n">lang-de-short</span><span class="tok-o">|</span><span class="tok-n">Albert</span> <span class="tok-n">Einstein</span>}}<span class="tok-s">&lt;ref ɛrt ˈaɪnˌʃtaɪn}} &#39;&#39;&#39;ア&#39;&#39;&#39;ルベルト・&#39;&#39;&#39;ア&#39;&#39;&#39;インシュタイン、&#39;&#39;&#39;ア&#39;&#39;&#39;ルバート・&#39;&#39;&#39;ア&#39;&#39;&#39;インシュタイン&lt;/ref&gt;&lt;ref group=&quot;†&quot;taɪn}} &#39;&#39;&#39;ア&#39;&#39;&#39;ルバ（ー）ト・&#39;&#39;&#39;ア&#39;&#39;&#39;インスタイン、&#39;&#39;&#39;ア&#39;&#39;&#39;ルバ（ー）&#39;&#39;&#39;タ&#39;&#39;&#39;インスタイン&lt;/ref&gt;&lt;ref&gt;</span>[<span class="tok-n">http:</span>//<span class="tok-n">dictionary</span>.<span class="tok-n">rein</span> <span class="tok-n">Einstein</span>] (<span class="tok-n">Dictionary</span>.<span class="tok-n">com</span>)<span class="tok-s">&lt;/ref&gt;&lt;ref&gt;</span>[<span class="tok-n">http:</span>//<span class="tok-n">www</span>.<span class="tok-n">oxfordlearnersdictionaries</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">definition</span><span class="tok-o">/</span><span class="tok-n">english</span><span class="tok-o">/</span><span class="tok-n">albert-einstein</span><span class="tok-o">?</span><span class="tok-s">q=Albert+Einstein Albert Einstein] (Oxford Learner&#39;s Dictionaries)&lt;/ref&gt;、[[1879年]][[3月14日]] - [[1955年]][[4月18日]]）ツ]]生まれの[[理論物理学者]]である。</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，这里有五个新问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一些模板</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>包含换行符;并且</p>
</li>
<li>
<p>是嵌套的(例如. <code>{{nowrap|{{仮リンク|&#8230;&#8203;}}&#8230;&#8203;}}</code>)</p>
</li>
</ol>
</div>
</li>
<li>
<p>某些 attribute-value 对是空的。</p>
</li>
<li>
<p>attribute-value 对的一些 value-sides</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>包含中断标签;并且</p>
</li>
<li>
<p>由不同类型的 token 组成（例如，anchortext 和 rawtext）。所以你需要添加位置信息来表示 tokens 之间的依赖关系。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>我将按照 Grammar，Actions 的顺序展示如何解决上述问题。</p>
</div>
<div class="paragraph">
<p>Caller 的代码与前一个相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar_2">12.2.8. Grammar</h4>
<div class="paragraph">
<p>Grammar 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">Infobox::Grammar</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"> &lt;infobox&gt; .+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> infobox</span> {<span class="tok-sr"> &#39;{{Infobox&#39; &lt;.ws&gt; &lt;name&gt; \n &lt;propertylist&gt; &#39;}}&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> name</span> {<span class="tok-sr"> &lt;-[\n]&gt;+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> propertylist</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;property&gt; \n</span>
<span class="tok-sr">            | \n</span>
<span class="tok-sr">        ]+</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> property</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; &lt;value=.value-content-list&gt;</span>
<span class="tok-sr">            | &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; </span><span class="tok-c1"># (#4)</span><span class="tok-sr"></span>
<span class="tok-sr">        ]</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">token</span><span class="tok-n"> key-content</span> {<span class="tok-sr"> &lt;-[=\n]&gt;+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> value-content-list</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;value-content&gt; &lt;br&gt; </span><span class="tok-c1"># (#6)</span><span class="tok-sr"></span>
<span class="tok-sr">            | &lt;value-content&gt;</span>
<span class="tok-sr">            | &lt;br&gt;</span>
<span class="tok-sr">        ]+</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> value-content-list-nl</span> {<span class="tok-sr"> </span><span class="tok-c1"># (#1)</span><span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;value-content&gt; &lt;br&gt; </span><span class="tok-c1"># (#7)</span><span class="tok-sr"></span>
<span class="tok-sr">            | &lt;value-content&gt;</span>
<span class="tok-sr">            | &lt;br&gt;</span>
<span class="tok-sr">        ]+ % \n</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> value-content</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;anchortext&gt;</span>
<span class="tok-sr">            | &lt;weblink&gt;</span>
<span class="tok-sr">            | &lt;rawtext&gt;</span>
<span class="tok-sr">            | &lt;template&gt;</span>
<span class="tok-sr">            | &lt;delimiter&gt;</span>
<span class="tok-sr">            | &lt;sup&gt;</span>
<span class="tok-sr">        ]+</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> br</span> {<span class="tok-sr"> </span><span class="tok-c1"># (#5)</span><span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &#39;&lt;br /&gt;&#39;</span>
<span class="tok-sr">            | &#39;&lt;br/&gt;&#39;</span>
<span class="tok-sr">            | &#39;&lt;br&gt;&#39;</span>
<span class="tok-sr">        ]</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> template</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &#39;{{&#39; &lt;-[\n]&gt;+? &#39;}}&#39;</span>
<span class="tok-sr">            | &#39;{{nowrap&#39; &#39;|&#39; &lt;value-content-list&gt; &#39;}}&#39; </span><span class="tok-c1"># (#3)</span><span class="tok-sr"></span>
<span class="tok-sr">            | &#39;{{Plainlist&#39; &#39;|&#39; \n &lt;value-content-list-nl&gt; \n &#39;}}&#39; </span><span class="tok-c1"># (#2)</span><span class="tok-sr"></span>
<span class="tok-sr">        ]</span>
<span class="tok-sr">    </span>}
    <span class="tok-k">token</span><span class="tok-n"> anchortext</span> {<span class="tok-sr"> &#39;[[&#39; &lt;-[\n]&gt;+? &#39;]]&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> weblink</span> {<span class="tok-sr"> &#39;[&#39; &lt;-[\n]&gt;+? &#39;]&#39; </span>}
    <span class="tok-k">token</span><span class="tok-n"> rawtext</span> {<span class="tok-sr"> &lt;-[\|\[\]\n、\,\&lt;\&gt;\}\{]&gt;+ </span>}
    <span class="tok-k">token</span><span class="tok-n"> delimiter</span> {<span class="tok-sr"> [ &#39;、&#39; | &#39;,&#39; | &#39;&amp;nbsp;&#39; ] </span>}
    <span class="tok-k">token</span><span class="tok-n"> sup</span> {<span class="tok-sr"> &#39;&lt;sup&gt;&#39; &lt;-[\n]&gt;+? &#39;&lt;/sup&gt;&#39;</span>}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 1.1 的解决方法：</p>
</li>
<li>
<p>创建 token <strong>value-content-list-nl</strong>，它是 value-content-list token 的换行符分隔版本。使用<a href="https://docs.perl6.org/language/regexes#Modified_quantifier:_%,_%%">修改量词</a> <code>％</code> 来表示这种序列是很有用的。 （＃1）</p>
</li>
<li>
<p>创建 token 模板。在这一个中，定义一个代表 <a href="https://en.wikipedia.org/wiki/Template:Plainlist">Plainlist 模板</a> 的序列。 （＃2）</p>
</li>
<li>
<p>问题 1.2 的解决方法：</p>
</li>
<li>
<p>使 token 模板能够调用 token value-content-list。此修改触发递归调用并捕获嵌套结构，因为 token value-content-list 包含 token 模板。 （＃3）</p>
</li>
<li>
<p>问题 2 的解决方法：</p>
</li>
<li>
<p>在 token <strong>property</strong> 中，定义一个 value-side 为空的序列（即以'='结尾的序列）。 （＃4）</p>
</li>
<li>
<p>问题 3.1 的解决方法:</p>
</li>
<li>
<p>创建 token br（＃5）
 - 让 token br 遵循两个 token 中的 token value-content：</p>
</li>
<li>
<p>token value-content-list （＃6）</p>
</li>
<li>
<p>token-content-list-nl（＃7）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actions_2">12.2.9. Actions</h4>
<div class="paragraph">
<p>Action 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">Infobox::Actions</span> {
    <span class="tok-k">method</span> <span class="tok-n">TOP</span>(<span class="tok-vg">$/</span>) { <span class="tok-k">make</span> <span class="tok-nv">$&lt;infobox&gt;</span>.<span class="tok-n">made</span> }
    <span class="tok-k">method</span> <span class="tok-n">infobox</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> %( <span class="tok-nb">name</span> =&gt; <span class="tok-nv">$&lt;name&gt;</span>.<span class="tok-n">made</span>, <span class="tok-n">propertylist</span> =&gt; <span class="tok-nv">$&lt;propertylist&gt;</span>.<span class="tok-n">made</span> )
    }
    <span class="tok-k">method</span> <span class="tok-nb">name</span>(<span class="tok-vg">$/</span>) { <span class="tok-k">make</span> <span class="tok-vg">$/</span>.<span class="tok-nb">trim</span> }
    <span class="tok-k">method</span> <span class="tok-n">propertylist</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> <span class="tok-nv">$&lt;property&gt;</span>&gt;&gt;.<span class="tok-n">made</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">property</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> <span class="tok-nv">$&lt;key&gt;</span>.<span class="tok-n">made</span> =&gt; <span class="tok-nv">$&lt;value&gt;</span>.<span class="tok-n">made</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">key-content</span>(<span class="tok-vg">$/</span>) { <span class="tok-k">make</span> <span class="tok-vg">$/</span>.<span class="tok-nb">trim</span> }
    <span class="tok-k">method</span> <span class="tok-n">value-content-list</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> <span class="tok-nv">$&lt;value-content&gt;</span>&gt;&gt;.<span class="tok-n">made</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">value-content</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">my</span> <span class="tok-nv">$rawtext</span> = <span class="tok-nv">$&lt;rawtext&gt;</span>&gt;&gt;.<span class="tok-n">made</span>&gt;&gt;.<span class="tok-nb">trim</span>.<span class="tok-nb">grep</span>({ <span class="tok-nv">$_</span> <span class="tok-o">ne</span> <span class="tok-s">&quot;&quot;</span> });

        <span class="tok-k">make</span> %(
            <span class="tok-n">anchortext</span> =&gt; <span class="tok-nv">$&lt;anchortext&gt;</span>&gt;&gt;.<span class="tok-n">made</span>,
            <span class="tok-n">weblink</span> =&gt; <span class="tok-nv">$&lt;weblink&gt;</span>&gt;&gt;.<span class="tok-n">made</span>,
            <span class="tok-n">rawtext</span> =&gt; <span class="tok-nv">$rawtext</span>.<span class="tok-nb">elems</span> == <span class="tok-mi">0</span> ?? $[] !! <span class="tok-nv">$rawtext</span>.<span class="tok-nb">Array</span>,
            <span class="tok-n">template</span> =&gt; <span class="tok-nv">$&lt;template&gt;</span>&gt;&gt;.<span class="tok-n">made</span>;
        );
    }
    <span class="tok-k">method</span> <span class="tok-n">template</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> %(<span class="tok-nb">body</span> =&gt; ~<span class="tok-vg">$/</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">from</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">to</span>); <span class="tok-c1"># (#1)</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">anchortext</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> %(<span class="tok-nb">body</span> =&gt; ~<span class="tok-vg">$/</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">from</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">to</span>); <span class="tok-c1"># (#2)</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">weblink</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> %(<span class="tok-nb">body</span> =&gt; ~<span class="tok-vg">$/</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">from</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">to</span>); <span class="tok-c1"># (#3)</span>
    }
    <span class="tok-k">method</span> <span class="tok-n">rawtext</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">make</span> %(<span class="tok-nb">body</span> =&gt; ~<span class="tok-vg">$/</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">from</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-vg">$/</span>.<span class="tok-nb">to</span>); <span class="tok-c1"># (#4)</span>
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 3.2 的解决方法：</p>
</li>
<li>
<p>调用 make 时，分别使用 Match.from 和 Match.to 来获取匹配开始位置和匹配结束位置。 （＃1〜＃4）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_运行解析器_2">12.2.10. 运行解析器</h4>
<div class="paragraph">
<p>该跑了！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">perl6</span> <span class="tok-n">parser</span>.<span class="tok-n">p6</span> &lt; <span class="tok-n">einstein</span>.<span class="tok-n">txt</span>
<span class="tok-n">Scientist</span>
<span class="tok-nb">name</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; <span class="tok-n">アルベルト</span>・<span class="tok-n">アインシュタイン</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">27</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">42</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">image</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; <span class="tok-n">Einstein1921</span> <span class="tok-nb">by</span> <span class="tok-n">F</span> <span class="tok-n">Schmutzer</span> <span class="tok-mi">2</span>.<span class="tok-n">jpg</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">51</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">85</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">caption</span>
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-mi">1921</span><span class="tok-n">年</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">97</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">106</span>} {<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">ウィーン</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">107</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">115</span>} {<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">講義</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">117</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">123</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">96</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">97</span>} {<span class="tok-nb">body</span> =&gt; <span class="tok-n">での</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">115</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">117</span>} {<span class="tok-nb">body</span> =&gt; <span class="tok-n">中</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">123</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">124</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">birth_date</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">138</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">139</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">生年月日と年齢</span><span class="tok-o">|</span><span class="tok-mi">1879</span><span class="tok-o">|</span><span class="tok-mi">3</span><span class="tok-o">|</span><span class="tok-mi">14</span><span class="tok-o">|</span><span class="tok-n">no</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">139</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">163</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">birth_place</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">178</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">179</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">DEU1871</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">179</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">190</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">ヴュルテンベルク王国</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">194</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">208</span>} {<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">ウルム</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">208</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">215</span>}], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">death_date</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">229</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">230</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">死亡年月日と没年齢</span><span class="tok-o">|</span><span class="tok-mi">1879</span><span class="tok-o">|</span><span class="tok-mi">3</span><span class="tok-o">|</span><span class="tok-mi">14</span><span class="tok-o">|</span><span class="tok-mi">1955</span><span class="tok-o">|</span><span class="tok-mi">4</span><span class="tok-o">|</span><span class="tok-mi">18</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">230</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">263</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">death_place</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">278</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">279</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">USA1912</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">279</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">290</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">ニュージャージー州</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">296</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">309</span>} {<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">プリンストン</span> (<span class="tok-n">ニュージャージー州</span>)|<span class="tok-n">プリンストン</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">309</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">338</span>}], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">residence</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">351</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">352</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">DEU</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">352</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">359</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">ITA</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">365</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">372</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">CHE</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">376</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">383</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">チェコ</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">400</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">407</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; (<span class="tok-n">現在の</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">396</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">400</span>} {<span class="tok-nb">body</span> =&gt; ), <span class="tok-nb">from</span> =&gt; <span class="tok-mi">407</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">408</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">AUT</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">389</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">396</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">BEL</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">414</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">421</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">USA</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">427</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">434</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">nationality</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">449</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">450</span>} {<span class="tok-nb">body</span> =&gt; <span class="tok-n">ヴュルテンベルク王国</span>（<span class="tok-mi">1879</span><span class="tok-o">-</span><span class="tok-mi">96</span>）, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">462</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">481</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">DEU1871</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">450</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">461</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">無国籍</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">487</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">494</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; （<span class="tok-mi">1896</span><span class="tok-o">-</span><span class="tok-mi">1901</span>）, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">494</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">505</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; （<span class="tok-mi">1901</span><span class="tok-o">-</span><span class="tok-mi">55</span>）, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">518</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">527</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">CHE</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">511</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">518</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; （<span class="tok-mi">1911</span><span class="tok-o">-</span><span class="tok-mi">12</span>）, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">544</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">553</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">AUT1867</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">533</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">544</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; （<span class="tok-mi">1914</span><span class="tok-o">-</span><span class="tok-mi">33</span>）, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">582</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">591</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">DEU1871</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">559</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">570</span>} {<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">DEU1919</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">571</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">582</span>}], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; （<span class="tok-mi">1940</span><span class="tok-o">-</span><span class="tok-mi">55</span>）, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">608</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">617</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">USA1912</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">597</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">608</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">spouse</span>
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">ミレヴァ</span>・<span class="tok-n">マリッチ</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">634</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">647</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">633</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">634</span>} {<span class="tok-nb">body</span> =&gt; (<span class="tok-mi">1903</span><span class="tok-o">-</span><span class="tok-mi">1919</span>), <span class="tok-nb">from</span> =&gt; <span class="tok-mi">653</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">664</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">nowrap</span>|{{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">エルザ</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Elsa</span> <span class="tok-n">Einstein</span><span class="tok-o">|</span><span class="tok-n">label</span>=<span class="tok-n">エルザ</span>・<span class="tok-n">レーベンタール</span>}}<span class="tok-nv">&amp;nbsp</span>;(<span class="tok-mi">1919</span><span class="tok-o">-</span><span class="tok-mi">1936</span>)}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">670</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">754</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">children</span>
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">リーゼル</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">リーゼル</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">771</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">793</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">770</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">771</span>} {<span class="tok-nb">body</span> =&gt; (<span class="tok-mi">1902</span><span class="tok-o">-</span><span class="tok-mi">1903</span>?), <span class="tok-nb">from</span> =&gt; <span class="tok-mi">793</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">806</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">ハンス</span>・<span class="tok-n">アルベルト</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">ハンス</span>・<span class="tok-n">アルベルト</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">812</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">844</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; (<span class="tok-mi">1904</span><span class="tok-o">-</span><span class="tok-mi">1973</span>), <span class="tok-nb">from</span> =&gt; <span class="tok-mi">844</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">856</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">エドゥアルト</span>・<span class="tok-n">アインシュタイン</span><span class="tok-o">|</span><span class="tok-n">エドゥアルト</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">862</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">888</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; (<span class="tok-mi">1910</span><span class="tok-o">-</span><span class="tok-mi">1965</span>), <span class="tok-nb">from</span> =&gt; <span class="tok-mi">888</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">900</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">field</span>
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">物理学</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">910</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">917</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">909</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">910</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">哲学</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">923</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">929</span>}], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">work_institution</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">949</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">950</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">Plainlist</span>|
* [[<span class="tok-n">スイス特許庁</span>]] ([[<span class="tok-n">ベルン</span>]]) (<span class="tok-mi">1902</span><span class="tok-o">-</span><span class="tok-mi">1909</span>)
* {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">ベルン大学</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">University</span> <span class="tok-k">of</span> <span class="tok-n">Bern</span>}} (<span class="tok-mi">1908</span><span class="tok-o">-</span><span class="tok-mi">1909</span>)
* [[<span class="tok-n">チューリッヒ大学</span>]] (<span class="tok-mi">1909</span><span class="tok-o">-</span><span class="tok-mi">1911</span>)
* [[<span class="tok-n">プラハ</span>・<span class="tok-n">カレル大学</span>]] (<span class="tok-mi">1911</span><span class="tok-o">-</span><span class="tok-mi">1912</span>)
* [[<span class="tok-n">チューリッヒ工科大学</span>]] (<span class="tok-mi">1912</span><span class="tok-o">-</span><span class="tok-mi">1914</span>)
* [[<span class="tok-n">プロイセン科学アカデミー</span>]] (<span class="tok-mi">1914</span><span class="tok-o">-</span><span class="tok-mi">1933</span>)
* [[<span class="tok-n">フンボルト大学ベルリン</span>]] (<span class="tok-mi">1914</span><span class="tok-o">-</span><span class="tok-mi">1917</span>)
* {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">カイザー</span>・<span class="tok-n">ヴィルヘルム協会</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Kaiser</span> <span class="tok-n">Wilhelm</span> <span class="tok-n">Society</span><span class="tok-o">|</span><span class="tok-n">label</span>=<span class="tok-n">カイザー</span>・<span class="tok-n">ヴィルヘルム研究所</span>}} (<span class="tok-n">化学</span>・<span class="tok-n">物理学研究所長</span>, <span class="tok-mi">1917</span><span class="tok-o">-</span><span class="tok-mi">1933</span>)
* [[<span class="tok-n">ドイツ物理学会</span>]] (<span class="tok-n">会長</span>, <span class="tok-mi">1916</span><span class="tok-o">-</span><span class="tok-mi">1918</span>)
* [[<span class="tok-n">ライデン大学</span>]] (<span class="tok-n">客員</span>, <span class="tok-mi">1920</span>-)
* [[<span class="tok-n">プリンストン高等研究所</span>]] (<span class="tok-mi">1933</span><span class="tok-o">-</span><span class="tok-mi">1955</span>)
* [[<span class="tok-n">カリフォルニア工科大学</span>]] (<span class="tok-n">客員</span>, <span class="tok-mi">1931</span><span class="tok-o">-</span><span class="tok-mi">33</span>)
}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">950</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1409</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">alma_mater</span>
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">チューリッヒ工科大学</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1424</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1438</span>}], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1423</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1424</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
{<span class="tok-n">anchortext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; [[<span class="tok-n">チューリッヒ大学</span>]], <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1444</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1456</span>}], <span class="tok-n">rawtext</span> =&gt; [], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">doctoral_advisor</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1476</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1477</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">アルフレート</span>・<span class="tok-n">ク</span>
<span class="tok-n">ライナー</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Alfred</span> <span class="tok-n">Kleiner</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1477</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1516</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">academic_advisors</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1537</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1538</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">ハインリヒ</span>・<span class="tok-n">フリ</span>
<span class="tok-n">ードリヒ</span>・<span class="tok-n">ウェーバー</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Heinrich</span> <span class="tok-n">Friedrich</span> <span class="tok-n">Weber</span>}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1538</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1593</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">doctoral_students</span>
<span class="tok-n">Nil</span>
<span class="tok-n">known_for</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1627</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1628</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">Plainlist</span>|
*[[<span class="tok-n">一般相対性理論</span>]]
*[[<span class="tok-n">特殊相対性理論</span>]]
*[[<span class="tok-n">光電効果</span>]]
*[[<span class="tok-n">ブラウン運動</span>]]
*<span class="tok-n">link:E</span>=<span class="tok-n">mc</span><span class="tok-s">&lt;sup&gt;</span><span class="tok-mi">2</span><span class="tok-s">&lt;/sup&gt;</span>[[<span class="tok-n">E</span>=<span class="tok-n">mc2</span><span class="tok-o">|</span><span class="tok-n">質量とエネルギーの等価性</span>]]
*[[<span class="tok-n">アインシュタイン方程式</span>]]
*[[<span class="tok-n">ボース分布関数</span>]]
*[[<span class="tok-n">宇宙定数</span>]]
*[[<span class="tok-n">ボース</span>＝<span class="tok-n">アインシュタイン凝縮</span>]]
*[[<span class="tok-n">EPRパラドックス</span>]]
*{{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">古典統一場論</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Classical</span> <span class="tok-n">unified</span> <span class="tok-n">field</span> <span class="tok-n">theories</span>}}
}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1628</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1861</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">influenced</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1877</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1878</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">Plainlist</span>|
* {{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">エルンスト</span>・<span class="tok-n">G</span>・<span class="tok-n">シュトラウス</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Ernst</span> <span class="tok-n">G</span>. <span class="tok-n">Straus</span>}}
* [[<span class="tok-n">ネイサン</span>・<span class="tok-n">ローゼン</span>]]
* [[<span class="tok-n">レオ</span>・<span class="tok-n">シラード</span>]]
}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1878</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1968</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">prizes</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; , <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1978</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">1979</span>}], <span class="tok-n">template</span> =&gt; [{<span class="tok-nb">body</span> =&gt; {{<span class="tok-n">Plainlist</span>|
*{{<span class="tok-n">仮リンク</span><span class="tok-o">|</span><span class="tok-n">バーナード</span>・<span class="tok-n">メダル</span><span class="tok-o">|</span><span class="tok-n">en</span><span class="tok-o">|</span><span class="tok-n">Barnard</span> <span class="tok-n">Medal</span> <span class="tok-k">for</span> <span class="tok-n">Meritorious</span> <span class="tok-n">Service</span> <span class="tok-nb">to</span> <span class="tok-n">Science</span>}}(<span class="tok-mi">1920</span>)
*<span class="tok-n">link:1921</span>[[<span class="tok-n">ノーベル物理学賞</span>]]
*<span class="tok-n">link:1921</span>[[<span class="tok-n">マテウチ</span>・<span class="tok-n">メダル</span>]]
*<span class="tok-n">link:1925</span>[[<span class="tok-n">コプリ</span>・<span class="tok-n">メダル</span>]]
*<span class="tok-n">link:1926</span>[[<span class="tok-n">王立天文学会ゴールドメダル</span>]]
*<span class="tok-n">link:1929</span>[[<span class="tok-n">マックス</span>・<span class="tok-n">プランク</span>・<span class="tok-n">メダル</span>]]
}}, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">1979</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">2181</span>}], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">religion</span>
<span class="tok-n">Nil</span>
<span class="tok-nb">signature</span>
{<span class="tok-n">anchortext</span> =&gt; [], <span class="tok-n">rawtext</span> =&gt; [{<span class="tok-nb">body</span> =&gt; <span class="tok-n">Albert</span> <span class="tok-n">Einstein</span> <span class="tok-nb">signature</span> <span class="tok-mi">1934</span>.<span class="tok-n">svg</span>, <span class="tok-nb">from</span> =&gt; <span class="tok-mi">2206</span>, <span class="tok-nb">to</span> =&gt; <span class="tok-mi">2241</span>}], <span class="tok-n">template</span> =&gt; [], <span class="tok-n">weblink</span> =&gt; []}
<span class="tok-n">footnotes</span>
<span class="tok-n">Nil</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_结论_4">12.2.11. 结论</h4>
<div class="paragraph">
<p>我演示了信息框的解析技术。如果您有机会将 Wikipedia 用作 NLP 的资源，我强烈建议您创建自己的解析器。它不仅会加深你对 Perl 6 的理解而且还会加深关于维基百科知识的理解。</p>
</div>
<div class="paragraph">
<p>再见！</p>
</div>
</div>
<div class="sect3">
<h4 id="_引文">12.2.12. 引文</h4>
<div class="paragraph">
<p>[0] Lehmann，Jens 等人。 “DBpedia&#8212;&#8203;一种从维基百科中提取的大型多语言知识库。”Semantic Web 6.2（2015）：167-195。</p>
</div>
<div class="paragraph">
<p>[1]阿里，Esraa，Annalina Caputo 和 SéamusLawless。 “使用学习排序的实体属性排名”。</p>
</div>
<div class="paragraph">
<p>[2]莫拉莱斯，阿尔瓦罗等人。 “学会回答维基百科信息框的问题。”2016年自然语言处理实证方法会议论文集。 2016年</p>
</div>
</div>
<div class="sect3">
<h4 id="_license">12.2.13. License</h4>
<div class="paragraph">
<p>所有来自维基百科的资料都是根据Creative Commons Attribution-ShareAlike 3.0 Unported License 授权使用的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Itsuki丰田，日本的网页开发人员。
== <a href="https://perl6advent.wordpress.com/2017/12/14/day-14-the-little-match-girl-building-and-testing-big-grammars-in-perl-6/">第十四天-在 Perl 6 中构建和测试 Big Grammars</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Perl 6 Grammars 很棒，但在项目中使用它们会是什么样呢？在圣诞节前和圣诞节后，我的经历是一个令人心酸的故事。你可以在<a href="https://github.com/albastev/Grammar-Modelica/tree/parse_modelica_library">这里</a>找到版本库。我不是来自计算机科学背景，所以也许它看起来很简陋，但是当我学习 Perl 6 Grammars 时，这是我的困难和胜利。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_第一根火柴">12.3. 第一根火柴</h3>
<div class="paragraph">
<p>就像卖火柴的小女孩一样，我们的故事发生在圣诞节前。卖火柴的小女孩的任务是在圣诞节前夕销售一捆火柴棍（实际上是新年，我确实回去读了那个故事。圣诞节更适合 Perl 6），而我的任务是从 Modelica 模型中提取注释渲染为矢量图形。现在，Modelica 是一个非常棒的面向对象的建模语言，除了提及其附录中包含一个具体语法部分的非常好的<a href="https://www.modelica.org/documents/ModelicaSpec34.pdf">规范文档</a>（pdf）之外，我将完全理解它。仔细阅读本节，我意识到“语法元符号”和“词法单位”看起来像我最近读过的一篇博客文章中的 Perl 6 Grammars，并且急于尝试。</p>
</div>
<div class="paragraph">
<p>来自 Modelica 的示例具体语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">class-definition</span> :
[ <span class="tok-n">encapsulated</span> ] <span class="tok-n">class-prefixes</span>
<span class="tok-n">class-specifier</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 6 <strong>rule</strong> 的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n"> class_definition</span> {<span class="tok-sr"></span>
<span class="tok-sr">  [&lt;|w&gt;&#39;encapsulated&#39;&lt;|w&gt;]?</span>
<span class="tok-sr">  &lt;class_prefixes&gt;</span>
<span class="tok-sr">  &lt;class_specifier&gt;</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就像卖火柴的小女孩划第一颗火柴一样，第一次看到了一个超越她现实的奇妙世界。一个温暖的小炉子。然后它熄灭了。</p>
</div>
<div class="paragraph">
<p>它非常接近，我把它放到了一个文本编辑器中，并且用一些 Perl 6 的东西替换了不是 Perl 6 的部分，以查看它是否会运行。它没有运行。我砍掉了它，我指出了不同的位来解决更小的块。无处不在的空白符号，正则表达式，标记，规则。我能够解析某些部分，其他部分神秘地没有起效。回顾过去，这一定很糟糕。与此同时，我们一起破解传统的正则表达式来提取注释，并将我的 Grammar 放在架子上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第二根火柴">12.4. 第二根火柴</h3>
<div class="paragraph">
<p>不久之后，发布了 Grammar::Profiler 和 Grammar::Debugger，并且我受到启发，决定再试一试。我被授予了对我的规则出乎意料表现的很好的见解。我能够比以前更深入地理解 grammar。第二支火柴一直亮着，我有一场盛宴。然后它熄灭了。</p>
</div>
<div class="paragraph">
<p>在调试器中，我陷入了回溯的深渊。分析器一直运行，因为它一次又一次地陷入泥潭。我能够走得更远，但最终遇到了一堵墙。成功似乎非常接近，但我自己的经历中有太多缺失的部分，并且有文档让我度过难关。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第三根火柴">12.5. 第三根火柴</h3>
<div class="paragraph">
<p>时间流逝，圣诞节来了。我有了新的职位，有时间做个人项目。我有不断改进的 <a href="https://docs.perl6.org/language/grammars">Grammar 文档</a>来指导我。我已经阅读了使用遗留代码高效工作的书。这足以让我再次迎难而上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象">12.6. 面向对象</h3>
<div class="paragraph">
<p>这对我来说是最大的突破。当我从文档中了解到 Tokens，rules 和  regex 都是有趣的外观方法时，我突然发现了所有的东西。当我回到家时，我立即检查我是否可以重写 TOP，并检查是否可以将 Grammar 方法变为 role。两人都很愉快地工作，而且我在做生意。我可以把它分成块，而不是一个单一的，全有或全无的 grammar。这极大地改进了代码的组织和可测试性。</p>
</div>
<div class="paragraph">
<p>其中一个特别突出的问题是，我能够将 Grammar 整齐地分解成与 Modelica 规范中相应的角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">lib</span>
----<span class="tok-n">Grammar</span>
--------<span class="tok-n">Modelica</span>
------------<span class="tok-n">LexicalConventions</span>.<span class="tok-n">pm6</span>
------------<span class="tok-n">ClassDefinition</span>.<span class="tok-n">pm6</span>
------------<span class="tok-n">Extends</span>.<span class="tok-n">pm6</span>
------------<span class="tok-n">ComponentClause</span>.<span class="tok-n">pm6</span>
------------<span class="tok-n">Modification</span>.<span class="tok-n">pm6</span>
------------<span class="tok-n">Equations</span>.<span class="tok-n">pm6</span>
------------<span class="tok-n">Expressions</span>.<span class="tok-n">pm6</span>
--------<span class="tok-n">Modelica</span>.<span class="tok-n">pm6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Unit testing: one layer at a time</strong></p>
</div>
<div class="paragraph">
<p>面向对象开辟了一个明智的单元测试方案，并通过将Modelica的部分内容传递到语法中，使我摆脱了临时测试的无稽之谈。您可以像继承其他任何类一样继承和重写语法。这允许您分别测试每个规则或标记，将您的语法分割为一口大小的层。您只需使用要测试的规则或标记覆盖TOP，并使用占位符方法覆盖任何依赖关系。</p>
</div>
<div class="paragraph">
<p>Expressions.pm6中表达式的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n"> expression</span> {<span class="tok-sr"></span>
<span class="tok-sr">  [</span>
<span class="tok-sr">  &lt;|w&gt;&#39;if&#39;&lt;|w&gt; &lt;expression&gt; &lt;|w&gt;&#39;then&#39;&lt;|w&gt; &lt;expression&gt; [</span>
<span class="tok-sr">  &lt;|w&gt;&#39;elseif&#39;&lt;|w&gt; &lt;expression&gt; &lt;|w&gt;&#39;then&#39;&lt;|w&gt; &lt;expression&gt;</span>
<span class="tok-sr">  ]*</span>
<span class="tok-sr">  &lt;|w&gt;&#39;else&#39;&lt;|w&gt; &lt;expression&gt;</span>
<span class="tok-sr">  ]</span>
<span class="tok-sr">  ||</span>
<span class="tok-sr">  &lt;simple_expression&gt;</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们看到表达式取决于它自己和simple_expression。为了测试，我们用一个占位符替换了通常的simple_expression规则。在这种情况下，它只是匹配字符串&#8217;simple_expression'。</p>
</div>
<div class="paragraph">
<p>从Expressions.t覆盖测试语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">TestExpression</span> <span class="tok-k">is</span> <span class="tok-n">Grammar::Modelica</span> {
    <span class="tok-k">rule</span><span class="tok-n"> TOP</span> {<span class="tok-sr">^ &lt;expression&gt; $</span>}
    <span class="tok-k">rule</span><span class="tok-n"> simple_expression</span> {<span class="tok-sr"> &#39;simple_expression&#39; </span>}
}
<span class="tok-nb">ok</span> <span class="tok-n">TestExpression</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;simple_expression&#39;</span>);
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你可以分离代码中有问题的部分时，回归测试也会更加愉快，并创建一个专门针对它的重写语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_w_is_your_friend">12.7. &lt;|w&gt; is your friend</h3>
<div class="paragraph">
<p>在我的第一次努力中，试图让Modelica保留字等正常工作的东西是我“存在的一些障碍”之一。在找到单词边界匹配标记&lt;| w&gt;后，这个改变了。当我在每边击打一个时，它可以工作，无论是在空白区还是标点符号旁边。</p>
</div>
<div class="paragraph">
<p>从ComponentClause.pm6：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n"> type_prefix</span> {<span class="tok-sr"></span>
<span class="tok-sr">  [&lt;|w&gt;[ &#39;flow&#39; || &#39;stream&#39; ]&lt;|w&gt;]?</span>
<span class="tok-sr">  [&lt;|w&gt;[ &#39;discrete&#39; || &#39;parameter&#39; || &#39;constant&#39; ]&lt;|w&gt;]?</span>
<span class="tok-sr">  [&lt;|w&gt;[ &#39;input&#39; || &#39;output&#39; ]&lt;|w&gt;]?</span>
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_token_rule_and_regex">12.7.1. Token, rule and regex</h4>
<div class="paragraph">
<p>现在有很好的文档，但是我也会简要介绍一下我的经验。我发现规则和它的：sigspace魔术是大多数时候最好的选择。令牌在需要严格控制格式的情况下很有用。</p>
</div>
<div class="paragraph">
<p>正则表达式用于回溯。对于Modelica，我发现它是无益的，可能是因为它被设计成单通口语。令牌和规则在我认为我需要的地方工作。所有的单元测试都在我将它们删除后通过，并且语法成功了四个Modelica标准库文件。只有在需要时才使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_以开始结束">12.7.2. 以开始结束</h4>
<div class="paragraph">
<p>另一个让我感到沮丧的是类定义语法。 Modelica使用形式some_identifier &#8230;&#8203;结束some_identifier的类。如何确保在开始和结束时使用相同的标识符对我来说很麻烦。幸运的是，Perl 6允许您在语法方法中使用捕获。下面的（&lt;IDENT&gt;）捕获将填充$ 0，然后可以用它来确保我们的long_class_specifier以适当的标识符结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n"> long_class_specifier</span> {<span class="tok-sr"></span>
<span class="tok-sr">  [(&lt;IDENT&gt;) &lt;string_comment&gt; &lt;composition&gt; &lt;|w&gt;&#39;end&#39;&lt;|w&gt; $0 ]</span>
<span class="tok-sr">  ||</span>
<span class="tok-sr">  [&lt;|w&gt;&#39;extends&#39;&lt;|w&gt; (&lt;IDENT&gt;) &lt;class_modification&gt;? &lt;string_comment&gt; &lt;composition&gt; &lt;|w&gt;&#39;end&#39;&lt;|w&gt; $0 ]</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integration Testing: lighting all the matches at once</strong></p>
</div>
<div class="paragraph">
<p>在我的单元测试全部过去后，我感到有点不安。当然，它可以解析我设计的测试案例，但它对真正的Modelica会如何呢？颤抖的手，我从他的Modelica电子书中提供了一些Michael Tiller的示例代码。有效！没有摆弄我忽略的微妙东西，没有有趣的解析错误或永恒的回溯。只是成功。</p>
</div>
<div class="paragraph">
<p>现在，星星偶尔会对齐。奇迹确实发生。充分巧妙的单元测试可以非常好地预防错误。我已经有足够的时间来验证了。回顾Damian Conway的演讲，我决定针对整个Modelica标准库运行它。并不是所有的CPAN，但305个文件都比我迄今尝试过的仅仅两个示例模型要好。</p>
</div>
<div class="paragraph">
<p>我编写了脚本，将它指向了Modelica目录，并将它解雇了。它通过图书馆搅动，喘息一下。 150次失败。现在这是熟悉的领域。经过几次迭代后，当我在parse_modelica_library分支上运行它时，我的性能下降到了66次。我只是通过一个失败的文件，找出有问题的代码，并为其编写回归测试。</p>
</div>
<div class="paragraph">
<p>所以，最后小火柴女郎点燃了她捆绑的其余部分。然后，她死了。不要死，但可以同时点亮所有305场比赛，例如/ parseThemAll.p6：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!perl6</span>

<span class="tok-k">use</span> <span class="tok-n">v6</span>;
<span class="tok-k">use</span> <span class="tok-n">Test</span>;
<span class="tok-k">use</span> <span class="tok-n">lib</span> <span class="tok-s">&#39;../lib&#39;</span>;
<span class="tok-k">use</span> <span class="tok-n">Grammar::Modelica</span>;


<span class="tok-nb">plan</span> <span class="tok-mi">305</span>;

<span class="tok-k">sub</span> <span class="tok-n">light</span>(<span class="tok-nv">$file</span>) {
  <span class="tok-k">my</span> <span class="tok-nv">$fh</span> = <span class="tok-nb">open</span> <span class="tok-nv">$file</span>, :<span class="tok-n">r</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$contents</span> = <span class="tok-nv">$fh</span>.<span class="tok-n">slurp-rest</span>;
  <span class="tok-nv">$fh</span>.<span class="tok-nb">close</span>;

  <span class="tok-k">my</span> <span class="tok-nv">$match</span> = <span class="tok-n">Grammar::Modelica</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$contents</span>);
  <span class="tok-nb">say</span> <span class="tok-nv">$file</span>;
  <span class="tok-nb">ok</span> <span class="tok-nv">$match</span>;
}

<span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(<span class="tok-nv">$modelica-dir</span>) {
    <span class="tok-nb">say</span> <span class="tok-s">&quot;directory: $modelica-dir&quot;</span>;
    <span class="tok-k">die</span> <span class="tok-s">&quot;Can&#39;t find directory&quot;</span> <span class="tok-k">if</span> ! <span class="tok-nv">$modelica-dir</span>.<span class="tok-nb">IO</span>.<span class="tok-n">d</span>;

    <span class="tok-c1"># modified from the lovely docs at</span>
    <span class="tok-c1"># https://docs.perl6.org/routine/dir</span>
    <span class="tok-k">my</span> <span class="tok-nv">@stack</span> = <span class="tok-nv">$modelica-dir</span>.<span class="tok-nb">IO</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@files</span>;
    <span class="tok-k">while</span> <span class="tok-nv">@stack</span> {
      <span class="tok-k">for</span> <span class="tok-nv">@stack</span>.<span class="tok-nb">pop</span>.<span class="tok-n">dir</span> -&gt; <span class="tok-nv">$path</span> {
        <span class="tok-n">light</span>(<span class="tok-nv">$path</span>) <span class="tok-k">if</span> <span class="tok-nv">$path</span>.<span class="tok-n">f</span> &amp;&amp; <span class="tok-nv">$path</span>.<span class="tok-n">extension</span>.<span class="tok-nb">lc</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;mo&#39;</span>;
        <span class="tok-nv">@stack</span>.<span class="tok-n">push:</span> <span class="tok-nv">$path</span> <span class="tok-k">if</span> <span class="tok-nv">$path</span>.<span class="tok-n">d</span>;
      }
    }
    <span class="tok-c1"># faster to do in parallel</span>
    <span class="tok-nv">@files</span>.<span class="tok-n">race</span>.<span class="tok-nb">map</span>({<span class="tok-n">light</span>(<span class="tok-nv">$_</span>)});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我会看到在圣诞节前我能说服多少。那么也许我会弄清楚如何编写一些规则来构建QAST。</p>
</div>
<div class="paragraph">
<p>圣诞节快乐！</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_带有_promise_的简单网络爬虫">13. <a href="https://perl6advent.wordpress.com/2017/12/15/a-simple-web-spider-with-promises/">第十五天-带有 Promise 的简单网络爬虫</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>承诺，承诺
去年夏天，我申请了一项编程工作，面试官要求我编写一个程序来抓取给定的域，只在该域中的链接之后，找到它引用的所有页面。我被允许以任何语言编写程序，但我选择使用Go语言执行任务，因为这是该公司使用的主要语言。这对于并发编程来说是一个理想的任务，并且Go具有非常好的现代化功能，即使有些低级别的并发支持。网络蜘蛛中的主要工作是执行与在域中发现的唯一锚链接相同的次数，即在每个页面上执行HTTP GET并解析页面文本以获取新链接。这个任务可以并行安全地完成，因为没有可能（除非你做得很糟糕），任何调用爬取代码都会干扰其他任何调用。</p>
</div>
<div class="paragraph">
<p>Go和Perl 6的创造者受到安东尼霍尔爵士1978年的开创性工作“沟通顺序过程”的启发，但值得注意的是，Perl 6代码更加简洁，因此更容易隐藏到博客文章中。事实上，Go设计者总是将他们的结构称为“并发原语”。 Go为我的作业应用程序编写的并发spider代码大约有200行，而在Perl 6中大小不到这个大小的一半。</p>
</div>
<div class="paragraph">
<p>下面我们来看看如何在Perl 6中实现一个简单的Web爬虫。内置的Promise类允许您启动，调度和检查异步计算的结果。所有你需要做的就是给Promise.start方法一个代码引用，然后调用await方法，这会阻塞，直到promise完成执行。然后您可以测试结果方法以确定承诺是否已被保留或中断。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">您可以通过将其保存到本地文件中来运行本文中的代码，例如网络spider.p6。如果您希望抓取https网站，请使用zef安装HTML </dt>
<dd>
<p>Parser :: XML和HTTP :: UserAgent以及IO :: Socket :: SSL。我会提醒你，SSL支持目前看起来有点狼狈，所以最好坚持http站点。 Perl 6程序中的MAIN子程序存在时表示一个独立程序，这就是执行开始的地方。 MAIN的参数表示命令行参数。我编写了这个程序，以便默认情况下它会抓取Perlmonks站点，但是您可以覆盖它，如下所示：</p>
<div class="literalblock">
<div class="content">
<pre>$ perl6 web-spider.p6 [–domain=http://example.com]</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>简单的Perl 6域蜘蛛</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">HTML::Parser::XML</span>;
<span class="tok-k">use</span> <span class="tok-n">XML::Document</span>;
<span class="tok-k">use</span> <span class="tok-n">HTTP::UserAgent</span>;

<span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(:<span class="tok-nv">$domain</span>=<span class="tok-s">&quot;http://www.perlmonks.org&quot;</span>) {

    <span class="tok-k">my</span> <span class="tok-nv">$ua</span> =  <span class="tok-n">HTTP::UserAgent</span>.<span class="tok-nb">new</span>;
    <span class="tok-k">my</span> <span class="tok-nv">%url_seen</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@urls</span>=(<span class="tok-nv">$domain</span>);

    <span class="tok-k">loop</span> {
        <span class="tok-k">my</span> <span class="tok-nv">@promises</span>;
        <span class="tok-k">while</span> ( <span class="tok-nv">@urls</span> ) {
            <span class="tok-k">my</span> <span class="tok-nv">$url</span> = <span class="tok-nv">@urls</span>.<span class="tok-nb">shift</span>;
            <span class="tok-k">my</span> <span class="tok-nv">$p</span> = <span class="tok-n">Promise</span>.<span class="tok-n">start</span>({<span class="tok-n">crawl</span>(<span class="tok-nv">$ua</span>, <span class="tok-nv">$domain</span>, <span class="tok-nv">$url</span>)});
            <span class="tok-nv">@promises</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$p</span>);
        }
        <span class="tok-n">await</span> <span class="tok-n">Promise</span>.<span class="tok-n">allof</span>(<span class="tok-nv">@promises</span>);
        <span class="tok-k">for</span> <span class="tok-nv">@promises</span>.<span class="tok-nb">kv</span> -&gt; <span class="tok-nv">$index</span>, <span class="tok-nv">$p</span> {
            <span class="tok-k">if</span> <span class="tok-nv">$p</span>.<span class="tok-n">status</span> ~~ <span class="tok-n">Kept</span> {
                <span class="tok-k">my</span> <span class="tok-nv">@results</span> =  <span class="tok-nv">$p</span>.<span class="tok-n">result</span>;
                <span class="tok-k">for</span> <span class="tok-nv">@results</span> {
                    <span class="tok-k">unless</span> <span class="tok-nv">%url_seen</span>{<span class="tok-nv">$_</span>} {
                        <span class="tok-nv">@urls</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$_</span>);
                        <span class="tok-nv">%url_seen</span>{<span class="tok-nv">$_</span>}++;
                    }
                }
            }
        }
        <span class="tok-c1"># Terminate if no more URLs to crawl</span>
        <span class="tok-k">if</span> <span class="tok-nv">@urls</span>.<span class="tok-nb">elems</span> == <span class="tok-mi">0</span> {
            <span class="tok-k">last</span>;
        }
    }
    <span class="tok-nb">say</span> <span class="tok-nv">%url_seen</span>.<span class="tok-nb">keys</span>;
}

<span class="tok-c1"># Get page and identify urls linked to in it. Return urls.</span>
<span class="tok-k">sub</span> <span class="tok-n">crawl</span>(<span class="tok-nv">$ua</span>, <span class="tok-nv">$domain</span>, <span class="tok-nv">$url</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$page</span> = <span class="tok-nv">$ua</span>.<span class="tok-n">get</span>(<span class="tok-nv">$url</span>);
    <span class="tok-k">my</span> <span class="tok-nv">$p</span> = <span class="tok-n">HTML::Parser::XML</span>.<span class="tok-nb">new</span>;
    <span class="tok-k">my</span> <span class="tok-n">XML::Document</span> <span class="tok-nv">$doc</span> = <span class="tok-nv">$p</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$page</span>.<span class="tok-n">content</span>);
    <span class="tok-c1"># URLs to crawl</span>
    <span class="tok-k">my</span> <span class="tok-nv">%todo</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@anchors</span> = <span class="tok-nv">$doc</span>.<span class="tok-n">elements</span>(:<span class="tok-n">TAG</span><span class="tok-s">&lt;a&gt;, :RECURSE);</span>
<span class="tok-s">    for @anchors -&gt;</span> <span class="tok-nv">$anchor</span> {
        <span class="tok-k">next</span> <span class="tok-k">unless</span> <span class="tok-nv">$anchor</span>.<span class="tok-nb">defined</span>;
        <span class="tok-k">my</span> <span class="tok-nv">$href</span> =  <span class="tok-nv">$anchor</span>.<span class="tok-n">attribs</span><span class="tok-s">&lt;href&gt;</span>;

        <span class="tok-c1"># Convert relative to absolute urls</span>
        <span class="tok-k">if</span> <span class="tok-nv">$href</span>.<span class="tok-n">starts-with</span>(<span class="tok-s">&#39;/&#39;</span>) <span class="tok-o">or</span> <span class="tok-nv">$href</span>.<span class="tok-n">starts-with</span>(<span class="tok-s">&#39;?&#39;</span>) {
            <span class="tok-nv">$href</span> = <span class="tok-nv">$domain</span> ~ <span class="tok-nv">$href</span>;
        }

        <span class="tok-c1"># Get unique urls from page</span>
        <span class="tok-k">if</span> <span class="tok-nv">$href</span>.<span class="tok-n">starts-with</span>(<span class="tok-nv">$domain</span>) {
              <span class="tok-nv">%todo</span>{<span class="tok-nv">$href</span>}++;
        }
    }
    <span class="tok-k">my</span> <span class="tok-nv">@urls</span> = <span class="tok-nv">%todo</span>.<span class="tok-nb">keys</span>;

    <span class="tok-k">return</span> <span class="tok-nv">@urls</span>;
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_结论是">13.1. 结论是</h3>
<div class="paragraph">
<p>并发编程总是会有很多陷阱，从竞争状态到资源匮乏和死锁，但我认为很显然，Perl 6 已经使得这种编程形式更容易被大家接受。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_perl_6_性能改进">14. <a href="https://perl6advent.wordpress.com/2017/12/16/day-16-%F0%9F%8E%B6-deck-the-halls-with-perf-improvements-%F0%9F%8E%B6/">第十六天-Perl 6 性能改进</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在英国，我们缺乏感恩节给圣诞节带来了新的一年，感谢和反思。为此，我想围绕Perl 6性能的状态放置一些我已经坐了一段时间的零碎片断，这些片断强调了这个过程需要付出多少努力。我不确定更广泛的编程社区对正在发生的努力的速度和数量表示赞赏。</p>
</div>
<div class="paragraph">
<p>我不是核心开发人员，但自2010年推出Rakudo *之后，我一直是Perl 6的低级用户。通常情况下，已经进入Rakudo的努力被未知的努力所掩盖。人们重新审视Rakudo Perl 6时尤其如此，他可能会想象下一个圣诞节将会如何。但是Perl 6在历史上证明，在下一个圣诞节之前，事情总会有所改善，无论您选择哪个圣诞节，</p>
</div>
<div class="paragraph">
<p>回到2014年的圣诞节，我写了一篇关于为什么我认为Perl 6能够完成生物信息学工作的出色文章。那篇文章中没有提到的是，为什么在Rakudo上实现Perl 6根本没有准备好去做任何严肃的生物信息学。表演真的没有！我在Perl 6中的第一次尝试（当Parrot虚拟机完全使用时）让我执行了几十分钟的简单操作，我期望它是毫秒级的性能。这很遗憾，因为我没有跟踪时间。但这当然不是一个好起点。</p>
</div>
<div class="paragraph">
<p>然而，快速转发到2014年和MoarVM，我觉得自己写这篇来临邮件感觉很舒服，因为我知道在作为用户的4年中有多少改进。而且，所有的发展都是在完成语言定义和正确的实施。然而，我是一直在等待perf到达那里的用户。我认为大部分时间到了。为此，我要感谢所有核心开发者所付出的巨大的日常努力。观看它展现出令人难以置信的动力。对我来说，这个圣诞节是圣诞节的目标，它已经到来。 👏🏻🎊</p>
</div>
<div class="paragraph">
<p>我一直在为我的BioInfo模块运行和计时测试，这些模块对生物序列数据进行了多年的基本操作。它以非常糟糕的方式做到了这一点。在紧密循环中分配和丢弃哈希时出现了很多错误等等。但是我已经将这些代码留给了现在 - 在五年多的时间里。悄悄地进行私人基准测试，偶尔鼓励在IRC频道看到大幅飞跃的努力。 Sub 10s是一个很大的！它从30/40秒突然发生。在我暗示IRC一个地方，我的代码在分析时特别慢，这是一次跳跃！</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/bioinfo_runtime.png">img</a></p>
</div>
<div class="paragraph">
<p>这是一个长期观点，如果我放大去年的这一年，可以看到，如果时间不是很长，整个系数的性能仍然在提高。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/bioinfo_runtime_2017.png">img</a></p>
</div>
<div class="paragraph">
<p>请记住，所有这些配置文件都不是来自Rakudo编译器的发布版本，而是来自当天的HEAD。所以偶尔会有一些奇怪的表现回归，正如你上面看到的，通常不会留下来发布。</p>
</div>
<div class="paragraph">
<p>发生什么了？情况如何变好？有几个原因。 Perl 6中的许多算法选择和核心功能都已经在源代码级别（更晚些时候）逐步和积极地进行了优化。但支持Rakudo的MoarVM虚拟机的优化能力也得到了提高，并且可以降低到原生代码和内联专用版本的代码。这部分得益于2014年以来Rakudo Perl 6提供的-profile选项，它提供了所有这些信息。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/bioinfo_frame_optimisations.png">img</a></p>
</div>
<div class="paragraph">
<p>在上面关于MoarVM如何处理我编译过的Perl 6测试的代码框的情节中，应该很清楚的是，自从今年夏天以来，有相当多的框架被JIT编译，解释较少，并且几乎所有专用框架（橙色）结束原生JIT（绿色）。如果您想了解更多有关“spesh”MoarVM代码专门工具的最新工作，您可以在他的博客上阅读Jonathan Worthington的4篇文章。 Baart Weigmans还有一篇博客概述了他在JIT编译器方面的工作，最近还谈到了许多尚未登陆的新功能，希望能让许多新开发人员加入并帮助改进JIT。所以如果这对你来说是一件有趣的事情，我建议你查看一下上面的链接。</p>
</div>
<div class="paragraph">
<p>所以这是我的基准和我的目标，其中大部分是围绕数据结构创建和解析。但是，数字作品等其他内容呢？那也保持了吗？没有任何人推动，就像我推动我对事情可以改进的地方的看法。答案是肯定的！</p>
</div>
<div class="paragraph">
<p>曾几何时，早在2013年，一位名叫Tim King的绅士就开始对Perl 6中的素数感兴趣.Tim对他发现的性能颇为不满。正确如此。他从以下漂亮的代码开始：</p>
</div>
<div class="paragraph">
<p>通过定义一个素数的交叉点找到任何素数，真是一个不错的优雅解决方案！但是蒂姆惊讶地发现联赛很慢，上面的代码让他看到了前1000个素数。今天，超级高级代码需要0.96s。</p>
</div>
<div class="paragraph">
<p>对于基于联结的代码的缓慢程度，蒂姆继续做更标准的迭代方法感到不满。 Tim在这些帖子后不久就从网上消失。但他留下了我继续留下的遗产。他的主要基准测试代码和我对时间结果的适应性可以在这个要点中找到。以下是另一张图表，其中显示了每个超过100次试验找到前1000个素数所需的平均时间。 2015年的垂直线是较高的标准偏差。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/timking_primes.png">img</a></p>
</div>
<div class="paragraph">
<p>再次以最近的放大视图（最新的数据点让我担心一点，我以某种方式搞砸了&#8230;&#8203;&#8230;&#8203;）</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/timking_primes_2017_improvement.png">img</a></p>
</div>
<div class="paragraph">
<p>上面的收敛到一个点，是启动和停止Rakudo运行时和MoarVM的开销。发现素数并不是它曾经的努力，它比Rakudo的开始稍微慢一些。无论您选择的代码解决方案的级别和优雅程度如何，至少要快一个数量级。</p>
</div>
<div class="paragraph">
<p>好吧，我们已经看到MoarVM获得了一些闪亮的新运动部件。但是像Liz，jnthn，Zoffix以及最近在字符串Samcv世界中开发人员已经付出了巨大的努力，以改进MoarVM和Rakudo在算法上实际上正在做的事情。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>旁注：我相信我根本不会做大多数其他开发人员的正义，特别是在这篇文章中忽略了JVM的努力。我建议每个人都去，并检查提交日志，看看有多少人现在参与使Rakudo更快，更好，更强大。我确定他们想在本文的底部看到您的感谢！</pre>
</div>
</div>
<div class="paragraph">
<p>因此，节省你一份查看提交日志的工作我已经做了一些挖掘，看看自上个圣诞节以来与提高性能有关的提交。 N％或Nx更快的东西。如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>3c6277c77 Have .codes use nqp::codes op. 350% faster for short strings</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ee4593601 Make Baggy (^) Baggy about 150x faster</pre>
</div>
</div>
<div class="paragraph">
<p>这两项承诺将以一年的核心发展时间表推动编程项目的发展。但是，今年，它们仅仅是数百次提交中的两次。</p>
</div>
<div class="paragraph">
<p>下面是一些提交数量的直方图以及他们提到的性能的百分比和x乘数的增加。你可以用上面的代码自己grep日志。在2016年有一些更令人兴奋的收益值得检查。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/percent_improvements_since_xmas2016.png">img</a></p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/x_improvements_since_xmas2016.png">img</a></p>
</div>
<div class="paragraph">
<p>这仅仅是2017年的性能提升承诺，几乎每天都会有更多的降落。这甚至不包括许多来自Zoffix授予的I / O性能收益，因为它们在之前/之后并不总是基准。 2016年同样密集，一些疯狂的&gt; 1000倍的改进。今年只有十个左右提交，提高40倍！看到这真是令人印象深刻。至少对我来说。我认为这对项目的许多人来说并不明显，他们正在完成多少。记住这些是单数提交。有些甚至在一年中复合改进！</p>
</div>
<div class="paragraph">
<p>我会把它留在这里。但是真的很感谢核心开发者，你们所有人。这是一个很棒的观看和等待体验。但现在是时候在2018年继续使用一些Perl 6代码了！终于圣诞节了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十七天_关于消息传递">15. <a href="https://perl6advent.wordpress.com/2017/12/17/something-about-messaging-but-i-couldnt-think-of-a-snappier-title/">第十七天-关于消息传递</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_为什么要传递消息">15.1. 为什么要传递消息</h3>
<div class="paragraph">
<p>当我第一次开始考虑写今年的 Advent 文章时，我反思我在过去的十二个月里并没有真正写过大量的 Perl 6，与往年相比，我似乎写了大量的模块。我一直在做的事情（至少在我的日常工作中）正在考虑和实施大量使用某些消息传递系统的应用程序。所以我认为将这些想法引入 Perl 6 会很有趣。</p>
</div>
<div class="paragraph">
<p>作为一种“胶水语言”，Perl一直享有盛誉，Perl 6 具有与之竞争的功能，最显着的是响应式和并发功能，因此非常适合创建基于消息的集成服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_传递什么信息">15.2. 传递什么信息</h3>
<div class="paragraph">
<p>现在我的脚下就是优秀的<a href="http://www.enterpriseintegrationpatterns.com/">企业集成模式</a>，尽管它现在已经有近15年的历史了，但我仍然建议任何有兴趣（或工作于）该领域的人。然而，它是一个重量级的书（字面上，它在硬书中的重量接近一点五公斤），所以我用它来提醒自己不要试图在这个主题上详尽无遗，以免这会变成一本书本身。</p>
</div>
<div class="paragraph">
<p>有相当多的自由和商业管理消息系统，使用一系列开放和专有的协议，但我将限制自己到我熟悉的 <a href="https://www.rabbitmq.com/">RabbitMQ</a>，并且在 Perl 6 中由 <a href="https://github.com/retupmoca/P6-Net-AMQP">Net::AMQP</a> 支持。</p>
</div>
<div class="paragraph">
<p>如果你想亲自尝试一下这些例子，你将需要访问一个 RabbitMQ 代理（它可以作为大多数操作系统发行版的包），但是你可以使用 <a href="https://hub.docker.com/_/rabbitmq/">Docker Image</a>，它看起来工作得很好。</p>
</div>
<div class="paragraph">
<p>您还需要安装 Net::AMQP，这可以通过以下方式完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Net::AMQP</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在示例中，我将使用 RabbitMQ 服务器的默认连接详细信息（即代理正在本地主机上运行，​​并且默认 <code>guest</code> 处于活动状态），如果您需要提供不同的详细信息，则可以更改 Net::AMQP 的构造函数以反映适当的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>(
  <span class="tok-n">host</span> =&gt; <span class="tok-s">&#39;localhost&#39;</span>,
  <span class="tok-n">port</span> =&gt; <span class="tok-mi">5672</span>,
  <span class="tok-n">login</span> =&gt; <span class="tok-s">&#39;guest&#39;</span>,
  <span class="tok-n">password</span> =&gt; <span class="tok-s">&#39;guest&#39;</span>,
  <span class="tok-n">vhost</span> =&gt; <span class="tok-s">&#39;/&#39;</span>
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些示例可能需要其他模块，但我会在介绍时介绍它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_强制性的你好世界">15.3. 强制性的你好，世界</h3>
<div class="paragraph">
<p>RabbitMQ实现了由AMQP v0.9规范描述的丰富的代理体系结构，由ActiveMQ实现的最新的v1.0规范取消了大部分规定的代理语义，以至于它基本上是一种不同的协议，它共享一个类似的电线格式。</p>
</div>
<div class="paragraph">
<p>发送消息（生产者）的最简单可能的例子可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;

<span class="tok-n">await</span> <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>;
<span class="tok-k">my</span> <span class="tok-nv">$channel</span> = <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>).<span class="tok-n">result</span>;
<span class="tok-k">my</span> <span class="tok-nv">$exchange</span> = <span class="tok-nv">$channel</span>.<span class="tok-n">exchange</span>.<span class="tok-n">result</span>;
<span class="tok-nv">$exchange</span>.<span class="tok-n">publish</span>(<span class="tok-n">routing-key</span> =&gt; <span class="tok-s">&quot;hello&quot;</span>, <span class="tok-nb">body</span> =&gt; <span class="tok-s">&quot;Hello, World&quot;</span>.<span class="tok-n">encode</span>);
<span class="tok-n">await</span> <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这演示了RabbitMQ和Net </dt>
<dd>
<p>AMQP的大部分核心功能。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>首先你会注意到许多方法返回一个Promise，它将大部分保留在实际的返回值中，这反映了代理的异步性质，它发送（大多数情况但不是全部）确认消息（AMQP说法中的方法，）当操作在服务器上完成时。</p>
</div>
<div class="paragraph">
<p>这里的连接建立到代理的网络连接并且协商某些参数，如果网络连接失败，提供的凭证不正确或者服务器拒绝某个其他连接，则返回一个Promise，如果成功或失败，它将保留一个真值原因。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">开放通道打开一个逻辑代理通信通道，在这个通道中交换消息，您可以在应用程序中使用多个通道。当服务器确认后，返回的Promise将保留在初始化的Net </dt>
<dd>
<p>AMQP :: Channel对象中。</p>
</dd>
<dt class="hdlist1">通道对象上的交换方法返回一个Net </dt>
<dd>
<p>AMQP :: Exchange对象，在AMQP模型中，所有消息都发布到交换机上，根据交换机的定义，代理可以将消息路由到一个或多个队列由此消息可能被另一客户消耗。在这个简单的例子中，我们将使用默认交换（名为amq.default。）</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>发布方法是在交换对象上调用的，它没有返回值，因为它只是简单的触发和遗忘，代理不会确认收到和交付，否则队列与发布消息的行为是分离的。顾名思义，路由密钥参数是由代理用来确定将消息路由到哪个队列（或多个队列）。在这个例子中使用默认交换的情况下，交换的类型是直接的，这基本上意味着消息传递到具有与路由密钥匹配的名称的队列中的一个消费者。正文总是一个Buf，并且可以是任意长度，在这种情况下，我们使用的是编码字符串，但它可以同样编码为JSON，MessagePack或BSON blob，无论适合消费应用程序。事实上可以提供内容类型和内容编码参数，如果应用程序的设计需要它，消息将传递给消费者，但代理本身完全不知道有效内容的内容。还有其他可选参数，但在这个例子中不需要。</p>
</div>
<div class="paragraph">
<p>当然，我们也需要阅读我们发布的消息（消费者）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;

<span class="tok-k">my</span> <span class="tok-nv">$connection</span> = <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>.<span class="tok-n">result</span>;

<span class="tok-n">react</span> {
    <span class="tok-n">whenever</span> <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>) -&gt; <span class="tok-nv">$channel</span> {
        <span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">declare-queue</span>(<span class="tok-s">&quot;hello&quot;</span>) -&gt; <span class="tok-nv">$queue</span> {
            <span class="tok-nv">$queue</span>.<span class="tok-n">consume</span>;
            <span class="tok-n">whenever</span> <span class="tok-nv">$queue</span>.<span class="tok-n">message-supply</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$v</span> { <span class="tok-nv">$v</span>.<span class="tok-nb">body</span>.<span class="tok-n">decode</span> }) -&gt; <span class="tok-nv">$message</span> {
                <span class="tok-nb">say</span> <span class="tok-nv">$message</span>;
                <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);
                <span class="tok-n">done</span>();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用的是一个命名队列，而不是像我们在制作人那样在交易所进行操作;如果队列尚不存在，declare-queue将导致队列被创建，并且代理默认将该队列绑定到默认交换，“绑定”实质上意味着发送到交换的消息可以被路由到队列取决于交换类型，消息的路由键以及可能来自消息的其他元数据。在这种情况下，默认交换的“直接”类型将导致消息被路由到与路由密钥相匹配的队列（如果存在的话，如果消息不存在，消息将被无声地丢弃）。</p>
</div>
<div class="paragraph">
<p>当您准备好开始接收消息时调用消费方法，它将返回一个Promise，该Promise将与“消费者标签”一起保存，该标签将消费者唯一标识给服务器，但由于我们不需要它，因此我们可以忽略它。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">一旦我们调用了消费（并且代理发送了确认），那么路由到我们队列的消息将作为Net </dt>
<dd>
<p>AMQP :: Queue :: Message对象发送到由消息供应返回的Supply，但是因为我们对这个例子中的消息元数据不感兴趣映射被用来创建具有消息的解码体的新的Supply;这是安全的，因为在这种情况下，您可以保证您将接收utf-8编码，但是在真实世界的应用程序中，如果您不控制发送者，您可能希望在处理身体方面更强壮一些（当与第三方应用程序集成时通常是这种情况）。发布消息时提供的内容类型和内容编码在Message对象的headers属性（一个Hash）中可用，但它们不是必需的因此您可能需要考虑适合您的应用的替代方案。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在这个例子中，连接被关闭，并且在接收到第一条消息之后退出响应，但实际上您可能需要删除这些行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);
<span class="tok-n">done</span>();</code></pre>
</div>
</div>
<div class="paragraph">
<p>从内到外，如果你想退出一个信号例如添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) {
    <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);
    <span class="tok-n">done</span>();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在反应区的最高层。但是，如果您选择退出程序，则应始终在连接对象上调用close，因为这会在代理日志中引发警告消息，如果不这样做，可能会使管理服务器的人感到不安。</p>
</div>
<div class="paragraph">
<p>我们当然可以用类似的方式在生产者示例中使用反应语法，但是它会增加冗长的好处，但是在一个更大的程序中，例如，您可能正在处理一个Supply，它可以很好地工作很好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">my</span> <span class="tok-nv">$supply</span> = <span class="tok-n">Supply</span>.<span class="tok-n">from-list</span>(<span class="tok-s">&quot;Hello, World&quot;</span>, <span class="tok-s">&quot;Bonjour le monde&quot;</span>, <span class="tok-s">&quot;Hola Mundo&quot;</span>);
<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;

<span class="tok-n">react</span> {
    <span class="tok-n">whenever</span> <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span> {
        <span class="tok-n">whenever</span> <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>) -&gt; <span class="tok-nv">$channel</span> {
            <span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">exchange</span> -&gt; <span class="tok-nv">$exchange</span> {
                <span class="tok-n">whenever</span> <span class="tok-nv">$supply</span>.<span class="tok-nb">map</span>(-&gt; <span class="tok-nv">$v</span> { <span class="tok-nv">$v</span>.<span class="tok-n">encode</span> }) -&gt; <span class="tok-nv">$body</span> {
                    <span class="tok-nv">$exchange</span>.<span class="tok-n">publish</span>(<span class="tok-n">routing-key</span> =&gt; <span class="tok-s">&quot;hello&quot;</span>, :<span class="tok-nv">$body</span> );
                    <span class="tok-k">LAST</span> {
                        <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);
                        <span class="tok-n">done</span>();
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一些更有用的东西">15.4. 一些更有用的东西</h3>
<div class="paragraph">
<p>你可能会认为“这一切都很好，但这不是我不能做的事情，比如说，一个HTTP客户端和一个小型Web服务器”，好吧，你得到可靠的排队，未读消息的持久性等等，但是，对于简单的应用程序来说，它可能会被过度杀死，直到您添加了将消息发送给多个可能未知的消费者的需求为止。这种模式是使用“扇出”交换类型，它将向绑定到交换的所有队列传递消息。</p>
</div>
<div class="paragraph">
<p>在这个例子中，我们需要声明自己的队列，以便我们可以指定类型，但是生产者不会变得更加复杂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;
<span class="tok-k">my</span> <span class="tok-nv">$con</span> =  <span class="tok-n">await</span> <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>;
<span class="tok-k">my</span> <span class="tok-nv">$channel</span> = <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>).<span class="tok-n">result</span>;
<span class="tok-k">my</span> <span class="tok-nv">$exchange</span> = <span class="tok-nv">$channel</span>.<span class="tok-n">declare-exchange</span>(<span class="tok-s">&#39;logs&#39;</span>, <span class="tok-s">&#39;fanout&#39;</span>).<span class="tok-n">result</span>;
<span class="tok-nv">$exchange</span>.<span class="tok-n">publish</span>(<span class="tok-nb">body</span> =&gt; <span class="tok-s">&#39;Hello, World&#39;</span>.<span class="tok-n">encode</span>);
<span class="tok-n">await</span> <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里唯一的区别是我们使用声明交换而不是在通道上交换来获得我们发送消息的交换，这样做的好处是使交换在指定类型的代理上创建已经存在，这在这里很有用，因为我们不需要依赖事先创建的交换（使用命令行工具rabbitmqctl或通过web管理界面），但它同样返回一个Promise，它将与Exchange交换目的。您可能还注意到，这里的路由密钥没有被传递给发布方法，这是因为对于扇出交换，路由密钥被忽略，并且消息被传递到绑定到交换机的所有消耗队列。</p>
</div>
<div class="paragraph">
<p>消费者代码与我们的原始消费者同样不存在差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;

<span class="tok-k">my</span> <span class="tok-nv">$connection</span> = <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>.<span class="tok-n">result</span>;

<span class="tok-n">react</span> {
    <span class="tok-n">whenever</span> <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>) -&gt; <span class="tok-nv">$channel</span> {
        <span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">declare-exchange</span>(<span class="tok-s">&#39;logs&#39;</span>, <span class="tok-s">&#39;fanout&#39;</span>) -&gt; <span class="tok-nv">$exchange</span> {
            <span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">declare-queue</span>() -&gt; <span class="tok-nv">$queue</span> {
                <span class="tok-n">whenever</span> <span class="tok-nv">$queue</span>.<span class="tok-n">bind</span>(<span class="tok-s">&#39;logs&#39;</span>) {
                    <span class="tok-nv">$queue</span>.<span class="tok-n">consume</span>;
                    <span class="tok-n">whenever</span> <span class="tok-nv">$queue</span>.<span class="tok-n">message-supply</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$v</span> { <span class="tok-nv">$v</span>.<span class="tok-nb">body</span>.<span class="tok-n">decode</span> }) -&gt; <span class="tok-nv">$message</span> {
                        <span class="tok-nb">say</span> <span class="tok-vg">$*PID</span> ~ <span class="tok-s">&quot; : &quot;</span> ~ <span class="tok-nv">$message</span>;
                    }
                }
                <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) {
                    <span class="tok-nb">say</span> <span class="tok-vg">$*PID</span> ~ <span class="tok-s">&quot; exiting&quot;</span>;
                    <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);
                    <span class="tok-n">done</span>();
                }

            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>交换的声明与生产者示例中声明的方式相同，这非常方便，因此您不必担心启动程序的顺序，第一次运行将创建队列，但是如果您在消费者启动之前运行生产者，发送的消息将被丢弃，因为默认情况下没有路由它们。这里我们还声明了一个没有提供名称的队列，这会创建一个“匿名”队列（该名称由代理组成），因为队列的名称在此路由消息中不起作用案件。</p>
</div>
<div class="paragraph">
<p>您可以提供一个队列名称，但如果名称重复，那么这些消息将以“先到先得”的方式路由到具有相同名称的队列，这可能不是预期的行为（尽管可能并可能有用。）</p>
</div>
<div class="paragraph">
<p>同样在这种情况下，队列必须明确地绑定到我们已经声明的交易所，在第一个例子中，默认交易所的绑定是由代理自动执行的，但在大多数情况下，您将不得不在队列上使用绑定交易所的名称。与许多方法一样，绑定返回一个Promise，当代理确认操作已完成时将保留Promise（尽管在这种情况下，值不重要）。</p>
</div>
<div class="paragraph">
<p>您应该能够根据需要启动尽可能多的消费者，并且他们都将按照发送的顺序接收所有消息。当然，在真实世界的应用程序中，消费者可能是用各种不同语言编写的完全不同的程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_保持主题">15.5. 保持主题</h3>
<div class="paragraph">
<p>一种常见模式是一组消费者，他们只对发布到特定交易所的某些消息感兴趣，其典型例子可能是记录系统，其中有专门针对不同日志级别的消费者。 AMQP提供了一种话题交换类型，允许通过生产者提供的路由密钥上的模式匹配将消息路由到特定的队列。</p>
</div>
<div class="paragraph">
<p>最简单的生产者可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(<span class="tok-nb">Str</span> <span class="tok-nv">$message</span> = <span class="tok-s">&#39;Hello, World&#39;</span>, <span class="tok-nb">Str</span> <span class="tok-nv">$level</span> = <span class="tok-s">&#39;application.info&#39;</span>) {
	<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;
	<span class="tok-k">my</span> <span class="tok-nv">$con</span> =  <span class="tok-n">await</span> <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>;
	<span class="tok-k">my</span> <span class="tok-nv">$channel</span> = <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>).<span class="tok-n">result</span>;
	<span class="tok-k">my</span> <span class="tok-nv">$exchange</span> = <span class="tok-nv">$channel</span>.<span class="tok-n">declare-exchange</span>(<span class="tok-s">&#39;topic-logs&#39;</span>, <span class="tok-s">&#39;topic&#39;</span>).<span class="tok-n">result</span>;
	<span class="tok-nv">$exchange</span>.<span class="tok-n">publish</span>(<span class="tok-n">routing-key</span> =&gt; <span class="tok-nv">$level</span>, <span class="tok-nb">body</span> =&gt; <span class="tok-nv">$message</span>.<span class="tok-n">encode</span>);
	<span class="tok-n">await</span> <span class="tok-nv">$n</span>.<span class="tok-nb">close</span>(<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;&quot;</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该从前面的例子中相当清楚，除了在这种情况下，我们将交换声明为主题类型，并且还提供将由代理用于匹配消费队列的路由密钥。</p>
</div>
<div class="paragraph">
<p>消费者代码本身又与前面的例子非常相似，只不过它会在命令行上列出一些用于匹配发送到交换机的路由密钥的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(*<span class="tok-nv">@topics</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>(:<span class="tok-n">debug</span>);
    <span class="tok-k">unless</span> <span class="tok-nv">@topics</span>.<span class="tok-nb">elems</span> {
        <span class="tok-nb">say</span> <span class="tok-s">&quot;will be displaying all the messages&quot;</span>;
        <span class="tok-nv">@topics</span>.<span class="tok-n">push:</span> <span class="tok-s">&#39;#&#39;</span>;
    }
    <span class="tok-k">my</span> <span class="tok-nv">$connection</span> = <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>.<span class="tok-n">result</span>;
    <span class="tok-n">react</span> {
        <span class="tok-n">whenever</span> <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>) -&gt; <span class="tok-nv">$channel</span> {
            <span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">declare-exchange</span>(<span class="tok-s">&#39;topic-logs&#39;</span>, <span class="tok-s">&#39;topic&#39;</span>) -&gt; <span class="tok-nv">$exchange</span> {
                <span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">declare-queue</span>() -&gt; <span class="tok-nv">$queue</span> {
                    <span class="tok-k">for</span> <span class="tok-nv">@topics</span> -&gt; <span class="tok-nv">$topic</span> {
                        <span class="tok-n">await</span> <span class="tok-nv">$queue</span>.<span class="tok-n">bind</span>(<span class="tok-s">&#39;topic-logs&#39;</span>, <span class="tok-nv">$topic</span>);
                    }
                    <span class="tok-nv">$queue</span>.<span class="tok-n">consume</span>;
                    <span class="tok-k">my</span> <span class="tok-nv">$body-supply</span> = <span class="tok-nv">$queue</span>.<span class="tok-n">message-supply</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$v</span> { [ <span class="tok-nv">$v</span>.<span class="tok-n">routing-key</span>, <span class="tok-nv">$v</span>.<span class="tok-nb">body</span>.<span class="tok-n">decode</span> ] }).<span class="tok-n">share</span>;
                    <span class="tok-n">whenever</span> <span class="tok-nv">$body-supply</span> -&gt; ( <span class="tok-nv">$topic</span> , <span class="tok-nv">$message</span> ) {
                            <span class="tok-nb">say</span> <span class="tok-vg">$*PID</span> ~ <span class="tok-s">&quot; : [$topic]  $message&quot;</span>;
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里基本上与前面的消费者示例的唯一区别是（除了提供给交换声明的类型）该主题提供给绑定方法。该主题可以是一个简单模式，其中＃将匹配任何提供的路由密钥，并且行为将与扇出交换相同，否则*可以在绑定主题的任何部分用作通配符，以匹配任何字符在这个例子中，在这个例子中，应用程序*将匹配使用路由关键字application.info或application.debug发送的消息。</p>
</div>
<div class="paragraph">
<p>如果有多于一个队列使用相同的模式绑定，则它们的行为也会像绑定到扇出交换机一样。如果绑定模式既不包含哈希也不包含星号字符，那么队列的行为就好像它被绑定到一个直接交换的那个名称的队列一样（也就是说它将有先到先服务基础。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_但是生命比amqp更重要">15.6. 但是，生命比AMQP更重要</h3>
<div class="paragraph">
<p>当然。 Perl 6反应模型的优点在于可以将上面提到的供应商提供的各种源集成到您的生产者代码中，并且类似地，消费者可以将消息推送到另一个传输机制。</p>
</div>
<div class="paragraph">
<p>我很高兴地发现，当我想到这个例子的时候，下面的工作是正常的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">EventSource::Server</span>;
<span class="tok-k">use</span> <span class="tok-n">Net::AMQP</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Router</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Server</span>;

<span class="tok-k">my</span> <span class="tok-nv">$supply</span> = <span class="tok-n">supply</span> {
	<span class="tok-k">my</span> <span class="tok-nv">$n</span> = <span class="tok-n">Net::AMQP</span>.<span class="tok-nb">new</span>;
	<span class="tok-k">my</span> <span class="tok-nv">$connection</span> = <span class="tok-nv">$n</span>.<span class="tok-nb">connect</span>.<span class="tok-n">result</span>;
	<span class="tok-n">whenever</span> <span class="tok-nv">$n</span>.<span class="tok-n">open-channel</span>(<span class="tok-mi">1</span>) -&gt; <span class="tok-nv">$channel</span> {
		<span class="tok-n">whenever</span> <span class="tok-nv">$channel</span>.<span class="tok-n">declare-queue</span>(<span class="tok-s">&quot;hello&quot;</span>) -&gt; <span class="tok-nv">$queue</span> {
			<span class="tok-nv">$queue</span>.<span class="tok-n">consume</span>;
			<span class="tok-n">whenever</span> <span class="tok-nv">$queue</span>.<span class="tok-n">message-supply</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$v</span> { <span class="tok-nv">$v</span>.<span class="tok-nb">body</span>.<span class="tok-n">decode</span> }) -&gt; <span class="tok-nv">$data</span> {
				<span class="tok-n">emit</span> <span class="tok-n">EventSource::Server::Event</span>.<span class="tok-nb">new</span>(<span class="tok-n">type</span> =&gt; <span class="tok-s">&#39;hello&#39;</span>, :<span class="tok-nv">$data</span>);
			}
		}
	}
};

<span class="tok-k">my</span> <span class="tok-nv">$es</span> = <span class="tok-n">EventSource::Server</span>.<span class="tok-nb">new</span>(:<span class="tok-nv">$supply</span>);

<span class="tok-k">my</span> <span class="tok-nv">$application</span> = <span class="tok-n">route</span> {
	<span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;greet&#39;</span>, <span class="tok-nv">$name</span> {
		<span class="tok-n">content</span> <span class="tok-s">&#39;text/event-stream; charset=utf-8&#39;</span>, <span class="tok-nv">$es</span>.<span class="tok-n">out-supply</span>;
	}
}
<span class="tok-k">my</span> <span class="tok-n">Cro::Service</span> <span class="tok-nv">$hello</span> = <span class="tok-n">Cro::HTTP::Server</span>.<span class="tok-n">new:</span>
	:<span class="tok-n">host</span>, :<span class="tok-n">port</span>, :<span class="tok-nv">$application</span>;
<span class="tok-nv">$hello</span>.<span class="tok-n">start</span>;

<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) { <span class="tok-nv">$hello</span>.<span class="tok-n">stop</span>; <span class="tok-k">exit</span>; }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这是EventSource </dt>
<dd>
<p>Server中的示例的变体，您当然可以修改它以使用上面讨论的任何交换类型。它应该适用于第一个例子中的生产者代码。而且（如果你是这么说服的话），你可以用一小段node.js代码（或者在一些面向浏览器的javascript中）来消费事件：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>	<span class="tok-n">var</span> <span class="tok-n">EventSource</span> = <span class="tok-k">require</span>(<span class="tok-s">&#39;eventsource&#39;</span>);

	<span class="tok-n">var</span> <span class="tok-n">event</span> = <span class="tok-n">process</span>.<span class="tok-n">argv</span>[<span class="tok-mi">2</span>] || <span class="tok-s">&#39;message&#39;</span>;

	<span class="tok-n">console</span>.<span class="tok-n">info</span>(<span class="tok-n">event</span>);
	<span class="tok-n">var</span> <span class="tok-n">v</span> = <span class="tok-nb">new</span> <span class="tok-n">EventSource</span>(<span class="tok-s">&#39; http://127.0.0.1:10000&#39;</span>);

	<span class="tok-n">v</span>.<span class="tok-n">addEventListener</span>(<span class="tok-n">event</span>, <span class="tok-n">function</span>(<span class="tok-nb">e</span>) {
		<span class="tok-n">console</span>.<span class="tok-n">info</span>(<span class="tok-nb">e</span>);

	}, <span class="tok-n">false</span>);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_把它包起来">15.7. 把它包起来</h3>
<div class="paragraph">
<p>在输入第一段之后，我总结道，在一篇短文中，我永远无法做到这个主题正义，所以我希望你认为这是一个开胃菜，我不认为我会永远找到时间来写书，它可能值得。但是我确实有基于 <a href="https://github.com/jonathanstowe/Perl6-RMQ-Examples">RabbitMQ 教程</a>的所有示例，因此请检查并随意贡献。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_perl_6_支持的工作流">16. <a href="https://perl6advent.wordpress.com/2017/12/18/perl6-powered-work-flow/">第十八天-Perl 6 支持的工作流</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>保持流畅的编码可能是一个挑战。分心和讨厌的句法错误是潜在的流量瓶颈。</p>
</div>
<div class="paragraph">
<p>然后是7 +/- 2短期内存限制，我们都必须耍弄。与计算机不同，我们不能仅仅增加更多的硬件来增加大脑工作内存缓冲区的大小 - 至少目前还没有。保持流量需要管理这个缓冲区以避免井喷。幸运的是，我们有电脑帮助。</p>
</div>
<div class="paragraph">
<p>自计算开始以来，使用计算机扩展记忆的想法一直存在。早在1945年，Vannevar Bush就设想了一种Memex（MEMory EXtender），这是一种“扩大了对个人记忆的贴心补充”。</p>
</div>
<div class="paragraph">
<p>在2017年，卑微的文本文件可以像一个穷人的memex。该文本文件包含三个部分的时间轴：过去，现在和下一个。这有点像改变日志，但也有未来。过去的部分会随着时间的推移填满，包含完成的任务和信息供以后召回。现在部分可帮助您专注于手头的任务，而下一部分将排队完成将来要完成的任务。</p>
</div>
<div class="paragraph">
<p>任务通过三种状态：do（+ next），done（！now）和done（-past）。</p>
</div>
<div class="paragraph">
<p>为了保持畅通，你有时需要快速回忆一些事情，记下将来要做的事情，并专注于现在的进步。保留一个123.do文件可以帮助您减轻编码时的认知负担。</p>
</div>
<div class="paragraph">
<p>123.do文件的格式很简单，因此您可以直接使用文本编辑器对其进行破解，并使用此Perl 6语法进行描述。</p>
</div>
<div class="paragraph">
<p>这是驱动它的Perl 6命令行模块。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2017/12/tty.gif?w=652&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>安装它只需:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">shell</span>&gt; <span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Do123</span>
<span class="tok-n">shell</span>&gt; <span class="tok-mi">123</span> +<span class="tok-mi">7</span> <span class="tok-n">Merry</span> <span class="tok-n">Christmas</span>
<span class="tok-n">shell</span>&gt; <span class="tok-mi">123</span> +<span class="tok-mi">13</span> <span class="tok-n">Happy</span> <span class="tok-n">New</span> <span class="tok-n">Year</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_language_independent_validation_rules_livr_for_perl6">17. <a href="https://perl6advent.wordpress.com/2017/12/19/day-19-language-independent-validation-rules-livr-for-perl6/">第十九天-Language Independent Validation Rules (LIVR) for Perl6</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>我刚刚将 LIVR <a href="https://modules.perl6.org/dist/LIVR:cpan:KOORCHIK">移植</a>到了 Perl6。在 Perl6 中编写代码非常有趣。而且，LIVR 的测试套件让我能够在 Perl6 的 Email::Valid 模块中发现 bug，而在 Rakudo 中则发现另一个 bug。更有趣的是，不仅仅实现了一个模块，而且还帮助其他开发人员进行了一些测试:)</p>
</div>
<div class="paragraph">
<p>什么是 LIVR？ LIVR 代表“语言独立验证规则”。所以，它就像 “<a href="https://mustache.github.io/">Mustache</a>” ，但在验证的世界。所以，LIVR 由以下几部分组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://livr-spec.org/">LIVR规范</a></p>
</li>
<li>
<p><a href="http://livr-spec.org/introduction/implementations.html">针对不同语言的实现</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/LIVR/tree/master/test_suite">通用测试套件</a>，用于检查实现是否正常工作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>LIVR 有如下语言的实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/Validator-LIVR">Perl 5 (LIVR 2.0)</a> available at <a href="https://metacpan.org/pod/Validator::LIVR">CPAN</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/perl6-livr">Perl 6 (LIVR 2.0)</a> available at <a href="https://modules.perl6.org/dist/LIVR:cpan:KOORCHIK">CPAN</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/js-validator-livr">JavaScript (LIVR 2.0)</a> available at <a href="https://www.npmjs.com/package/livr">npm</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/WebbyLab/php-validator-livr">PHP (LIVR 2.0)</a> available at <a href="https://packagist.org/packages/validator/livr">packagist</a>, 维护者 <a href="https://github.com/WebbyLab">@WebbyLab</a></p>
</li>
<li>
<p><a href="https://github.com/asholok/python-validator-livr">Python (LIVR 2.0)</a> available at <a href="https://pypi.python.org/pypi/LIVR">pypi</a>, 维护者 <a href="https://github.com/asholok">@asholok</a></p>
</li>
<li>
<p><a href="https://github.com/Prots/olifer">OLIFER Erlang (LIVR 2.0)</a>, 维护者 <a href="https://github.com/Prots">@Prots</a></p>
</li>
<li>
<p><a href="https://github.com/erlangbureau/liver">LIVER Erlang (LIVR 2.0)</a>, 维护者 <a href="https://github.com/erlangbureau">@erlangbureau</a></p>
</li>
<li>
<p><a href="https://github.com/vlbaluk/java-validator-livr">Java (LIVR 2.0)</a>, 维护者 <a href="https://github.com/vlbaluk">@vlbaluk</a></p>
</li>
<li>
<p><a href="https://github.com/maktwin/ruby-validator-livr">Ruby (LIVR 0.4, previous version)</a> at <a href="https://rubygems.org/gems/livr">rubygems</a>, 维护者 <a href="https://github.com/maktwin">@maktwin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我会在这里给你一个关于LIVE的简短介绍，但是对于细节，我强烈推荐阅读这篇文章 <a href="http://blog.webbylab.com/language-independent-validation-rules-library/">“LIVR – Data Validation Without Any Issues”</a></p>
</div>
<div class="sect2">
<h3 id="_livr_介绍">17.1. LIVR 介绍</h3>
<div class="paragraph">
<p>数据验证是一项非常普遍的任务。我确信每个开发者都会一次又一次面对它。尤其是，当您开发Web应用程序时，这一点很重要。这是一条通用规则 - 绝对不要相信用户的输入。看起来，如果任务如此普遍，应该有大量的图库。是的，但它是很难找到一个理想的。有些库做了太多事情（如 HTML 表单生成等），其他库很难扩展，有些没有分层数据支持等。</p>
</div>
<div class="paragraph">
<p>而且，如果您是一名 Web 开发人员，则可能需要在服务器和客户端上进行相同的验证。</p>
</div>
<div class="paragraph">
<p>在 WebbyLab 中，我们主要使用 3 种编程语言 -  Perl，JavaScript，PHP。因此，对我们来说，重用跨语言的类似验证方法是理想的选择。</p>
</div>
<div class="paragraph">
<p>因此，决定创建一个可以跨不同语言工作的通用验证器。</p>
</div>
<div class="sect3">
<h4 id="_验证器要求">17.1.1. 验证器要求</h4>
<div class="paragraph">
<p>在尝试了大量的验证库之后，我们对我们想要解决的问题有了一些想法。以下是验证器的要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>规则是声明式并独立于语言的。因此，验证规则只是一个数据结构，而不是方法调用等。您可以对其进行转换，在对其他数据结构进行更改时进行更改</p>
</li>
<li>
<p>每个字段的任何数量的规则</p>
</li>
<li>
<p>验证器应该返回所有字段的错误。例如，我们想突出显示表单中的所有错误</p>
</li>
<li>
<p>剪掉所有没有描述验证规则的字段。 （否则，你不能依赖你的验证，如果验证器不符合这个属性，总有一天你会遇到安全问题）</p>
</li>
<li>
<p>可以验证复杂的层次结构。特别适用于 JSON APIs</p>
</li>
<li>
<p>易于描述和理解验证</p>
</li>
<li>
<p>返回可理解的错误代码（既不是错误消息也不是数字代码）</p>
</li>
<li>
<p>易于实现自己的规则（通常你会在每个项目中有几个）</p>
</li>
<li>
<p>规则应该能够改变结果输出（例如，“trim”，“nested_object”）</p>
</li>
<li>
<p>多用途（用户输入验证，配置验证等）</p>
</li>
<li>
<p>Unicode 支持</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_livr规范">17.1.2. LIVR规范</h4>
<div class="paragraph">
<p>由于该任务设置为独立于编程语言（某种胡须/句柄的东西）创建验证器，但在数据验证领域内，我们从规范的组成开始。</p>
</div>
<div class="paragraph">
<p>规范的目标是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标准化数据描述格式。</p>
</li>
<li>
<p>描述每个实现必须支持的最小验证规则集。</p>
</li>
<li>
<p>标准化错误代码。</p>
</li>
<li>
<p>成为所有实现的单个基本文档。</p>
</li>
<li>
<p>具有一组测试数据，可以检查实现是否符合规范。</p>
</li>
<li>
<p>基本思想是验证规则的描述必须看起来像数据方案，并且尽可能与数据类似，但是使用规则而不是值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该规范可在 <a href="http://livr-spec.org/" class="bare">http://livr-spec.org/</a> 获得。</p>
</div>
<div class="paragraph">
<p>这是基本的介绍。更多细节在我上面提到的文章中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_livr和perl6">17.2. LIVR和Perl6</h3>
<div class="paragraph">
<p>让我们玩得开心，玩一段代码。我将通过几个例子，并在每个例子后提供一些内部细节。所有示例的源代码都可以在 <a href="https://github.com/koorchik/perl6-livr-advent-calendar-post/tree/master/examples">GitHub</a> 上找到</p>
</div>
<div class="paragraph">
<p>首先，从 CPAN 安装 Perl 6 的 LIVR 模块</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">LIVR</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例1：注册数据验证</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;

<span class="tok-c1"># Automatically trim all values before validation</span>
<span class="tok-n">LIVR::Validator</span>.<span class="tok-n">default-auto-trim</span>(<span class="tok-nb">True</span>);

<span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(<span class="tok-n">livr-rules</span> =&gt; {
    <span class="tok-nb">name</span>      =&gt; <span class="tok-s">&#39;required&#39;</span>,
    <span class="tok-n">email</span>     =&gt; [ <span class="tok-s">&#39;required&#39;</span>, <span class="tok-s">&#39;email&#39;</span> ],
    <span class="tok-n">gender</span>    =&gt; { <span class="tok-n">one_of</span> =&gt; [<span class="tok-s">&#39;male&#39;</span>, <span class="tok-s">&#39;female&#39;</span>] },
    <span class="tok-n">phone</span>     =&gt; { <span class="tok-n">max_length</span> =&gt; <span class="tok-mi">10</span> },
    <span class="tok-n">password</span>  =&gt; [ <span class="tok-s">&#39;required&#39;</span>, {<span class="tok-n">min_length</span> =&gt; <span class="tok-mi">10</span>} ],
    <span class="tok-n">password2</span> =&gt; { <span class="tok-n">equal_to_field</span> =&gt; <span class="tok-s">&#39;password&#39;</span> }
});

<span class="tok-k">my</span> <span class="tok-nv">$user-data</span> = {
    <span class="tok-nb">name</span>      =&gt; <span class="tok-s">&#39;Viktor&#39;</span>,
    <span class="tok-n">email</span>     =&gt; <span class="tok-s">&#39;viktor@mail.com&#39;</span>,
    <span class="tok-n">gender</span>    =&gt; <span class="tok-s">&#39;male&#39;</span>,
    <span class="tok-n">password</span>  =&gt; <span class="tok-s">&#39;mypassword123&#39;</span>,
    <span class="tok-n">password2</span> =&gt; <span class="tok-s">&#39;mypassword123&#39;</span>
}


<span class="tok-k">if</span> <span class="tok-k">my</span> <span class="tok-nv">$valid-data</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">validate</span>(<span class="tok-nv">$user-data</span>) {
    <span class="tok-c1"># $valid-data is clean and does contain only fields</span>
    <span class="tok-c1"># which have validation and have passed it</span>
    <span class="tok-nv">$valid-data</span>.<span class="tok-nb">say</span>;
} <span class="tok-k">else</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$errors</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">errors</span>();
    <span class="tok-nv">$errors</span>.<span class="tok-nb">say</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>那么，如何理解规则？</strong></p>
</div>
<div class="paragraph">
<p>这个想法很简单。每条规则都是一个散列. key  - 验证规则的名称。value - 一个参数数组。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{
    <span class="tok-nb">name</span>  =&gt; { <span class="tok-k">required</span> =&gt; [] },
    <span class="tok-n">phone</span> =&gt; { <span class="tok-n">max_length</span> =&gt; [<span class="tok-mi">10</span>] }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但如果只有一个参数，则可以使用较短的形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{
    <span class="tok-n">phone</span> =&gt; { <span class="tok-n">max_length</span> =&gt; <span class="tok-mi">10</span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有参数，则可以将规则的名称作为字符串传递：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{
    <span class="tok-nb">name</span> =&gt; <span class="tok-s">&#39;required&#39;</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在数组中给字段传递一个规则列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{
    <span class="tok-nb">name</span> =&gt; [ <span class="tok-s">&#39;required&#39;</span>, { <span class="tok-n">max_length</span> =&gt; <span class="tok-mi">10</span> } ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，规则将陆续应用。因此，在这个例子中，首先，“required” 规则将被应用，“max_length” 之后，并且只有当 “required” 成功通过时。</p>
</div>
<div class="paragraph">
<p>这里是 <a href="http://livr-spec.org/validation-rules/how-it-works.html">LIVR 规范的细节</a>。</p>
</div>
<div class="paragraph">
<p>你可以在<a href="http://livr-spec.org/validation-rules.html">这里</a>找到标准规则的列表。</p>
</div>
<div class="paragraph">
<p>例2：分层数据结构的验证</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;

<span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(<span class="tok-n">livr-rules</span> =&gt; {
    <span class="tok-nb">name</span>  =&gt; <span class="tok-s">&#39;required&#39;</span>,
    <span class="tok-n">phone</span> =&gt; {<span class="tok-n">max_length</span> =&gt; <span class="tok-mi">10</span>},
    <span class="tok-n">address</span> =&gt; {<span class="tok-s">&#39;nested_object&#39;</span> =&gt; {
        <span class="tok-n">city</span> =&gt; <span class="tok-s">&#39;required&#39;</span>,
        <span class="tok-nb">zip</span>  =&gt; [<span class="tok-s">&#39;required&#39;</span>, <span class="tok-s">&#39;positive_integer&#39;</span>]
    }}
});

<span class="tok-k">my</span> <span class="tok-nv">$user-data</span> = {
    <span class="tok-nb">name</span>  =&gt; <span class="tok-s">&quot;Michael&quot;</span>,
    <span class="tok-n">phone</span> =&gt; <span class="tok-s">&quot;0441234567&quot;</span>,
    <span class="tok-n">address</span> =&gt; {
        <span class="tok-n">city</span> =&gt; <span class="tok-s">&quot;Kiev&quot;</span>,
        <span class="tok-nb">zip</span>  =&gt; <span class="tok-s">&quot;30552&quot;</span>
    }
}

<span class="tok-k">if</span> <span class="tok-k">my</span> <span class="tok-nv">$valid-data</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">validate</span>(<span class="tok-nv">$user-data</span>) {
    <span class="tok-c1"># $valid-data is clean and does contain only fields</span>
    <span class="tok-c1"># which have validation and have passed it</span>
    <span class="tok-nv">$valid-data</span>.<span class="tok-nb">say</span>;
} <span class="tok-k">else</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$errors</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">errors</span>();
    <span class="tok-nv">$errors</span>.<span class="tok-nb">say</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这个例子中有趣的是什么？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>模式（验证规则）形状与数据形状非常相似。例如，读取比 JSON Schema 容易得多。</p>
</li>
<li>
<p>看起来 “nested_object” 是一种特殊的语法，但它不是。验证器在 “required”，“nested_object”，“max_length” 之间没有任何区别。所以，核心非常小，您可以轻松地使用自定义规则引入新功能。</p>
</li>
<li>
<p>通常你想重用复杂的验证规则，比如 “address”，并且可以使用别名来完成。</p>
</li>
<li>
<p>您将收到分层错误消息。例如，如果您错过 city 和 name，错误对象将显示 <code>{name &#8658;'REQUIRED'，address &#8658; {city &#8658;'REQUIRED'}}</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_别名">17.2.1. 别名</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;

<span class="tok-n">LIVR::Validator</span>.<span class="tok-n">register-aliased-default-rule</span>({
    <span class="tok-nb">name</span>  =&gt; <span class="tok-s">&#39;short_address&#39;</span>, <span class="tok-c1"># names of the rule</span>
    <span class="tok-n">rules</span> =&gt; {<span class="tok-s">&#39;nested_object&#39;</span> =&gt; {
        <span class="tok-n">city</span> =&gt; <span class="tok-s">&#39;required&#39;</span>,
        <span class="tok-nb">zip</span>  =&gt; [<span class="tok-s">&#39;required&#39;</span>, <span class="tok-s">&#39;positive_integer&#39;</span>]
    }},
    <span class="tok-n">error</span> =&gt; <span class="tok-s">&#39;WRONG_ADDRESS&#39;</span> <span class="tok-c1"># custom error (optional)</span>
});

<span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(<span class="tok-n">livr-rules</span> =&gt; {
    <span class="tok-nb">name</span>    =&gt; <span class="tok-s">&#39;required&#39;</span>,
    <span class="tok-n">phone</span>   =&gt; {<span class="tok-n">max_length</span> =&gt; <span class="tok-mi">10</span>},
    <span class="tok-n">address</span> =&gt; <span class="tok-s">&#39;short_address&#39;</span>
});

<span class="tok-k">my</span> <span class="tok-nv">$user-data</span> = {
    <span class="tok-nb">name</span>  =&gt; <span class="tok-s">&quot;Michael&quot;</span>,
    <span class="tok-n">phone</span> =&gt; <span class="tok-s">&quot;0441234567&quot;</span>,
    <span class="tok-n">address</span> =&gt; {
        <span class="tok-n">city</span> =&gt; <span class="tok-s">&quot;Kiev&quot;</span>,
        <span class="tok-nb">zip</span>  =&gt; <span class="tok-s">&quot;30552&quot;</span>
    }
}

<span class="tok-k">if</span> <span class="tok-k">my</span> <span class="tok-nv">$valid-data</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">validate</span>(<span class="tok-nv">$user-data</span>) {
    <span class="tok-c1"># $valid-data is clean and does contain only fields</span>
    <span class="tok-c1"># which have validation and have passed it</span>
    <span class="tok-nv">$valid-data</span>.<span class="tok-nb">say</span>;
} <span class="tok-k">else</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$errors</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">errors</span>();
    <span class="tok-nv">$errors</span>.<span class="tok-nb">say</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你愿意，你可以只为你的验证器实例注册别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;

<span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(<span class="tok-n">livr-rules</span> =&gt; {
    <span class="tok-n">password</span> =&gt; [<span class="tok-s">&#39;required&#39;</span>, <span class="tok-s">&#39;strong_password&#39;</span>]
});

<span class="tok-nv">$validator</span>.<span class="tok-n">register-aliased-rule</span>({
    <span class="tok-nb">name</span>  =&gt; <span class="tok-s">&#39;strong_password&#39;</span>,
    <span class="tok-n">rules</span> =&gt; {<span class="tok-n">min_length</span> =&gt; <span class="tok-mi">6</span>},
    <span class="tok-n">error</span> =&gt; <span class="tok-s">&#39;WEAK_PASSWORD&#39;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例3：数据修改，流水线</strong>
有规则可以做数据修改。以下是他们的列表：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>trim</p>
</li>
<li>
<p>to_lc</p>
</li>
<li>
<p>to_uc</p>
</li>
<li>
<p>remove</p>
</li>
<li>
<p>leave_only</p>
</li>
<li>
<p>default</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以在这里<a href="http://livr-spec.org/validation-rules/modifiers.html">阅读细节</a>。</p>
</div>
<div class="paragraph">
<p>用这种方法，你可以创建某种管道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;

<span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(<span class="tok-n">livr-rules</span> =&gt; {
    <span class="tok-n">email</span> =&gt; [ <span class="tok-s">&#39;trim&#39;</span>, <span class="tok-s">&#39;required&#39;</span>, <span class="tok-s">&#39;email&#39;</span>, <span class="tok-s">&#39;to_lc&#39;</span> ]
});

<span class="tok-k">my</span> <span class="tok-nv">$input-data</span> = { <span class="tok-n">email</span> =&gt; <span class="tok-s">&#39; EMail@Gmail.COM &#39;</span> };
<span class="tok-k">my</span> <span class="tok-nv">$output-data</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">validate</span>(<span class="tok-nv">$input-data</span>);

<span class="tok-nv">$output-data</span>.<span class="tok-nb">say</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这里重要的是什么？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>正如我之前提到的，对于验证器来说，任何规则都没有区别。它以同样的方式处理 “trim”，“default”，“required”，“nested_object”。</p>
</li>
<li>
<p>规则一个接一个地应用。规则的输出将被传递给下一个规则的输入。这就像一个 bash 管道 <code>echo ' <a href="mailto:EMail@Gmail.COM">EMail@Gmail.COM</a> ' | trim | required | email | to_lc</code></p>
</li>
<li>
<p><code>$input-data</code> <strong>永远不会</strong>改变 <code>$output-data</code> 是验证后使用的数据。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示例4：自定义规则</strong></p>
</div>
<div class="paragraph">
<p>您可以使用别名作为自定义规则，但有时这还不够。编写自己的自定义规则绝对没问题。你可以用自定义规则做几乎所有事情。</p>
</div>
<div class="paragraph">
<p>通常，我们在每个项目中都有 1-5 个自定义规则。此外，您可以将自定义规则组织为单独的可重用模块（甚至可以将其上传到 CPAN）。</p>
</div>
<div class="paragraph">
<p><strong>那么，如何为 LIVR 编写自定义规则？</strong></p>
</div>
<div class="paragraph">
<p>这里是&#8217;strong_password&#8217;的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;

<span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(<span class="tok-n">livr-rules</span> =&gt; {
    <span class="tok-n">password</span> =&gt; [<span class="tok-s">&#39;required&#39;</span>, <span class="tok-s">&#39;strong_password&#39;</span>]
});

<span class="tok-nv">$validator</span>.<span class="tok-n">register-rules</span>( <span class="tok-s">&#39;strong_password&#39;</span> =&gt;  <span class="tok-k">sub</span> (<span class="tok-nv">@rule-args</span>, <span class="tok-nv">%builders</span>) {
    <span class="tok-c1"># %builders - are rules from original validator</span>
    <span class="tok-c1"># to allow you create new validator with all supported rules</span>
    <span class="tok-c1"># my $validator = LIVR::Validator.new(livr-rules =&gt; $livr).register-rules(%builders).prepare();</span>
    <span class="tok-c1"># See &quot;nested_object&quot; rule implementation for example</span>
    <span class="tok-c1"># https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/Meta.pm6#L5</span>

    <span class="tok-c1"># Return closure that will take value and return error</span>
    <span class="tok-k">return</span> <span class="tok-k">sub</span> (<span class="tok-nv">$value</span>, <span class="tok-nv">$all-values</span>, <span class="tok-nv">$output</span> <span class="tok-k">is</span> <span class="tok-k">rw</span>) {
        <span class="tok-c1"># We already have &quot;required&quot; rule to check that the value is present</span>
        <span class="tok-k">return</span> <span class="tok-k">if</span> <span class="tok-n">LIVR::Utils::is-no-value</span>(<span class="tok-nv">$value</span>); <span class="tok-c1"># so we skip empty values</span>

        <span class="tok-c1"># Return value is a string</span>
        <span class="tok-k">return</span> <span class="tok-s">&#39;FORMAT_ERROR&#39;</span> <span class="tok-k">if</span> <span class="tok-nv">$value</span> !~~ <span class="tok-nb">Str</span> &amp;&amp; <span class="tok-nv">$value</span> !~~ <span class="tok-n">Numeric</span>;

        <span class="tok-c1"># Return error in case of failed validation</span>
        <span class="tok-k">return</span> <span class="tok-s">&#39;WEAK_PASSWORD&#39;</span> <span class="tok-k">if</span> <span class="tok-nv">$value</span>.<span class="tok-nb">chars</span> &lt; <span class="tok-mi">6</span>;

        <span class="tok-c1"># Change output value. We want always return value be a string</span>
        <span class="tok-nv">$output</span> = <span class="tok-nv">$value</span>.<span class="tok-nb">Str</span>;
        <span class="tok-k">return</span>;
    };
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看更多示例的现有规则实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/Common.pm6">Common rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/Numeric.pm6">Numeric rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/String.pm6">String rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/Special.pm6">Special rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/Modifiers.pm6">Modifiers rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/perl6-livr/blob/master/lib/LIVR/Rules/Meta.pm6">Meta rules</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示例5：Web 应用程序</strong></p>
</div>
<div class="paragraph">
<p>LIVR 适用于 REST API。通常，很多 REST API 在返回可理解的错误方面存在问题。如果您的 API 用户将收到 HTTP 错误 500，它不会帮助他。更好的时候，他会得到类似的错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>{
    <span class="tok-s">&quot;name&quot;</span>: <span class="tok-s">&quot;REQUIRED&quot;</span>,
    <span class="tok-s">&quot;phone&quot;</span>: <span class="tok-s">&quot;TOO_LONG&quot;</span>,
    <span class="tok-s">&quot;address&quot;</span>: {
        <span class="tok-s">&quot;city&quot;</span>: <span class="tok-s">&quot;REQUIRED&quot;</span>,
        <span class="tok-s">&quot;zip&quot;</span>: <span class="tok-s">&quot;NOT_POSITIVE_INTEGER&quot;</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不仅仅是“服务器错误”。</p>
</div>
<div class="paragraph">
<p>所以，让我们试着做一个带有两个端点的小型 Web 服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GET /notes &#8594; get list of notes</p>
</li>
<li>
<p>POST /notes &#8594; create a note</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要为其安装 Bailador：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Bailador</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来创建一些服务。我更喜欢带有 “run”模板方法的服务中的 “Command”模式。</p>
</div>
<div class="paragraph">
<p>我们将有 2 项服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Service::Notes::Create</p>
</li>
<li>
<p>Service::Notes::List</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>服务使用示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">%CONTEXT</span> = (<span class="tok-n">storage</span> =&gt; <span class="tok-k">my</span> <span class="tok-nv">@STORAGE</span>);

<span class="tok-k">my</span> <span class="tok-nv">%note</span> = <span class="tok-n">title</span> =&gt; <span class="tok-s">&#39;Note1&#39;</span>, <span class="tok-n">text</span> =&gt; <span class="tok-s">&#39;Note text&#39;</span>;

<span class="tok-k">my</span> <span class="tok-nv">$new-note</span> = <span class="tok-n">Service::Notes::Create</span>.<span class="tok-nb">new</span>(
    <span class="tok-nb">context</span> =&gt; <span class="tok-nv">%CONTEXT</span>
).<span class="tok-nb">run</span>(<span class="tok-nv">%note</span>);

<span class="tok-k">my</span> <span class="tok-nv">$list</span> = <span class="tok-n">Service::Notes::Create</span>.<span class="tok-nb">new</span>(
    <span class="tok-nb">context</span> =&gt; <span class="tok-nv">%CONTEXT</span>
).<span class="tok-nb">run</span>({});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了上下文，你可以注入任何依赖关系。 “run” 方法接受用户传递的数据。</p>
</div>
<div class="paragraph">
<p>以下是创建笔记服务的源代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Service::Base</span>;
<span class="tok-k">my</span> <span class="tok-nv">$LAST_ID</span> = <span class="tok-mi">0</span>;
<span class="tok-k">class</span> <span class="tok-n">Service::Notes::Create</span> <span class="tok-k">is</span> <span class="tok-n">Service::Base</span> {
    <span class="tok-k">has</span> <span class="tok-nv">%.validation-rules</span> = (
        <span class="tok-n">title</span> =&gt; [<span class="tok-s">&#39;required&#39;</span>, {<span class="tok-n">max_length</span> =&gt; <span class="tok-mi">20</span>} ],
        <span class="tok-n">text</span>  =&gt; [<span class="tok-s">&#39;required&#39;</span>, {<span class="tok-n">max_length</span> =&gt; <span class="tok-mi">255</span>} ]
    );

    <span class="tok-k">method</span> <span class="tok-n">execute</span>(<span class="tok-nv">%note</span>) {
        <span class="tok-nv">%note&lt;id&gt;</span> = <span class="tok-nv">$LAST_ID</span>++;
        <span class="tok-nv">$.context&lt;storage&gt;</span>.<span class="tok-nb">push</span>(<span class="tok-nv">%note</span>);

        <span class="tok-k">return</span> <span class="tok-nv">%note</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和 Service::Base 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">LIVR</span>;
<span class="tok-n">LIVR::Validator</span>.<span class="tok-n">default-auto-trim</span>(<span class="tok-nb">True</span>);

<span class="tok-k">class</span> <span class="tok-n">Service::Base</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$.context</span> = {};

    <span class="tok-k">method</span> <span class="tok-nb">run</span>(<span class="tok-nv">%params</span>) {
        <span class="tok-k">my</span> <span class="tok-nv">%clean-data</span> = <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">validate</span>(<span class="tok-nv">%params</span>);
        <span class="tok-k">return</span> <span class="tok-k">self</span>.<span class="tok-n">execute</span>(<span class="tok-nv">%params</span>);
    }

    <span class="tok-k">method</span> !<span class="tok-n">validate</span>(<span class="tok-nv">$params</span>) {
        <span class="tok-k">return</span> <span class="tok-nv">$params</span> <span class="tok-k">unless</span> <span class="tok-nv">%.validation-rules</span>.<span class="tok-nb">elems</span>;

        <span class="tok-k">my</span> <span class="tok-nv">$validator</span> = <span class="tok-n">LIVR::Validator</span>.<span class="tok-nb">new</span>(
            <span class="tok-n">livr-rules</span> =&gt; <span class="tok-nv">%.validation-rules</span>
        );

        <span class="tok-k">if</span> <span class="tok-k">my</span> <span class="tok-nv">$valid-data</span> = <span class="tok-nv">$validator</span>.<span class="tok-n">validate</span>(<span class="tok-nv">$params</span>) {
            <span class="tok-k">return</span> <span class="tok-nv">$valid-data</span>;
        } <span class="tok-k">else</span> {
            <span class="tok-k">die</span> <span class="tok-nv">$validator</span>.<span class="tok-n">errors</span>();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>“run” 方法保证所有过程都被保留：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据已经过验证。</p>
</li>
<li>
<p>“execute” 仅在验证后才会调用。</p>
</li>
<li>
<p>“execute” 将只收到干净的数据。</p>
</li>
<li>
<p>在验证错误的情况下引发异常。</p>
</li>
<li>
<p>在调用“execute”之前可以检查权限。</p>
</li>
<li>
<p>可以执行额外的工作，如缓存验证器对象等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是<a href="https://github.com/koorchik/perl6-livr-advent-calendar-post/tree/master/examples/example5-restapi">完整的工作示例</a>。</p>
</div>
<div class="paragraph">
<p>运行应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">perl6</span> <span class="tok-n">app</span>.<span class="tok-n">pl6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个 note：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">curl</span> -<span class="tok-n">H</span> <span class="tok-s">&quot;Content-Type: application/json&quot;</span> -<span class="tok-o">X</span> <span class="tok-k">POST</span> -<span class="tok-n">d</span> <span class="tok-s">&#39;{&quot;title&quot;:&quot;New Note&quot;,&quot;text&quot;:&quot;Some text here&quot;}&#39;</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:3000</span><span class="tok-o">/</span><span class="tok-n">notes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>检查验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">curl</span> -<span class="tok-n">H</span> <span class="tok-s">&quot;Content-Type: application/json&quot;</span> -<span class="tok-o">X</span> <span class="tok-k">POST</span> -<span class="tok-n">d</span> <span class="tok-s">&#39;{&quot;title&quot;:&quot;&quot;,&quot;text&quot;:&quot;&quot;}&#39;</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:3000</span><span class="tok-o">/</span><span class="tok-n">notes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>获取notes列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">curl</span> <span class="tok-n">http:</span>//<span class="tok-n">localhost:3000</span><span class="tok-o">/</span><span class="tok-n">notes</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_livr_链接">17.3. LIVR 链接</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/perl6-livr-advent-calendar-post/tree/master/examples">The source code of all examples</a></p>
</li>
<li>
<p>文章 <a href="http://blog.webbylab.com/language-independent-validation-rules-library/">“LIVR – Data Validation Without Any Issues”</a></p>
</li>
<li>
<p><a href="http://livr-spec.org/">LIVR specifications and docs (the latest version – 2.0)</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/LIVR/tree/master/test_suite">Universal test suite</a></p>
</li>
<li>
<p>你可以在线玩 <a href="http://webbylab.github.io/livr-playground/">LIVR Playground</a></p>
</li>
<li>
<p>你可以在线玩 <a href="http://livr-multi-playground.webbylab.com/">LIVR Multi-Language Playground</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我希望你会喜欢 LIVR。我会很感激任何反馈。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_宏的进阶">18. <a href="https://perl6advent.wordpress.com/2017/12/20/day-20-advancements-in-macrotechnologies/">第二十天-宏的进阶</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>你好！</p>
</div>
<div class="paragraph">
<p>请允许我，在出现日历的这一天，一个小切线。我不会直接谈论一个很酷的熟练的Perl 6特性。相反，我会打开一个小窗口，讨论可能会发生什么 - 希望在某些时候！</p>
</div>
<div class="paragraph">
<p>如果你像我一样，在Rakudo上继续了几年的进步，你在版本中经常看到这一点：&gt;一些不太有效的功能包括：&gt;  - 高级宏</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">那么，这究竟意味着什么？ Perl 6确实有宏，但它们目前的限制超出了人们通常想要做的。这并不是说它们目前是无用的，它们仍然是有用的，从前几年出现的其他帖子到OO </dt>
<dd>
<p>Monitor使用宏来提前报告拼写错误。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>输入007. 007是“具有宏观许可的小型实验语言”。这是什么意思？！这是一种用于对宏进行调试和实验的语言，因此当他们被集成到Perl 6中时，他们的设计就已经准备好并经过战斗测试。</p>
</div>
<div class="paragraph">
<p>那么，它有什么？ 007试图模仿Perl 6的“强大”部分，因此我们不会为完全不同的语言设计宏。这意味着阶段，中缀操作员，（MOP和正则表达式的要点）。</p>
</div>
<div class="paragraph">
<p>它是什么样子的？ 007的核心就是喜欢Perl 6.然而，它的确存在一些问题。让我们来看看你想写的最重要的片段：FizzBu​​zz。注意：此博客帖子中的所有代码片段都是可执行的007代码，而不是Perl 6代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-n">n</span> = <span class="tok-mi">1</span>;
<span class="tok-k">while</span> <span class="tok-n">n</span> &lt;= <span class="tok-mi">100</span> {
    <span class="tok-k">if</span> <span class="tok-n">n</span> %% <span class="tok-mi">15</span> {
        <span class="tok-nb">say</span>(<span class="tok-s">&quot;FizzBuzz&quot;</span>);
    }
    <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-n">n</span> %% <span class="tok-mi">3</span> {
        <span class="tok-nb">say</span>(<span class="tok-s">&quot;Fizz&quot;</span>);
    }
    <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-n">n</span> %% <span class="tok-mi">5</span> {
        <span class="tok-nb">say</span>(<span class="tok-s">&quot;Buzz&quot;</span>);
    }
    <span class="tok-k">else</span> {
        <span class="tok-nb">say</span>(<span class="tok-n">n</span>);
    }
    <span class="tok-n">n</span> = <span class="tok-n">n</span> + <span class="tok-mi">1</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么？你不在乎吗？很明显，我确实答应过你的宏。我们将看看一个简单的宏“name”，它返回最后一个索引对象的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">macro</span> <span class="tok-nb">name</span>(<span class="tok-n">expr</span>) {
    <span class="tok-k">if</span> <span class="tok-n">expr</span> ~~ <span class="tok-s">Q::Postfix::Property {</span>
<span class="tok-s">        expr = expr.property;</span>
<span class="tok-s">    }</span>
    <span class="tok-k">if</span> <span class="tok-n">expr</span> !~~ <span class="tok-s">Q::Identifier {</span>
<span class="tok-s">        throw new Exception {</span>
<span class="tok-s">            message: &quot;Cannot turn a &quot; ~ type(expr) ~ &quot; into a name&quot;</span>
<span class="tok-s">        };</span>
<span class="tok-s">    }</span>
    <span class="tok-k">return</span> <span class="tok-nb">quasi</span> { <span class="tok-n">expr</span>.<span class="tok-nb">name</span> };
}

<span class="tok-k">my</span> <span class="tok-n">info</span> = {
    <span class="tok-n">foo:</span> <span class="tok-s">&quot;Bond&quot;</span>,
    <span class="tok-n">bar:</span> {
        <span class="tok-n">baz:</span> <span class="tok-s">&quot;James Bond&quot;</span>
    },
};

<span class="tok-nb">say</span>(<span class="tok-nb">name</span>(<span class="tok-n">info</span>));           <span class="tok-c1"># info</span>
<span class="tok-nb">say</span>(<span class="tok-nb">name</span>(<span class="tok-n">info</span>.<span class="tok-n">foo</span>));       <span class="tok-c1"># foo</span>
<span class="tok-nb">say</span>(<span class="tok-nb">name</span>(<span class="tok-n">info</span>.<span class="tok-n">bar</span>.<span class="tok-n">baz</span>));   <span class="tok-c1"># baz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，你可能会在这里“WAT”。你是对的 - 这个要点缺少一些解释。宏的一个最重要的功能是访问AST（抽象语法树）。宏需要能够混淆代码的结构（如Lisp），而不是代码文本（如C）。 Q ::类型是代表程序形状的标准化类型。他们并不特别需要表示编译器/解释器如何考虑代码，但他们需要保持稳定，因为我们正在编写我们的代码 - 我们的宏 - 针对这种内省API。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在这个代码示例中，我们使用了两种Q类型：表示点访问的Q </dt>
<dd>
<p>Postfix :: Property和表示标识符的Q :: Identifier。首先，我们检查我们是否有财产。如果是这种情况，我们提取点右侧的内容（记住，a.b.c是（a.b）.c）。然后我们检查我们是否结束了一个标识符（而不是一个数字），并打印出来。这是例如我们如何才能实现C＃的操作符名称，而不必为语言添加任何内容！</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>几天前，masak ++发布了一篇名为“三年过去”的博客文章，标志着007的第三个生日。虽然有些地区仍然非常粗糙，但它看起来越来越像一种可用的语言，日复一日。</p>
</div>
<div class="paragraph">
<p>接下来我们要看的是正在解析的实现。下面是它的外观：（这个例子适用于PR，但是现在使用特殊外壳）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">macro</span> <span class="tok-n">statement:</span>() <span class="tok-k">is</span> <span class="tok-k">parsed</span>(<span class="tok-sr">/&quot;whoa!&quot;/</span>) {
    <span class="tok-k">return</span> <span class="tok-nb">quasi</span> @ <span class="tok-s">Q::Statement {</span>
<span class="tok-s">        say(&quot;whoa!&quot;);</span>
<span class="tok-s">    }</span>
};

<span class="tok-n">whoa</span>!;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也可能是我们希望他们在Perl 6中看起来&#8230;&#8203;&#8230;&#8203;或者不是？讨论仍在进行中！鼓励你加入自行车&#8230;&#8203;&#8230;&#8203;讨论:-)。这种语言还很年轻，需要大量的丰富功能，以及它的高级功能和简单功能。</p>
</div>
<div class="paragraph">
<p>在我向你提供大量的元乐趣之前，这里是007想要达到目前坐落在分支中的一个里程碑：实现infix：&lt;ff&gt;作为库的一部分（如果你不确定，Perl 6文档如果在这里适用），而不是语言的一部分。代码在这里！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># our infix macro takes a lhs (left hand side) and a rhs (right hand side).</span>
<span class="tok-k">macro</span> <span class="tok-n">infix:</span><span class="tok-s">&lt;ff&gt;</span>(<span class="tok-n">lhs</span>, <span class="tok-n">rhs</span>) <span class="tok-k">is</span> <span class="tok-k">tighter</span>(<span class="tok-n">infix:</span>&lt;=&gt;) {
    <span class="tok-k">my</span> <span class="tok-n">active</span> = <span class="tok-nb">False</span>; <span class="tok-c1"># our current value when starting</span>
    <span class="tok-k">return</span> <span class="tok-nb">quasi</span> {
        <span class="tok-k">if</span> {{{<span class="tok-n">lhs</span>}}} {
            <span class="tok-n">active</span> = <span class="tok-nb">True</span>; <span class="tok-c1"># if the bit on the left is true, we switch to active mode</span>
        }
        <span class="tok-k">my</span> <span class="tok-n">result</span> = <span class="tok-n">active</span>; <span class="tok-c1"># the result we are returning</span>
        <span class="tok-k">if</span> {{{<span class="tok-n">rhs</span>}}} {
            <span class="tok-n">active</span> = <span class="tok-nb">False</span>; <span class="tok-c1"># if the bit on the right is true, we switch to inactive mode</span>
        }
        <span class="tok-n">result</span>; <span class="tok-c1"># return the result stored *before* the rhs ran.</span>
    };
}

<span class="tok-k">my</span> <span class="tok-nb">values</span> = [<span class="tok-s">&quot;A&quot;</span>, <span class="tok-s">&quot;B&quot;</span>, <span class="tok-s">&quot;A&quot;</span>, <span class="tok-s">&quot;B&quot;</span>, <span class="tok-s">&quot;A&quot;</span>];
<span class="tok-k">for</span> <span class="tok-nb">values</span> -&gt; <span class="tok-n">v</span> {
    <span class="tok-k">if</span> <span class="tok-n">v</span> == <span class="tok-s">&quot;B&quot;</span> <span class="tok-o">ff</span> <span class="tok-n">v</span> == <span class="tok-s">&quot;B&quot;</span> {
        <span class="tok-nb">say</span>(<span class="tok-n">v</span>);
    }
    <span class="tok-k">else</span> {
        <span class="tok-nb">say</span>(<span class="tok-s">&quot;x&quot;</span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是今天！如果您需要更多，请随时查看教程或示例文件夹。如果你想了解意愿，我们也有路线图。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_数独与junctions和集合">19. <a href="https://perl6advent.wordpress.com/2017/12/21/day-21-sudoku-with-junctions-and-sets/">第二十一天-数独与Junctions和集合</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Perl6 中有许多核心元素为您提供强大的工具，以简洁而强大的方式完成任务。其中两个是具有许多特征的联结和集合，但也是截然不同的。为了演示这些功能，我将介绍如何将它们用于一个简单的问题，Sudoku拼图。</p>
</div>
<div class="paragraph">
<p>数独：进修
所以对于那些不知道数独谜题的人来说，它是一个9乘9的网格，它提供了一些填充了数字1-9的单元格。目标是填充数字在1和9之间的所有单元格，所以没有任何行，列或子广场具有多于一个的数字。</p>
</div>
<div class="paragraph">
<p>有几种方法来表示一个数独谜题，我个人最喜欢的是 9×9 嵌套数组，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@game</span> = [
    [<span class="tok-mi">4</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>],
    [<span class="tok-mi">0</span>,<span class="tok-mi">9</span>,<span class="tok-mi">0</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>,<span class="tok-mi">6</span>,<span class="tok-mi">0</span>,<span class="tok-mi">5</span>,<span class="tok-mi">0</span>],
    [<span class="tok-mi">5</span>,<span class="tok-mi">8</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">9</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">6</span>],
    [<span class="tok-mi">0</span>,<span class="tok-mi">4</span>,<span class="tok-mi">0</span>,<span class="tok-mi">8</span>,<span class="tok-mi">1</span>,<span class="tok-mi">3</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">9</span>],
    [<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">5</span>,<span class="tok-mi">0</span>,<span class="tok-mi">4</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>],
    [<span class="tok-mi">8</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">6</span>,<span class="tok-mi">2</span>,<span class="tok-mi">9</span>,<span class="tok-mi">0</span>,<span class="tok-mi">4</span>,<span class="tok-mi">0</span>],
    [<span class="tok-mi">3</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">5</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">6</span>,<span class="tok-mi">2</span>],
    [<span class="tok-mi">0</span>,<span class="tok-mi">5</span>,<span class="tok-mi">0</span>,<span class="tok-mi">9</span>,<span class="tok-mi">3</span>,<span class="tok-mi">2</span>,<span class="tok-mi">0</span>,<span class="tok-mi">8</span>,<span class="tok-mi">0</span>],
    [<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">1</span>]
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，没有赋值的单元格被赋值为0，这样所有的单元格都有一个赋值给它们的整数值。使用这种格式要记住的主要事情是你需要使用@game [$ y] [$ x]而不是@game [$ x] [$ y]来引用单元格，</p>
</div>
<div class="sect2">
<h3 id="_junctions量子逻辑测试">19.1. Junctions：量子逻辑测试</h3>
<div class="paragraph">
<p>在 Perl6 中使用 Junction 的最简单方法之一是逻辑测试。 Junction可以表示您想要测试的值的选择。例如 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">if</span> ( <span class="tok-mi">5</span> &lt; <span class="tok-mi">1</span><span class="tok-o">|</span><span class="tok-mi">10</span> &lt; <span class="tok-mi">2</span> ) { <span class="tok-nb">say</span> <span class="tok-s">&quot;Spooky&quot;</span> } <span class="tok-k">else</span> { <span class="tok-nb">say</span> <span class="tok-s">&quot;Boo&quot;</span> }
<span class="tok-n">Spooky</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，这不仅证明了操作符链（经验丰富的程序员可能已经看起来很困惑），而且对于5 &lt;10和1 &lt;2，任何连接点（1 | 10）的计算结果都为True。这样，连接点可以非常已经很强大了，当你为它们分配一个变量容器时，它变得非常有趣。</p>
</div>
<div class="paragraph">
<p>我们希望能够在我们的数独游戏中做出的一个测试就是看它是否已满。我的意思是每个单元格的赋值都大于0.完整的拼图可能无法正确完成，但每个单元格都有一个猜测。另一种方法是，没有任何单元格的值为0.因此，我们可以定义一个Junction并将其存储在一个标量变量中，我们可以在任何时候测试它以查看拼图是否已满。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$full-test</span> = <span class="tok-nb">none</span>( (^<span class="tok-mi">9</span> <span class="tok-o">X</span> ^<span class="tok-mi">9</span>).<span class="tok-nb">map</span>(-&gt; (<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>) {
    <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>];
} ) );
<span class="tok-nb">say</span> <span class="tok-o">so</span> <span class="tok-nv">$full-test</span> == <span class="tok-mi">0</span>;
<span class="tok-nb">False</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，游戏中仍然有0个数字，因此看看$ full-test是否等于0，结果为False。请注意，如果没有将结果强制转换为布尔值，只有当所有这些值都为False时，才会得到等于0的单元格的细分。</p>
</div>
<div class="paragraph">
<p>还要注意使用^ 9和X运算符来生成0到8的两个范围，然后使用这两个9个字符的列表的叉积来列出所有可能的X，Y坐标的列表。这就是这种强大的简单性，这是我喜欢Perl6的原因之一。但我离题了。</p>
</div>
<div class="paragraph">
<p>这种方法的优点是，一旦你定义了Junction，你就不需要修改它。如果您更改存储在数组中的值，那么连接将会查看新的值（注意，这仅适用于更新单个单元格，如果用新的数组替换整个子数组，您将打破连接点）。</p>
</div>
<div class="paragraph">
<p>所以这是一个简单的使用连接点，因此存储一个可以重复使用的多变量测试。但是当你意识到连接点中的值本身就是连接点时，它会变得更有趣。</p>
</div>
<div class="paragraph">
<p>让我们看看更复杂的测试，如果拼图中的每一行，每列和每个数字中只有一个，则拼图就完成了。为了做这个测试，我们需要三个帮助函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">subset</span> <span class="tok-n">Index</span> <span class="tok-k">of</span> <span class="tok-nb">Int</span> <span class="tok-k">where</span> <span class="tok-mi">0</span> &lt;= * &lt;= <span class="tok-mi">8</span>;
<span class="tok-k">sub</span> <span class="tok-n">row</span>( <span class="tok-n">Index</span> <span class="tok-nv">$y</span> ) {
    <span class="tok-k">return</span> (^<span class="tok-mi">9</span>).<span class="tok-nb">map</span>( { ( <span class="tok-nv">$_</span>, <span class="tok-nv">$y</span> ) } );
}
<span class="tok-k">sub</span> <span class="tok-n">col</span>( <span class="tok-n">Index</span> <span class="tok-nv">$x</span> ) {
     <span class="tok-k">return</span> (^<span class="tok-mi">9</span>).<span class="tok-nb">map</span>( { ( <span class="tok-nv">$x</span>, <span class="tok-nv">$_</span> ) } );
}
<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">square</span>( <span class="tok-n">Index</span> <span class="tok-nv">$sq</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">$x</span> = <span class="tok-nv">$sq</span> % <span class="tok-mi">3</span> * <span class="tok-mi">3</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$y</span> = <span class="tok-nv">$sq</span> <span class="tok-o">div</span> <span class="tok-mi">3</span> * <span class="tok-mi">3</span>;
    <span class="tok-k">return</span> <span class="tok-k">self</span>.<span class="tok-n">square</span>( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> );
}
<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">square</span>( <span class="tok-n">Index</span> <span class="tok-nv">$x</span>, <span class="tok-n">Index</span> <span class="tok-nv">$y</span> ) {
     <span class="tok-k">my</span> <span class="tok-nv">$tx</span> = <span class="tok-nv">$x</span> <span class="tok-o">div</span> <span class="tok-mi">3</span> * <span class="tok-mi">3</span>;
     <span class="tok-k">my</span> <span class="tok-nv">$ty</span> = <span class="tok-nv">$y</span> <span class="tok-o">div</span> <span class="tok-mi">3</span> * <span class="tok-mi">3</span>;
     <span class="tok-k">return</span> ( (<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">2</span>) <span class="tok-o">X</span> (<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">2</span>) ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$dx</span>, <span class="tok-nv">$dy</span> ) {
        ( <span class="tok-nv">$tx</span> + <span class="tok-nv">$dx</span>, <span class="tok-nv">$ty</span> + <span class="tok-nv">$dy</span> )
    } );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们在这里定义一个索引作为0到8之间的值，然后定义我们的子索引来返回一个列表列表，其中子列表是一对X和Y索引。请注意，我们的平方函数可以接受一个或两个位置参数。在单个参数中，我们定义了0在左上角然后从左到右，8是右下角的子广场。两个参数版本给出了给定单元格（包括它自己）的正方形单元格列表。</p>
</div>
<div class="paragraph">
<p>所以在这些地方我们可以为每一行，列和方块定义我们的一个（）列表。一旦我们拥有了它们，我们就可以将它们放入一个全部（）连接点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$complete-all</span> = <span class="tok-nb">all</span>(
     (^<span class="tok-mi">9</span>).<span class="tok-nb">map</span>(
        {
            |(
                <span class="tok-nb">one</span>( <span class="tok-n">row</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                    <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                } ) ),
                <span class="tok-nb">one</span>( <span class="tok-n">col</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                    <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                } ) ),
                <span class="tok-nb">one</span>( <span class="tok-n">square</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                    <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                } ) )
            )
        }
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦我们进行了测试，看看这个难题是否完整，那就很简单了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> [&amp;&amp;] (<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>).<span class="tok-nb">map</span>( <span class="tok-o">so</span> <span class="tok-nv">$complete-all</span> == * );
<span class="tok-nb">False</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们测试1到9的每个可能的单元格值，对于交叉点，在每种情况下，如果所有的一个（）连接仅包含一个值，则这将为真。然后，我们使用[]缩减元运算符来链接这些结果以给出最终的真/假值（如果所有结果均为真，否则为真）。再次，这个测试可以在您向单元格添加值时重新使用，并且只有在拼图完成且正确时才会返回True。</p>
</div>
<div class="paragraph">
<p>我们再一次将复杂的测试归结为一行代码。我们的$ complete-all变量需要定义一次，然后在会话的其余部分有效。</p>
</div>
<div class="paragraph">
<p>这种嵌套联结测试可以达到很多级别，最后一个例子是如果我们想测试当前的难题是否有效。我的意思是它没有完成，但它没有任何重复的数字和行，列或方块。我们可以再次为此创建一个Junction，对于每一行，每列或每个方块，如果其中一个或没有一个单元格设置为每个可能的值，则它是有效的。因此，我们创建的Junction类似于$ complete-全部。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nv">$valid-all</span> = <span class="tok-nb">all</span>(
    (^<span class="tok-mi">9</span>).<span class="tok-nb">map</span>(
        {
            |(
                <span class="tok-nb">one</span>(
                    <span class="tok-nb">none</span>( <span class="tok-n">row</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                    } ) ),
                    <span class="tok-nb">one</span>( <span class="tok-n">row</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                    } ) )
                ),
                <span class="tok-nb">one</span>(
                    <span class="tok-nb">none</span>( <span class="tok-n">col</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                    } ) ),
                    <span class="tok-nb">one</span>( <span class="tok-n">col</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                    } ) )
                ),
                <span class="tok-nb">one</span>(
                    <span class="tok-nb">none</span>( <span class="tok-n">square</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                    } ) ),
                    <span class="tok-nb">one</span>( <span class="tok-n">square</span>( <span class="tok-nv">$_</span> ).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
                    } ) )
                )
            )
        }
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有效性测试与完整性测试基本相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> [&amp;&amp;] (<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>).<span class="tok-nb">map</span>( <span class="tok-o">so</span> <span class="tok-nv">$valid-all</span> == * );
<span class="tok-nb">True</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了在这种情况下我们的谜题是有效的，所以我们得到一个真实的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_集合对象的集合">19.2. 集合：对象的集合</h3>
<div class="paragraph">
<p>虽然结点对测试值很有用，但如果我们想尝试解决这个难题，它们就不那么有用。但是Perl6有另一种类型的集合，可以派上用场。套装（及其相关类型的手袋和混合物）可让您收集物品，然后对其进行数学设定操作，以找出不同套装之间的互动方式。</p>
</div>
<div class="paragraph">
<p>作为一个例子，我们将定义一个可能的函数，它返回给定单元格可能的值。如果单元格具有设置的值，我们将返回空列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">possible</span>( <span class="tok-n">Index</span> <span class="tok-nv">$x</span>, <span class="tok-n">Index</span> <span class="tok-nv">$y</span>, <span class="tok-nv">@game</span> ) {
    <span class="tok-k">return</span> () <span class="tok-k">if</span> <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>] &gt; <span class="tok-mi">0</span>;

    (
        (<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>)
            (-)
        <span class="tok-n">set</span>(
            ( <span class="tok-n">row</span>(<span class="tok-nv">$y</span>).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
            } ).<span class="tok-nb">grep</span>( * &gt; <span class="tok-mi">0</span> ) ),
            ( <span class="tok-n">col</span>(<span class="tok-nv">$x</span>).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
            } ).<span class="tok-nb">grep</span>( * &gt; <span class="tok-mi">0</span> ) ),
            ( <span class="tok-n">square</span>(<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) {
                <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>]
            } ).<span class="tok-nb">grep</span>( * &gt; <span class="tok-mi">0</span> ) )
        )
    ).<span class="tok-nb">keys</span>.<span class="tok-nb">sort</span>;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们发现数字1到9与由给定单元格所在的行，列和平方值组成的集合之间的差异。我们使用grep忽略具有0值的单元格。 As Sets将他们的细节存储为无序的键/值对，我们得到这些键，然后对它们进行排序以保持一致性。请注意，这里我们使用的是运算符的ascii（ - ）版本，我们也可以使用Unicode版本。</p>
</div>
<div class="paragraph">
<p>我们可以将该集合定义为来自行，列和平方的每个结果的并集，并且结果将是相同的。在这种情况下，我们也使用square的两个参数版本。</p>
</div>
<div class="paragraph">
<p>应该指出的是，这是可能值最简单的定义，没有附加的逻辑进行，但即使这个简单的结果，我们也可以做最简单的求解算法。如果是这种情况，我们会在网格中的每个单元格中循环，如果它有1个可能的值，我们可以将该值设置为该值。在这种情况下，我们将循环，获取要设置的单元列表，然后遍历列表并设置值。如果要设置的列表为空或拼图完成，则停止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@updates</span>;
<span class="tok-k">repeat</span> {
    <span class="tok-nv">@updates</span> = (^<span class="tok-mi">9</span> <span class="tok-o">X</span> ^<span class="tok-mi">9</span>).<span class="tok-nb">map</span>( -&gt; (<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>) {
        (<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>) =&gt; <span class="tok-n">possible</span>(<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>,<span class="tok-nv">@game</span>)
    } ).<span class="tok-nb">grep</span>( *.<span class="tok-nb">value</span>.<span class="tok-nb">elems</span> == <span class="tok-mi">1</span> );
    <span class="tok-k">for</span> <span class="tok-nv">@updates</span> -&gt; <span class="tok-nv">$pair</span> {
        <span class="tok-k">my</span> ( <span class="tok-nv">$x</span>, <span class="tok-nv">$y</span> ) = <span class="tok-nv">$pair</span>.<span class="tok-nb">key</span>;
        <span class="tok-nv">@game</span>[<span class="tok-nv">$y</span>][<span class="tok-nv">$x</span>] = <span class="tok-nv">$pair</span>.<span class="tok-nb">value</span>[<span class="tok-mi">0</span>];
    }
} <span class="tok-k">while</span> ( <span class="tok-nv">@updates</span>.<span class="tok-nb">elems</span> &gt; <span class="tok-mi">0</span> &amp;&amp;
          ! [&amp;&amp;] (<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>).<span class="tok-nb">map</span>( <span class="tok-o">so</span> <span class="tok-nv">$complete-all</span> == * ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们列出了对的列表，其中关键是x，y坐标，值是可能的值。然后我们删除所有那些没有一个价值的东西。这一直持续到没有找到具有单个可能值的细胞或者谜题已完成为止。</p>
</div>
<div class="paragraph">
<p>找到解决方案的另一种方法是获得只出现在给定，行，列或方块的一组可能性中的值。例如，如果我们有以下可能性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>(<span class="tok-mi">1</span>,<span class="tok-mi">2</span>,<span class="tok-mi">3</span>),(<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>),(),(),(<span class="tok-mi">4</span>,<span class="tok-mi">5</span>),(),(),(<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>),()</code></pre>
</div>
</div>
<div class="paragraph">
<p>1和5只在每行出现一次。我们可以利用对称集合差分算子和算子链来得到它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> (<span class="tok-mi">1</span>,<span class="tok-mi">2</span>,<span class="tok-mi">3</span>) (^) (<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>) (^) () (^) () (^) (<span class="tok-mi">4</span>,<span class="tok-mi">5</span>) (^) () (^) () (^) (<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>) (^) ()
<span class="tok-n">set</span>(<span class="tok-mi">1</span> <span class="tok-mi">5</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，在这种情况下，我们可以在列表中使用简化元运算符</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> [(^)] (<span class="tok-mi">1</span>,<span class="tok-mi">2</span>,<span class="tok-mi">3</span>),(<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>),(),(),(<span class="tok-mi">4</span>,<span class="tok-mi">5</span>),(),(),(<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">4</span>),()
<span class="tok-n">set</span>(<span class="tok-mi">1</span> <span class="tok-mi">5</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以在这种情况下，算法很简单（在这种情况下，我只是覆盖行，列和方形代码基本相同）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@updates</span>;
<span class="tok-k">for</span> ^<span class="tok-mi">9</span> -&gt; <span class="tok-nv">$idx</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$only</span> = [(^)] <span class="tok-n">row</span>(<span class="tok-nv">$idx</span>).<span class="tok-nb">map</span>( -&gt; ( <span class="tok-nv">$x</span>,<span class="tok-nv">$y</span> ) {
        <span class="tok-n">possible</span>(<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>,<span class="tok-nv">@game</span>)
    } );
    <span class="tok-k">for</span> <span class="tok-nv">$only</span>.<span class="tok-nb">keys</span> -&gt; <span class="tok-nv">$val</span> {
        <span class="tok-k">for</span> <span class="tok-n">row</span>(<span class="tok-nv">$idx</span>) -&gt; (<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>) {
            <span class="tok-k">if</span> <span class="tok-nv">$val</span> (<span class="tok-n">elem</span>) <span class="tok-n">possible</span>(<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>,<span class="tok-nv">@game</span>) {
                <span class="tok-nv">@updates</span>.<span class="tok-nb">push</span>( (<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>) =&gt; <span class="tok-nv">$val</span> );
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以遍历与上面类似的更新数组。结合这两种算法可以自己解决大量的数独难题并简化其他难题。</p>
</div>
<div class="paragraph">
<p>请注意，我们必须进行两次传球，首先我们得到我们正在查找的数字，然后我们必须查看每一行并找出数字出现的位置。为此，我们使用（elem）运算符。集合也可以使用关联引用来引用，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-n">set</span>(<span class="tok-mi">1</span>,<span class="tok-mi">5</span>){<span class="tok-mi">1</span>}
<span class="tok-nb">True</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_关于对象的说明">19.3. 关于对象的说明</h3>
<div class="paragraph">
<p>因此，迄今为止所有的例子都使用了基本整数。但是没有任何东西阻止你在连接和集合中使用对象。有几件事要记住，虽然，集合使用===身份运算符进行测试。大多数对象都不能通过身份检查，除非你已经克隆了它们或者已经定义了WHICH方法以便能够进行比较。</p>
</div>
<div class="paragraph">
<p>对于数独谜题，您可能需要创建一个CellValue类，用于存储该数字是否为谜题中的初始值之一。如果你这样做，尽管你需要覆盖WHICH并使其返回Cell的Integer值。只要你在这种情况下身体检查技术无效（两个不同的CellValues可能具有相同的值，但不会是同一个对象），那么你可以将它们放入集合中。</p>
</div>
<div class="paragraph">
<p>我希望你已经发现了这个有趣的东西，Junctions和Sets是Perl6的许多不同部分中的两个，它们可以帮助你轻松完成复杂的任务。如果您对代码感兴趣，可以使用以下基于对象的版本进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Game::Sudoku</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_perl_6_d_的特性">20. <a href="https://perl6advent.wordpress.com/2017/12/22/day-22-features-of-perl-6-d/">第二十二天-Perl 6.d 的特性</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>所以我们就是这样。 Rakudo Perl 6第一次正式发布两年后，或者更准确的说是6.c。自从马特奥茨从那时起就开始关注性能的提升之后，圣诞老人认为要对此进行对比，描述自那时起实施的6.d的新功能。因为有很多，圣诞老人不得不做出选择。</p>
</div>
<div class="sect2">
<h3 id="_在创建时调整对象">20.1. 在创建时调整对象</h3>
<div class="paragraph">
<p>您创建的任何课程现在都可以使用TWEAK方法。在新的类的新实例的所有其他初始化完成之前，这个方法将被调用。一个简单的，有点人为的例子，其中一个类A有一个属性，默认值是42，但如果在创建对象时指定了默认值，它应该更改该值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">A</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$.value</span> = <span class="tok-mi">42</span>;
    <span class="tok-k">method</span> <span class="tok-n">TWEAK</span>(:<span class="tok-nv">$value</span> = <span class="tok-mi">0</span>) { <span class="tok-c1"># default prevents warning</span>
        <span class="tok-c1"># change the attribute if the default value is specified</span>
        <span class="tok-nv">$!value</span> = <span class="tok-mi">666</span> <span class="tok-k">if</span> <span class="tok-nv">$value</span> == <span class="tok-nv">$!value</span>;
    }
}
<span class="tok-c1"># no value specified, it gets the default attribute value</span>
<span class="tok-n">dd</span> <span class="tok-n">A</span>.<span class="tok-nb">new</span>;              <span class="tok-c1"># A.new(value =&gt; 42)</span>

<span class="tok-c1"># value specified, but it is not the default</span>
<span class="tok-n">dd</span> <span class="tok-n">A</span>.<span class="tok-nb">new</span>(<span class="tok-nb">value</span> =&gt; <span class="tok-mi">77</span>); <span class="tok-c1"># A.new(value =&gt; 77)</span>

<span class="tok-c1"># value specified, and it is the default</span>
<span class="tok-n">dd</span> <span class="tok-n">A</span>.<span class="tok-nb">new</span>(<span class="tok-nb">value</span> =&gt; <span class="tok-mi">42</span>); <span class="tok-c1"># A.new(value =&gt; 666)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并发性改进">20.2. 并发性改进</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Rakudo Perl 6的并发功能在引擎盖下看到了许多改进。其中一些暴露为新功能。最显着的是Lock </dt>
<dd>
<p>Async（一个返回Promise的非阻塞锁）和原子操作符。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在大多数情况下，您不需要直接使用它们，但是如果您正在编写使用并发功能的程序，那么您可能知道原子操作符。经常发生的逻辑错误，特别是如果你在Pumpking Perl 5中使用线程，是因为在Rakudo Perl 6中没有对共享变量的隐式锁定。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$a</span>;
    <span class="tok-n">await</span> (^<span class="tok-mi">5</span>).<span class="tok-n">map:</span> {
        <span class="tok-n">start</span> { ++<span class="tok-nv">$a</span> <span class="tok-k">for</span> ^<span class="tok-mi">100000</span> }
    }
    <span class="tok-nb">say</span> <span class="tok-nv">$a</span>; <span class="tok-c1"># something like 419318</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>那么为什么没有显示500000？原因是我们有5个线程同时递增相同的变量。由于增量由读步骤，增量步骤和写步骤组成，因此一个线程与另一个线程同时执行读取步骤变得非常容易。因此失去了一个增量。在我们有原子操作符之前，做上述代码的正确方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>   <span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$a</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$l</span> = <span class="tok-n">Lock</span>.<span class="tok-nb">new</span>;
    <span class="tok-n">await</span> (^<span class="tok-mi">5</span>).<span class="tok-n">map:</span> {
       <span class="tok-n">start</span> {
           <span class="tok-k">for</span> ^<span class="tok-mi">100000</span> {
               <span class="tok-nv">$l</span>.<span class="tok-n">protect</span>( { ++<span class="tok-nv">$a</span> } )
           }
       }
    }
    <span class="tok-nb">say</span> <span class="tok-nv">$a</span>; <span class="tok-c1"># 500000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这会给你正确的答案，但速度至少要慢20倍。</p>
</div>
<div class="paragraph">
<p>现在我们有了原子变量，上面的代码就变成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>   <span class="tok-k">my</span> <span class="tok-n">atomicint</span> <span class="tok-nv">$a</span>;
    <span class="tok-n">await</span> (^<span class="tok-mi">5</span>).<span class="tok-n">map:</span> {
        <span class="tok-n">start</span> { ++⚛<span class="tok-nv">$a</span> <span class="tok-k">for</span> ^<span class="tok-mi">100000</span> }
    }
    <span class="tok-nb">say</span> <span class="tok-nv">$a</span>; <span class="tok-c1"># 500000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这非常类似于原始（不正确）的代码。这至少是使用Lock.protect的正确代码的6倍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_unicode_goodies">20.3. Unicode goodies</h3>
<div class="paragraph">
<p>太多了，太多了。例如，现在可以使用≤，≥，≠作为Unicode版本的&#8656;，&gt; =和！=（完整列表）。</p>
</div>
<div class="paragraph">
<p>您现在还可以通过指定字形的Unicode名称来创建字形，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-s">&quot;BUTTERFLY&quot;</span>.<span class="tok-n">parse-names</span>; <span class="tok-c1"># 🦋</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在运行时创建Unicode名称字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$t</span> = <span class="tok-s">&quot;THUMBS UP SIGN, EMOJI MODIFIER FITZPATRICK TYPE&quot;</span>;
<span class="tok-nb">print</span> <span class="tok-s">&quot;$t-$_&quot;</span>.<span class="tok-n">parse-names</span> <span class="tok-k">for</span> <span class="tok-mi">3</span><span class="tok-o">..</span><span class="tok-mi">6</span>; <span class="tok-c1"># 👍🏼👍🏽👍🏾👍🏿</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者整理而不是仅仅排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># sort by codepoint value</span>
<span class="tok-nb">say</span> <span class="tok-s">&lt;ä a o ö&gt;</span>.<span class="tok-nb">sort</span>; <span class="tok-c1"># (a o ä ö)</span>
<span class="tok-c1"># sort using Unicode Collation Algorithm</span>
<span class="tok-nb">say</span> <span class="tok-s">&lt;ä a o ö&gt;</span>.<span class="tok-n">collate</span>; <span class="tok-c1"># (a ä o ö)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用unicmp而不是cmp：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-s">&quot;a&quot;</span> <span class="tok-o">cmp</span> <span class="tok-s">&quot;Z&quot;</span>; <span class="tok-c1"># More</span>
<span class="tok-nb">say</span> <span class="tok-s">&quot;a&quot;</span> <span class="tok-n">unicmp</span> <span class="tok-s">&quot;Z&quot;</span>; <span class="tok-c1"># Less</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您现在可以使用任何Unicode数字匹配变量（$ 1为$ 1），负数（-1为-1）和基数基数（：3（“22”）为3（“22”））。</p>
</div>
<div class="paragraph">
<p>圣诞老人认为Rakudo Perl 6拥有世界上任何编程语言的最佳Unicode支持！</p>
</div>
</div>
<div class="sect2">
<h3 id="_跳过值">20.4. 跳过值</h3>
<div class="paragraph">
<p>您现在可以在Seq和Supply上调用.skip跳过正在生成的多个值。与.head和.tail一起，这给了你Iterables和Supplies充足的操作性。</p>
</div>
<div class="paragraph">
<p>顺便说一下，.head现在也会带一个WhateverCode，所以你可以指明除了最后N以外的所有值（例如.head（*  -  3）会给你除了最后三个以外的所有值）。 .tail也是如此（例如.tail（*  -  3）会为您提供除前三个之外的所有值）。</p>
</div>
<div class="paragraph">
<p>对迭代器角色的一些补充使得迭代器可以更好地支持.skip功能。如果一个迭代器可以更有效地跳过一个值而不是实际产生它，它应该实现skip-one方法。派生于此的是可以由迭代器提供的跳过至少和跳过至少拉一个方法。</p>
</div>
<div class="paragraph">
<p>使用.skip查找第1000个素数的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> (^<span class="tok-n">Inf</span>).<span class="tok-nb">grep</span>(*.<span class="tok-n">is-prime</span>)[<span class="tok-mi">999</span>]; <span class="tok-c1"># 7919</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> (^<span class="tok-n">Inf</span>).<span class="tok-nb">grep</span>(*.<span class="tok-n">is-prime</span>).<span class="tok-nb">skip</span>(<span class="tok-mi">999</span>).<span class="tok-n">head</span>; <span class="tok-c1"># 7919</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>后者的CPU效率略高一些，但更重要的是内存效率更高，因为它不需要保留内存中的前999个素数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_of_bufs_and_blobs">20.5. Of Bufs and Blobs</h3>
<div class="paragraph">
<p>Buf变得更像一个Array，因为它现在支持.push，.append，.pop，.unshift，.prepend，.shift和.splice。它也变得更像Str，增加了一个subbuf-rw（类似于.substr-rw），例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$b</span> = <span class="tok-nb">Buf</span>.<span class="tok-nb">new</span>(<span class="tok-mi">100</span><span class="tok-o">..</span><span class="tok-mi">105</span>);
<span class="tok-nv">$b</span>.<span class="tok-n">subbuf-rw</span>(<span class="tok-mi">2</span>,<span class="tok-mi">3</span>) = <span class="tok-nb">Blob</span>.<span class="tok-nb">new</span>(^<span class="tok-mi">5</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$b</span>.<span class="tok-nb">perl</span>; <span class="tok-c1"># Buf.new(100,101,0,1,2,3,4,105)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您现在也可以使用给定数量的元素和模式来分配Buf或Blob。或者用.reallocate改变Buf的大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$b</span> = <span class="tok-nb">Buf</span>.<span class="tok-n">allocate</span>(<span class="tok-mi">10</span>,(<span class="tok-mi">1</span>,<span class="tok-mi">2</span>,<span class="tok-mi">3</span>));
<span class="tok-nb">say</span> <span class="tok-nv">$b</span>.<span class="tok-nb">perl</span>; <span class="tok-c1"># Buf.new(1,2,3,1,2,3,1,2,3,1)</span>
<span class="tok-nv">$b</span>.<span class="tok-n">reallocate</span>(<span class="tok-mi">5</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$b</span>.<span class="tok-nb">perl</span>; <span class="tok-c1"># Buf.new(1,2,3,1,2)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试测试测试">20.6. 测试，测试，测试！</h3>
<div class="paragraph">
<p>Test.pm的计划子例程现在还采用可选的：skip-all参数来指示文件中的所有测试都应该跳过。或者您可以拨打救助中止测试运行，将其标记为失败。或者将PERL6_TEST_DIE_ON_FAIL环境变量设置为真值，以指示您希望测试一旦第一次测试失败就立即结束。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这是怎么回事">20.7. 这是怎么回事</h3>
<div class="paragraph">
<p>您现在可以通过调用Kernel.cpu-cores来反思计算机中CPU内核的数量。程序启动后使用的CPU数量在Kernel.cpu-usage中可用，但您可以使用VM.osname轻松检查操作系统的名称。</p>
</div>
<div class="paragraph">
<p>就好像这还不够，还有一个新的遥测模块，您需要在需要时加载，就像测试模块一样。遥测模块提供了许多可直接使用的基元，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Telemetry</span>;
<span class="tok-nb">say</span> <span class="tok-n">T</span><span class="tok-s">&lt;wallclock cpu max-rss&gt;</span>; <span class="tok-c1"># (138771 280670 82360)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它显示自程序启动以来的微秒数，所用CPU的微秒数以及调用时正在使用的内存数量。</p>
</div>
<div class="paragraph">
<p>如果你想得到你的程序中发生的事情的报告，你可以使用管理单元，并在程序完成时显示报告。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Telemetry</span>;
<span class="tok-n">snap</span>;
<span class="tok-n">Nil</span> <span class="tok-k">for</span> ^<span class="tok-mi">10000000</span>;  <span class="tok-c1"># something that takes a bit of time</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果将显示在STDERR上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Telemetry</span> <span class="tok-n">Report</span> <span class="tok-k">of</span> <span class="tok-n">Process</span> <span class="tok-c1">#60076</span>
<span class="tok-n">Number</span> <span class="tok-k">of</span> <span class="tok-n">Snapshots:</span> <span class="tok-mi">2</span>
<span class="tok-n">Initial</span><span class="tok-o">/</span><span class="tok-n">Final</span> <span class="tok-n">Size:</span> <span class="tok-mi">82596</span> / <span class="tok-mi">83832</span> <span class="tok-n">Kbytes</span>
<span class="tok-n">Total</span> <span class="tok-n">Time:</span>           <span class="tok-mf">0.55</span> <span class="tok-n">seconds</span>
<span class="tok-n">Total</span> <span class="tok-n">CPU</span> <span class="tok-n">Usage:</span>      <span class="tok-mf">0.56</span> <span class="tok-n">seconds</span>
<span class="tok-n">No</span> <span class="tok-n">supervisor</span> <span class="tok-n">thread</span> <span class="tok-k">has</span> <span class="tok-n">been</span> <span class="tok-n">running</span>

<span class="tok-n">wallclock</span>  <span class="tok-n">util</span>%  <span class="tok-o">max-</span><span class="tok-n">rss</span>
   <span class="tok-mi">549639</span>  <span class="tok-mf">12.72</span>     <span class="tok-mi">1236</span>
--------- ------ --------
   <span class="tok-mi">549639</span>  <span class="tok-mf">12.72</span>     <span class="tok-mi">1236</span>

<span class="tok-n">Legend:</span>
<span class="tok-n">wallclock</span>  <span class="tok-n">Number</span> <span class="tok-k">of</span> <span class="tok-n">microseconds</span> <span class="tok-n">elapsed</span>
    <span class="tok-n">util</span>%  <span class="tok-n">Percentage</span> <span class="tok-k">of</span> <span class="tok-n">CPU</span> <span class="tok-n">utilization</span> (<span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">100</span>%)
  <span class="tok-o">max-</span><span class="tok-n">rss</span>  <span class="tok-n">Maximum</span> <span class="tok-n">resident</span> <span class="tok-n">set</span> <span class="tok-n">size</span> (<span class="tok-n">in</span> <span class="tok-n">Kbytes</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想要每秒1次的程序状态，你可以使用snapper：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Telemetry</span>;
<span class="tok-n">snapper</span>;
<span class="tok-n">Nil</span> <span class="tok-k">for</span> ^<span class="tok-mi">10000000</span>;  <span class="tok-c1"># something that takes a bit of time</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Telemetry</span> <span class="tok-n">Report</span> <span class="tok-k">of</span> <span class="tok-n">Process</span> <span class="tok-c1">#60722</span>
<span class="tok-n">Number</span> <span class="tok-k">of</span> <span class="tok-n">Snapshots:</span> <span class="tok-mi">7</span>
<span class="tok-n">Initial</span><span class="tok-o">/</span><span class="tok-n">Final</span> <span class="tok-n">Size:</span> <span class="tok-mi">87324</span> / <span class="tok-mi">87484</span> <span class="tok-n">Kbytes</span>
<span class="tok-n">Total</span> <span class="tok-n">Time:</span>           <span class="tok-mf">0.56</span> <span class="tok-n">seconds</span>
<span class="tok-n">Total</span> <span class="tok-n">CPU</span> <span class="tok-n">Usage:</span>      <span class="tok-mf">0.57</span> <span class="tok-n">seconds</span>
<span class="tok-n">No</span> <span class="tok-n">supervisor</span> <span class="tok-n">thread</span> <span class="tok-k">has</span> <span class="tok-n">been</span> <span class="tok-n">running</span>

<span class="tok-n">wallclock</span>  <span class="tok-n">util</span>%  <span class="tok-o">max-</span><span class="tok-n">rss</span>
   <span class="tok-mi">103969</span>  <span class="tok-mf">13.21</span>      <span class="tok-mi">152</span>
   <span class="tok-mi">101175</span>  <span class="tok-mf">12.48</span>
   <span class="tok-mi">101155</span>  <span class="tok-mf">12.48</span>
   <span class="tok-mi">104097</span>  <span class="tok-mf">12.51</span>
   <span class="tok-mi">105242</span>  <span class="tok-mf">12.51</span>
    <span class="tok-mi">44225</span>  <span class="tok-mf">12.51</span>        <span class="tok-mi">8</span>
--------- ------ --------
   <span class="tok-mi">559863</span>  <span class="tok-mf">12.63</span>      <span class="tok-mi">160</span>

<span class="tok-n">Legend:</span>
<span class="tok-n">wallclock</span>  <span class="tok-n">Number</span> <span class="tok-k">of</span> <span class="tok-n">microseconds</span> <span class="tok-n">elapsed</span>
    <span class="tok-n">util</span>%  <span class="tok-n">Percentage</span> <span class="tok-k">of</span> <span class="tok-n">CPU</span> <span class="tok-n">utilization</span> (<span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">100</span>%)
  <span class="tok-o">max-</span><span class="tok-n">rss</span>  <span class="tok-n">Maximum</span> <span class="tok-n">resident</span> <span class="tok-n">set</span> <span class="tok-n">size</span> (<span class="tok-n">in</span> <span class="tok-n">Kbytes</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有更多选项可用，例如以.csv格式获取输出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_函数">20.8. MAIN 函数</h3>
<div class="paragraph">
<p>您现在可以通过设置％* SUB-MAIN-OPTS中的选项来修改MAIN参数的处理方式。默认的USAGE消息现在可以在MAIN中作为$ * USAGE动态变量使用，所以如果你愿意，你可以改变它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_嵌入_perl_6">20.9. 嵌入 Perl 6</h3>
<div class="paragraph">
<p>两个新功能使嵌入Rakudo Perl 6更易于处理：
现在可以设置＆* EXIT动态变量来指定调用exit（）时要执行的操作。</p>
</div>
<div class="paragraph">
<p>将环境变量RAKUDO_EXCEPTIONS_HANDLER设置为“JSON”将引发JSON中的异常，而不是文本，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">RAKUDO_EXCEPTIONS_HANDLER</span>=<span class="tok-n">JSON</span> <span class="tok-n">perl6</span> -<span class="tok-n">e</span> <span class="tok-s">&#39;42 = 666&#39;</span>
{
  <span class="tok-s">&quot;X::Assignment::RO&quot;</span> : {
    <span class="tok-s">&quot;value&quot;</span> : <span class="tok-mi">42</span>,
    <span class="tok-s">&quot;message&quot;</span> : <span class="tok-s">&quot;Cannot modify an immutable Int (42)&quot;</span>
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_礼品袋的底部">20.10. 礼品袋的底部</h3>
<div class="paragraph">
<p>在翻看仍然相当完整的礼品袋的同时，圣诞老人发现了以下较小的惊悚片：</p>
</div>
<div class="paragraph">
<p>本地字符串数组现在实现（我的str @a）
IO :: CatHandle允许您将多个数据源抽象为单个虚拟IO :: Handle
parse-base（）执行base（）的相反操作</p>
</div>
</div>
<div class="sect2">
<h3 id="_赶上雪橇的时间">20.11. 赶上雪橇的时间</h3>
<div class="paragraph">
<p>圣诞老人想留下来告诉你更多有关已添加的内容，但是没有足够的时间来做到这一点。如果您真的想了解新功能的最新情况，您应该查看Changelog中的Additions部分，这些部分随每个Rakudo编译器版本一起更新。</p>
</div>
<div class="paragraph">
<p>所以，明年再来抓你！</p>
</div>
<div class="paragraph">
<p>来自美好的祝福</p>
</div>
<div class="paragraph">
<p>🎅🏾</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_perl_6_高尔夫">21. <a href="https://perl6advent.wordpress.com/2017/12/23/day-23-the-wonders-of-perl6-golf/">第二十三天-Perl 6 高尔夫</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>啊，圣诞节！还有什么比和你的朋友与家人一起坐在桌子旁边玩高尔夫球代码还好呢！ &#8230;&#8203;等等，什么？</p>
</div>
<div class="paragraph">
<p>哦，对，这还不是圣诞节。但是你可能想要为它做好准备！</p>
</div>
<div class="paragraph">
<p>如果你还没有注意到，有一个不错的网站可以玩高尔夫球代码：<a href="https://code-golf.io/">https://code-golf.io/</a>。这个网站很酷的地方是，它不仅仅只支持 perl 6！在撰写本文时，它还支持其他 6 种语言。嗯&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>无论如何，因为我在那个网站的成绩还不错，我会分享一些我觉得最好的解决方案。所有的 trickety-hackety，unicode-cheatery 和 mind-blowety。在我们看来，也许我们甚至会看到即使在代码高尔夫中，perl 6 也非常<a href="https://raw.githubusercontent.com/perl6/marketing/master/TablePosters/6lang-Concise/v1&#8212;&#8203;6lang-Concise&#8212;&#8203;square.png">简洁</a>易读。也就是说，如果你很难将你的圣诞愿望放在一张卡片上，那么可能会放得下一行 perl 6 代码。</p>
</div>
<div class="paragraph">
<p>我不会提供完整的解决方案，不会破坏你的圣诞乐趣，但我会给你足够的提示，以提出有竞争力的解决方案。</p>
</div>
<div class="paragraph">
<p>这个圣诞节我就是想让你得到一些乐趣。所以你先下载一份 <a href="https://perl6.org/downloads/">rakudo</a>，以确保你可以跟随。稍后我们会有一些南瓜派，我们会<a href="https://www.youtube.com/watch?v=Y51JyG7M3dw#t=26s">做一些颂歌</a>。如果您在运行 perl 6 时遇到任何问题，可以在 freenode 上加入 <a href="https://docs.perl6.org/webchat.html">＃perl6 频道</a>以获得一些帮助。这就是说，<a href="https://code-golf.io/">https://code-golf.io/</a> 本身为你提供了一个很好的编辑器来编写和评估你的代码，所以应该没有问题。</p>
</div>
<div class="sect2">
<h3 id="_一些基本的例子">21.1. 一些基本的例子</h3>
<div class="paragraph">
<p>让我们以<a href="https://code-golf.io/pascals-triangle">帕斯卡三角形</a>任务为例。我听到了，我听到了！圣诞节前的数学，这太残酷了。残忍，但很有必要。</p>
</div>
<div class="paragraph">
<p>只有一个你必须知道的基本技巧。如果从 Pascal 三角形中取出任何一行，将它移动一个元素，然后用原始行对结果进行 zip-sum，就会得到下一行！</p>
</div>
<div class="paragraph">
<p>所以如果你有一行数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你所做的只是把它移到右边：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>并将其与原始行相加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span>
+ + + +
<span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span>
=
<span class="tok-mi">1</span> <span class="tok-mi">4</span> <span class="tok-mi">6</span> <span class="tok-mi">4</span> <span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>就是如此容易！所以我们还是写代码吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">for</span> ^<span class="tok-mi">16</span> { <span class="tok-n">put</span> (+<span class="tok-n">combinations</span>(<span class="tok-nv">$^row</span>,<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-mi">0</span>..<span class="tok-nv">$row</span>) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你看！简单的很！</p>
</div>
<div class="paragraph">
<p>哦&#8230;&#8203;&#8230;&#8203;等等，这有一个完全不同的解决方案。好吧，让我们来看看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>.<span class="tok-n">put</span> <span class="tok-k">for</span> <span class="tok-mi">1</span>, { |<span class="tok-nv">$_</span>,<span class="tok-mi">0</span> <span class="tok-o">Z</span>+ <span class="tok-mi">0</span>,|<span class="tok-nv">$_</span> } ... <span class="tok-mi">16</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">4</span> <span class="tok-mi">6</span> <span class="tok-mi">4</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">5</span> <span class="tok-mi">10</span> <span class="tok-mi">10</span> <span class="tok-mi">5</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">6</span> <span class="tok-mi">15</span> <span class="tok-mi">20</span> <span class="tok-mi">15</span> <span class="tok-mi">6</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">7</span> <span class="tok-mi">21</span> <span class="tok-mi">35</span> <span class="tok-mi">35</span> <span class="tok-mi">21</span> <span class="tok-mi">7</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">8</span> <span class="tok-mi">28</span> <span class="tok-mi">56</span> <span class="tok-mi">70</span> <span class="tok-mi">56</span> <span class="tok-mi">28</span> <span class="tok-mi">8</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">9</span> <span class="tok-mi">36</span> <span class="tok-mi">84</span> <span class="tok-mi">126</span> <span class="tok-mi">126</span> <span class="tok-mi">84</span> <span class="tok-mi">36</span> <span class="tok-mi">9</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">10</span> <span class="tok-mi">45</span> <span class="tok-mi">120</span> <span class="tok-mi">210</span> <span class="tok-mi">252</span> <span class="tok-mi">210</span> <span class="tok-mi">120</span> <span class="tok-mi">45</span> <span class="tok-mi">10</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">11</span> <span class="tok-mi">55</span> <span class="tok-mi">165</span> <span class="tok-mi">330</span> <span class="tok-mi">462</span> <span class="tok-mi">462</span> <span class="tok-mi">330</span> <span class="tok-mi">165</span> <span class="tok-mi">55</span> <span class="tok-mi">11</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">12</span> <span class="tok-mi">66</span> <span class="tok-mi">220</span> <span class="tok-mi">495</span> <span class="tok-mi">792</span> <span class="tok-mi">924</span> <span class="tok-mi">792</span> <span class="tok-mi">495</span> <span class="tok-mi">220</span> <span class="tok-mi">66</span> <span class="tok-mi">12</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">13</span> <span class="tok-mi">78</span> <span class="tok-mi">286</span> <span class="tok-mi">715</span> <span class="tok-mi">1287</span> <span class="tok-mi">1716</span> <span class="tok-mi">1716</span> <span class="tok-mi">1287</span> <span class="tok-mi">715</span> <span class="tok-mi">286</span> <span class="tok-mi">78</span> <span class="tok-mi">13</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">14</span> <span class="tok-mi">91</span> <span class="tok-mi">364</span> <span class="tok-mi">1001</span> <span class="tok-mi">2002</span> <span class="tok-mi">3003</span> <span class="tok-mi">3432</span> <span class="tok-mi">3003</span> <span class="tok-mi">2002</span> <span class="tok-mi">1001</span> <span class="tok-mi">364</span> <span class="tok-mi">91</span> <span class="tok-mi">14</span> <span class="tok-mi">1</span>
<span class="tok-mi">1</span> <span class="tok-mi">15</span> <span class="tok-mi">105</span> <span class="tok-mi">455</span> <span class="tok-mi">1365</span> <span class="tok-mi">3003</span> <span class="tok-mi">5005</span> <span class="tok-mi">6435</span> <span class="tok-mi">6435</span> <span class="tok-mi">5005</span> <span class="tok-mi">3003</span> <span class="tok-mi">1365</span> <span class="tok-mi">455</span> <span class="tok-mi">105</span> <span class="tok-mi">15</span> <span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>啊哈！ 我们做到了。 所以究竟是怎么回事儿？ 那么，在 perl 6 中，你可以用一个非常简单的语法创建 <code>2,4,8 &#8230;&#8203; ∞</code> 这样的序列。 通常你会让它自己计算序列，但你也可以提供一个代码块来求值。 这太棒了！ 在其他语言中，你经常需要一个带有状态变量的循环，而序列操作符为你做了所有的事情！ 这个功能可能单独需要一篇<a href="https://perl6.party/post/Perl-6-Seqs-Drugs-and-Rock-n-Roll">文章</a>或<a href="https://perl6.party/post/Perl-6-Seqs-Drugs-and-Rock-n-Roll&#8212;&#8203;Part-2">𝍪</a>。</p>
</div>
<div class="paragraph">
<p>其余的只是一个 for 循环和 <a href="https://docs.perl6.org/routine/put">put</a> 调用。 这里唯一的技巧就是理解它使用的是列表，所以当你指定序列的端点时，它实际上是检查元素的数量。 另外，您需要用 <code>|</code> 来展平列表。</p>
</div>
<div class="paragraph">
<p>如果删除空格并应用本文中提到的所有技巧，这应该会让您的字符数为 26。 这相当有竞争力。</p>
</div>
<div class="paragraph">
<p>同样，其他任务通常有相当直接的解决方案。 例如，对于 <a href="https://code-golf.io/evil-numbers">Evil NUmbers</a>，你可以写这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>.<span class="tok-n">base</span>(<span class="tok-mi">2</span>).<span class="tok-nb">comb</span>(~<span class="tok-mi">1</span>) %% <span class="tok-mi">2</span> &amp;&amp; .<span class="tok-nb">say</span> <span class="tok-k">for</span> ^<span class="tok-mi">50</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>删除一些空格，应用一些技巧，你几乎就达到要求了。</p>
</div>
<div class="paragraph">
<p>我们再举一个例子：<a href="https://code-golf.io/pangram-grep">Pangram Grep</a>。在这里我们可以使用 <a href="https://docs.perl6.org/language/setbagmix">set操作符</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>‘<span class="tok-n">a</span>’..‘<span class="tok-n">z</span>’ ⊆ .<span class="tok-nb">lc</span>.<span class="tok-nb">comb</span> &amp;&amp; .<span class="tok-nb">say</span> <span class="tok-k">for</span> <span class="tok-vg">@*ARGS</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>基本上，几乎所有的 perl 6 解决方案看起来都是真正的代码。这是额外的-1角色，需要额外的眼睛疼痛，但你没有来这里听简洁，对吧？是时候变脏了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_numbers">21.2. Numbers</h3>
<div class="paragraph">
<p>让我们来谈谈数字吧！ 1 ² ③ ٤ ⅴ ߆…  <strong>咳嗽</strong>。 你看，在 perl 6 中，任何数字字符（具有相应的数值属性）都可以在源代码中使用。 该功能的目的是让我们得到一些好处，如 ½ 和其他整洁的东西，但这意味着，而不是写 50 你可以写 ㊿。 有些高尔夫平台会以 UTF-8 编码来计算字节数，所以看起来你没有赢得任何东西。 但是 <code>1000000000000</code> 和 ` 𖭡` 呢？ 在任何情况下，<a href="https://code-golf.io/">code-golf.io</a> 都可以识别 unicode，所以这些字符的长度都是 1。</p>
</div>
<div class="paragraph">
<p>所以你可能会想，你能用这种方式写出哪些数字？ 你试试看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>-<span class="tok-mf">0.5</span> <span class="tok-mf">0.00625</span> <span class="tok-mf">0.025</span> <span class="tok-mf">0.0375</span> <span class="tok-mf">0.05</span> <span class="tok-mf">0.0625</span> <span class="tok-mf">0.083333</span> <span class="tok-mf">0.1</span>
<span class="tok-mf">0.111111</span> <span class="tok-mf">0.125</span> <span class="tok-mf">0.142857</span> <span class="tok-mf">0.15</span> <span class="tok-mf">0.166667</span> <span class="tok-mf">0.1875</span> <span class="tok-mf">0.2</span>
<span class="tok-mf">0.25</span> <span class="tok-mf">0.333333</span> <span class="tok-mf">0.375</span> <span class="tok-mf">0.4</span> <span class="tok-mf">0.416667</span> <span class="tok-mf">0.5</span> <span class="tok-mf">0.583333</span> <span class="tok-mf">0.6</span>
<span class="tok-mf">0.625</span> <span class="tok-mf">0.666667</span> <span class="tok-mf">0.75</span> <span class="tok-mf">0.8</span> <span class="tok-mf">0.833333</span> <span class="tok-mf">0.875</span> <span class="tok-mf">0.916667</span> <span class="tok-mi">1</span>
<span class="tok-mf">1.5</span> <span class="tok-mi">2</span> <span class="tok-mf">2.5</span> <span class="tok-mi">3</span> <span class="tok-mf">3.5</span> <span class="tok-mi">4</span> <span class="tok-mf">4.5</span> <span class="tok-mi">5</span> <span class="tok-mf">5.5</span> <span class="tok-mi">6</span> <span class="tok-mf">6.5</span> <span class="tok-mi">7</span> <span class="tok-mf">7.5</span> <span class="tok-mi">8</span> <span class="tok-mf">8.5</span> <span class="tok-mi">9</span> <span class="tok-mi">10</span>
<span class="tok-mi">11</span> <span class="tok-mi">12</span> <span class="tok-mi">13</span> <span class="tok-mi">14</span> <span class="tok-mi">15</span> <span class="tok-mi">16</span> <span class="tok-mi">17</span> <span class="tok-mi">18</span> <span class="tok-mi">19</span> <span class="tok-mi">20</span> <span class="tok-mi">21</span> <span class="tok-mi">22</span> <span class="tok-mi">23</span> <span class="tok-mi">24</span> <span class="tok-mi">25</span> <span class="tok-mi">26</span> <span class="tok-mi">27</span>
<span class="tok-mi">28</span> <span class="tok-mi">29</span> <span class="tok-mi">30</span> <span class="tok-mi">31</span> <span class="tok-mi">32</span> <span class="tok-mi">33</span> <span class="tok-mi">34</span> <span class="tok-mi">35</span> <span class="tok-mi">36</span> <span class="tok-mi">37</span> <span class="tok-mi">38</span> <span class="tok-mi">39</span> <span class="tok-mi">40</span> <span class="tok-mi">41</span> <span class="tok-mi">42</span> <span class="tok-mi">43</span> <span class="tok-mi">44</span>
<span class="tok-mi">45</span> <span class="tok-mi">46</span> <span class="tok-mi">47</span> <span class="tok-mi">48</span> <span class="tok-mi">49</span> <span class="tok-mi">50</span> <span class="tok-mi">60</span> <span class="tok-mi">70</span> <span class="tok-mi">80</span> <span class="tok-mi">90</span> <span class="tok-mi">100</span> <span class="tok-mi">200</span> <span class="tok-mi">300</span> <span class="tok-mi">400</span> <span class="tok-mi">500</span>
<span class="tok-mi">600</span> <span class="tok-mi">700</span> <span class="tok-mi">800</span> <span class="tok-mi">900</span> <span class="tok-mi">1000</span> <span class="tok-mi">2000</span> <span class="tok-mi">3000</span> <span class="tok-mi">4000</span> <span class="tok-mi">5000</span> <span class="tok-mi">6000</span> <span class="tok-mi">7000</span>
<span class="tok-mi">8000</span> <span class="tok-mi">9000</span> <span class="tok-mi">10000</span> <span class="tok-mi">20000</span> <span class="tok-mi">30000</span> <span class="tok-mi">40000</span> <span class="tok-mi">50000</span> <span class="tok-mi">60000</span> <span class="tok-mi">70000</span>
<span class="tok-mi">80000</span> <span class="tok-mi">90000</span> <span class="tok-mi">100000</span> <span class="tok-mi">200000</span> <span class="tok-mi">216000</span> <span class="tok-mi">300000</span> <span class="tok-mi">400000</span>
<span class="tok-mi">432000</span> <span class="tok-mi">500000</span> <span class="tok-mi">600000</span> <span class="tok-mi">700000</span> <span class="tok-mi">800000</span> <span class="tok-mi">900000</span> <span class="tok-mi">1000000</span>
<span class="tok-mi">100000000</span> <span class="tok-mi">10000000000</span> <span class="tok-mi">1000000000000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着，例如，在某些情况下，如果需要否定结果，则可以节省 1 个字符。有很多方法可以使用，我只会提到一个特定的情况。其余的你自己去找，以及如何找到可用于任何特定值的实际字符（提示：循环所有 0x10FFFF 字符并检查它们的 `.unival`s）。</p>
</div>
<div class="paragraph">
<p>例如，当打高尔夫时，你想略去不必要的空白，所以也许你会想写一些这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-mi">5</span><span class="tok-n">max3</span>  <span class="tok-c1"># ERROR</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这当然不起作用，我们也不能责怪编译器没有解决这个混乱问题。但是，试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-n">⑤max③</span>  <span class="tok-c1"># OUTPUT: «5␤»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>哇噢！这在许多其他情况下会起作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_条件">21.3. 条件</h3>
<div class="paragraph">
<p>如果有很好的高尔夫语言，但不是 Perl 6. 我的意思是，看看这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ruby"><span></span><span class="tok-nb">puts</span> <span class="tok-mi">10</span><span class="tok-o">&lt;</span><span class="tok-mi">30</span><span class="tok-o">?</span><span class="tok-mi">1</span><span class="tok-p">:</span><span class="tok-mi">2</span>   <span class="tok-c1"># ruby</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-mi">10</span> &lt;<span class="tok-mi">30</span><span class="tok-o">??</span><span class="tok-mi">1</span><span class="tok-o">!!</span><span class="tok-mi">2</span> <span class="tok-c1"># perl 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 6 的三元操作符不仅多需要俩个字符，而且 <code>&lt;</code> 运算符周围还要有一些必要的的空白字符！他们有什么问题，对吧？他们怎么敢设计一种无代码高尔夫语言?!</p>
</div>
<div class="paragraph">
<p>那么，我们可以通过某些方法解决它。其中之一是链式操作符。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-mi">5</span><span class="tok-o">&gt;</span><span class="tok-mi">3</span><span class="tok-o">&gt;</span><span class="tok-nb">say</span>(<span class="tok-mi">42</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 5≤3，则不需要进行其他比较，因此它不会运行它。这样我们可以节省至少一个字符。在略有相关的说明中，请记住，junctions 也可能派上用场：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> ‘<span class="tok-n">yes</span>!’ <span class="tok-k">if</span> <span class="tok-mi">5</span><span class="tok-o">==</span><span class="tok-mi">3</span><span class="tok-o">|</span><span class="tok-mi">5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，不要忘记 unicode 操作符：<code>≥</code>，<code>≤</code>，<code>≠</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_打字很难让我们使用一些预定义的字符串">21.4. 打字很难，让我们使用一些预定义的字符串！</h3>
<div class="paragraph">
<p>你不会相信这有时是多么的有用。想要打印所有棋子的名字？好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> (‘♔’…‘♙’)».<span class="tok-n">uniname</span>».<span class="tok-n">words</span>»[<span class="tok-mi">2</span>]
<span class="tok-c1">#   KING QUEEN ROOK BISHOP KNIGHT PAWN</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这仅仅节省了几个字符，但有时可以将解决方案的大小减半。但是，不要停在那里，想想错误消息，方法名称等。你还能挽回什么？</p>
</div>
</div>
<div class="sect2">
<h3 id="_base_16_base_36_nah_base_0x10ffff">21.5. Base 16? Base 36? Nah, Base 0x10FFFF!</h3>
<div class="paragraph">
<p><a href="https://code-golf.io/φ">其中一项任务</a>告诉我们打印 φ 的前1000个小数位。那么，这很容易！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> ‘<span class="tok-mf">1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374847540880753868917521266338622235369317931800607667263544333890865959395829056383226613199282902678806752087668925017116962070322210432162695486262963136144381497587012203408058879544547492461856953648644492410443207713449470495658467885098743394422125448770664780915884607499887124007652170575179788341662562494075890697040002812104276217711177780531531714101170466659914669798731761356006708748071013179523689427521948435305678300228785699782977834784587822891109762500302696156170025046433824377648610283831268330372429267526311653392473167111211588186385133162038400522216579128667529465490681131715993432359734949850904094762132229810172610705961164562990981629055520852479035240602017279974717534277759277862561943208275051312181562855122248093947123414517022373580577278616008688382952304592647878017889921990270776903895321968198615143780314997411069260886742962267575605231727775203536139362</span>’</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的！！！</p>
</div>
<div class="paragraph">
<p>好吧，这需要 1000 多个字符&#8230;&#8203;&#8230;&#8203;当然，我们可以尝试计算它，但这不完全符合<a href="https://perl6advent.wordpress.com/2017/12/01/">圣诞节的精神</a>。我们想作弊。</p>
</div>
<div class="paragraph">
<p>如果我们看一下 <a href="https://docs.perl6.org/type/Int#method_polymod">polymod</a> 的文档，有一点提示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@digits-in-base37</span> = <span class="tok-mi">9123607</span>.<span class="tok-n">polymod</span>(<span class="tok-mi">37</span> <span class="tok-o">xx</span> *); <span class="tok-c1"># Base conversion</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯&#8230;&#8203;&#8230;&#8203;这样就给了我们任意数量的数字。我们可以走多高？那么，这取决于我们想要存储数字的形式。鉴于 code-golf.io 计算码位，我们可以使用base 0x10FFFF（即使用所有可用的码位）。或者，在这种情况下，我们将使用base 0x10FFFE，<a href="https://docs.perl6.org/language/traps#All_Text_is_Normalized_By_Default">因为</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>☠☠☠⚠⚠⚠ <span class="tok-n">WARNING</span>! <span class="tok-n">WARNING</span>! <span class="tok-n">WARNING</span>! ⚠⚠⚠☠☠☠
<span class="tok-n">THIS</span> <span class="tok-n">WILL</span> <span class="tok-n">MAKE</span> <span class="tok-n">YOUR</span> <span class="tok-n">COMPUTER</span> <span class="tok-n">IMPLODE</span>!
<span class="tok-n">UNICODE</span> <span class="tok-n">STRINGS</span> <span class="tok-n">ARE</span> <span class="tok-n">SUBJECT</span> <span class="tok-n">TO</span> <span class="tok-n">NORMALIZATION</span> <span class="tok-n">SO</span> <span class="tok-n">YOUR</span>
<span class="tok-n">DATA</span> <span class="tok-n">WILL</span> <span class="tok-n">NOT</span> <span class="tok-n">BE</span> <span class="tok-n">PRESERVED</span>. <span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span> <span class="tok-n">KIDS</span>, <span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span>
<span class="tok-n">WIFE</span>. <span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span> <span class="tok-n">KIDS</span>, <span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span> <span class="tok-n">WIFE</span>. <span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span> <span class="tok-n">KIDS</span>,
<span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span> <span class="tok-n">WIFE</span>. <span class="tok-n">AND</span> <span class="tok-n">HIDE</span> <span class="tok-n">YOUR</span> <span class="tok-n">HUSBAND</span>.
☠☠☠⚠⚠⚠ <span class="tok-n">WARNING</span>! <span class="tok-n">WARNING</span>! <span class="tok-n">WARNING</span>! ⚠⚠⚠☠☠☠</code></pre>
</div>
</div>
<div class="paragraph">
<p>当应用于我们的常数时，它应该给出这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>󻁾񤍠򷒋󜹕󘶸񙦅񨚑򙯬񗈼𢍟𪱷򡀋𢕍򌠐񘦵𔇆򅳒򑠒󌋩򯫞򶝠򚘣򣥨񫵗𿞸􋻩񱷳󟝐󮃞󵹱񿢖𛒕𺬛󊹛󲝂򺗝𭙪񰕺𝧒򊕆𘝞<span class="tok-n">뎛</span>􆃂򊥍񲽤򩻛󂛕<span class="tok-n">磪</span>󡯮<span class="tok-n">끝</span>򰯬󢽈󼿶󘓥򮀓񽑖򗔝󃢖񶡁􁇘󶪼񌍌񛕄񻊺򔴩<span class="tok-n">寡</span>񿜾񿸶򌰘񡇈򦬽𥵑󧨑򕩃򳴪񾖾򌯎󿥐񱛦𱫞𵪶򁇐󑓮򄨠򾎹𛰑𗋨<span class="tok-n">䨀</span>򡒶𰌡򶟫񦲋𧮁􍰍񲍚񰃦𦅂󎓜󸾧󉦩󣲦򄉼񿒣𸖉񿡥󬯞<span class="tok-n">嗟</span>𧽘񿷦򠍍🼟򇋹񖾷𖏕񟡥󜋝􋯱񤄓򭀢򌝓𱀉𫍡󬥝򈘏򞏡񄙍𪏸࿹𺐅񢻳򘮇𐂇񘚡<span class="tok-n">ந</span>򾩴󜆵𰑕򰏷񛉿򢑬򭕴𨬎󴈂􋵔򆀍񖨸􂳚󽡂󎖪񡉽񕧣񎗎򝤉򡔙񆔈󖾩󅾜񋩟򝼤񯓦󐚉񟯶򄠔𦔏򲔐<span class="tok-n">o</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们如何翻转操作？在其中一次 <a href="https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day">squashathons</a> 我找到一张关于我以前不知道的功能的票。基本上，票据说 Rakudo 正在做它不应该做的事情，这当然是我们下一次会被滥用的事情。但现在我们处于相对理智的范围之内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> ‘<span class="tok-mi">1</span>.’,:<span class="tok-mi">1114110</span>[‘<span class="tok-n">o</span>򲔐𦔏򄠔񟯶󐚉񯓦򝼤񋩟󅾜󖾩񆔈򡔙򝤉񎗎񕧣񡉽󎖪󽡂􂳚񖨸򆀍􋵔󴈂𨬎򭕴򢑬񛉿򰏷𰑕󜆵򾩴<span class="tok-n">ந</span>񘚡𐂇򘮇񢻳𺐅࿹𪏸񄙍򞏡򈘏󬥝𫍡𱀉򌝓򭀢񤄓􋯱󜋝񟡥𖏕񖾷򇋹🼟򠍍񿷦𧽘<span class="tok-n">嗟</span>󬯞񿡥𸖉񿒣򄉼󣲦󉦩󸾧󎓜𦅂񰃦񲍚􍰍𧮁񦲋򶟫𰌡򡒶<span class="tok-n">䨀</span>𗋨𛰑򾎹򄨠󑓮򁇐𵪶𱫞񱛦󿥐򌯎񾖾򳴪򕩃󧨑𥵑򦬽񡇈򌰘񿸶񿜾<span class="tok-n">寡</span>򔴩񻊺񛕄񌍌󶪼􁇘񶡁󃢖򗔝񽑖򮀓󘓥󼿶󢽈򰯬<span class="tok-n">끝</span>󡯮<span class="tok-n">磪</span>󂛕򩻛񲽤򊥍􆃂<span class="tok-n">뎛</span>𘝞򊕆𝧒񰕺𭙪򺗝󲝂󊹛𺬛𛒕񿢖󵹱󮃞󟝐񱷳􋻩𿞸񫵗򣥨򚘣򶝠򯫞󌋩򑠒򅳒𔇆񘦵򌠐𢕍򡀋𪱷𢍟񗈼򙯬񨚑񙦅󘶸󜹕򷒋񤍠󻁾’.<span class="tok-n">ords</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，字符串必须相反。除此之外，它看起来非常好。 192 个字符包括解码器。</p>
</div>
<div class="paragraph">
<p>这对于打印另外可计算的常量来说并不是一个好主意，但考虑到解码器的长度和数据的相对密集的打包率，这在其他任务中很方便。</p>
</div>
</div>
<div class="sect2">
<h3 id="_所有的好事都必须结束可怕的事情_更是如此">21.6. 所有的好事都必须结束;可怕的事情 - 更是如此</h3>
<div class="paragraph">
<p>这是关于这篇文章的。更多代码高尔夫技巧我已经启动了这个存储库：<a href="https://github.com/AlexDaniel/6lang-golf-cheatsheet">https://github.com/AlexDaniel/6lang-golf-cheatsheet</a></p>
</div>
<div class="paragraph">
<p>希望能在 <a href="https://code-golf.io/">https://code-golf.io/</a> 上看到你！无论是否使用 perl 6，我都希望看到我提交的所有内容都被打败了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十四天_解魔方">22. <a href="https://perl6advent.wordpress.com/2017/12/24/">第二十四天-解魔方</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_2">22.1. 介绍</h3>
<div class="paragraph">
<p>我在圣诞节的愿望清单上有一个速度魔方，我真的很兴奋。 :)我想分享一些Perl 6代码的热情。</p>
</div>
<div class="paragraph">
<p>我在89年从高中毕业，所以我恰好是在青少年时期拥有魔方的合适年龄。我记得试图在巴士上炫耀，让我的时间缩短到不到一分钟。我在80年代从当地的一家玩具店拿到了一本小册子，其中展示了一个关于如何解决我记忆的立方体的算法。我再也没有这本小册子了。多年来我一直坚持，但从来没有达到竞争水平。</p>
</div>
<div class="paragraph">
<p>在过去的几个月里，YouTube根据我对立体声频道的兴趣，向我推荐了一些立方体视频;看到世界纪录在5秒以内，使我一分钟的旧时间看起来很慢。</p>
</div>
<div class="paragraph">
<p>我所讲过的每个人都可以解决魔方问题，他们使用的算法与我所学的算法不同，而在立体魔法中讨论的方法却与众不同。不过，这种先进的版本似乎被定期制定世界记录的人们普遍使用。</p>
</div>
<div class="paragraph">
<p>拾取这个算法并不难，我找到了几个视频，尤其是描述如何解决最后一层的视频。这样做了几天之后，我将步骤转录为几个笔记，其中列出了步骤列表，以及每个步骤的关键部分：所需的方向，然后是该步骤的各个转弯。然后，我可以参考我的笔记本的一个页面，而不是一个30分钟的视频，并且在几天后，记住了以下步骤：能够从记谱法移动到仅仅做这些移动是一个很大的加速。</p>
</div>
<div class="paragraph">
<p>一周后，我能够在两分钟内使用新方法可靠地解决问题;退后一步，但在休息时间里一周的努力并不坏。从那以后（几个星期后），我一直下到1:20以下。再次，这是初学者的方法，没有任何先进的技术，而且我可以在不查看立方体的情况下完成各个算法步骤。 （尽管如此，我仍然有很长的路要走。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_符号">22.2. 符号</h3>
<div class="paragraph">
<p>关于移动符号的快速注释 - 考虑到您将立方体的一边保持在顶部，一边朝向您，相对边是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>L (Left) R (Right) U (Up) D (Down) F (Front) B (Back)</pre>
</div>
</div>
<div class="paragraph">
<p>如果在步骤中看到一个单独的字母，如B，则表示顺时针转动该面（相对于立方体的中心，而不是您）。如果你在信里加了一个''，那就意味着逆时针方向，所以R&#8217;会让最上面的部分下来，而R会让底部的部分出现。</p>
</div>
<div class="paragraph">
<p>此外，您可能必须翻转两次，写成U2; （顺时针或逆时针无关紧要，因为它从起点开始为180º。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_算法">22.3. 算法</h3>
<div class="paragraph">
<p>我正在使用的初学者算法有以下基本步骤：</p>
</div>
<div class="paragraph">
<p>1.白色十字架2.白色拐角3.第二层4.黄色十字架5.黄色边缘6.黄色拐角7.定位黄色拐角</p>
</div>
<div class="paragraph">
<p>如果您对每个步骤的具体内容感到好奇，您可以浏览Rubik的wiki或上面链接的YouTube视频。该算法的更高级版本（由Jessica Fridrich提供的CFOP）允许您合并步骤，具有处理特定立方体状态的特定“快捷方式”，或者解决任何颜色作为第一面，而不仅仅是白色。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设计一个模块">22.4. 设计一个模块</h3>
<div class="paragraph">
<p>当我开始研究这个模块时，我知道我希望能够以某种熟悉算法的人熟悉的方式展示每一步所需的位置，并且让各个步骤也是自然的，就像是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>F.R.U.Rʼ.Uʼ.Fʼ</pre>
</div>
</div>
<div class="paragraph">
<p>我也希望能够转储立方体的现有状态;现在作为文本，但最终也能够将其与视觉表示相结合，</p>
</div>
<div class="paragraph">
<p>我们需要能够判断立方体是否已解决;我们需要能够检查相对于当前方向的棋子，并且能够改变我们的方向。</p>
</div>
<div class="paragraph">
<p>由于我要开始渲染立方体状态的能力，然后快速添加转向两侧的能力，我选择了一个内部结构，使其变得相当容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_代码">22.5. 代码</h3>
<div class="paragraph">
<p>github上提供了该模块的最新版本。这里介绍的代码来自最初的版本。</p>
</div>
<div class="paragraph">
<p>Perl 6允许您创建Enumerations，因此您可以在代码中使用实际的单词而不是查找值，所以让我们从一些我们需要的内容开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">enum</span> <span class="tok-n">Side</span> «:<span class="tok-n">Up</span>(<span class="tok-s">&#39;U&#39;</span>) :<span class="tok-n">Down</span>(<span class="tok-s">&#39;D&#39;</span>) :<span class="tok-n">Front</span>(<span class="tok-s">&#39;F&#39;</span>) :<span class="tok-n">Back</span>(<span class="tok-s">&#39;B&#39;</span>) :<span class="tok-n">Left</span>(<span class="tok-s">&#39;L&#39;</span>) :<span class="tok-n">Right</span>(<span class="tok-s">&#39;R&#39;</span>)»;
<span class="tok-k">enum</span> <span class="tok-n">Colors</span> «:<span class="tok-n">Red</span>(<span class="tok-s">&#39;R&#39;</span>) :<span class="tok-n">Green</span>(<span class="tok-s">&#39;G&#39;</span>) :<span class="tok-n">Blue</span>(<span class="tok-s">&#39;B&#39;</span>) :<span class="tok-n">Yellow</span>(<span class="tok-s">&#39;Y&#39;</span>) :<span class="tok-n">White</span>(<span class="tok-s">&#39;W&#39;</span>) :<span class="tok-n">Orange</span>(<span class="tok-s">&#39;O&#39;</span>)»;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个语法，我们可以直接在我们的代码中使用Up，并且它的关联值是U.</p>
</div>
<div class="paragraph">
<p>我们需要一个类，以便我们可以存储属性并拥有方法，所以我们的类定义具有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">Cube::Three</span> {
    <span class="tok-k">has</span> <span class="tok-nv">%!Sides</span>;
    ...
    <span class="tok-k">submethod</span> <span class="tok-n">BUILD</span>() {
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Up</span>}    = [<span class="tok-n">White</span>  <span class="tok-o">xx</span> <span class="tok-mi">9</span>];
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Front</span>} = [<span class="tok-n">Red</span>    <span class="tok-o">xx</span> <span class="tok-mi">9</span>];
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有一个属性，一个叫做％.Sides的Hash;每个键对应于其中一个Enum边。该值是Colors的9元素数组。数组上的每个元素对应于立方体上的一个位置。默认情况下，顶部的白色和正面的红色将在此处显示颜色和单元格位置，并带有数字和颜色。 （白色，红色是前面）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>         <span class="tok-n">W0</span> <span class="tok-n">W1</span> <span class="tok-n">W2</span>
         <span class="tok-n">W3</span> <span class="tok-n">W4</span> <span class="tok-n">W5</span>
         <span class="tok-n">W6</span> <span class="tok-n">W7</span> <span class="tok-n">W8</span>
<span class="tok-n">G2</span> <span class="tok-n">G5</span> <span class="tok-n">G8</span> <span class="tok-n">R2</span> <span class="tok-n">R5</span> <span class="tok-n">R8</span> <span class="tok-n">B2</span> <span class="tok-n">B5</span> <span class="tok-n">B8</span> <span class="tok-n">O2</span> <span class="tok-n">O5</span> <span class="tok-n">O8</span>
<span class="tok-n">G1</span> <span class="tok-n">G4</span> <span class="tok-n">G7</span> <span class="tok-n">R1</span> <span class="tok-n">R4</span> <span class="tok-n">R7</span> <span class="tok-n">B1</span> <span class="tok-n">B4</span> <span class="tok-n">B7</span> <span class="tok-n">O1</span> <span class="tok-n">O4</span> <span class="tok-n">O7</span>
<span class="tok-n">G0</span> <span class="tok-n">G3</span> <span class="tok-n">G6</span> <span class="tok-n">R0</span> <span class="tok-n">R3</span> <span class="tok-n">R6</span> <span class="tok-n">B0</span> <span class="tok-n">B3</span> <span class="tok-n">B6</span> <span class="tok-n">B0</span> <span class="tok-n">B3</span> <span class="tok-n">B6</span>
         <span class="tok-n">Y0</span> <span class="tok-n">Y1</span> <span class="tok-n">Y2</span>
         <span class="tok-n">Y3</span> <span class="tok-n">Y4</span> <span class="tok-n">Y5</span>
         <span class="tok-n">Y6</span> <span class="tok-n">Y7</span> <span class="tok-n">Y8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我添加的第一种方法是做每个脸部顺时针转动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">F</span> {
    <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-clockwise</span>(<span class="tok-n">Front</span>);
    <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">fixup-sides</span>([
        <span class="tok-nb">Pair</span>.<span class="tok-nb">new</span>(<span class="tok-n">Up</span>,    [<span class="tok-mi">6</span>,<span class="tok-mi">7</span>,<span class="tok-mi">8</span>]),
        <span class="tok-nb">Pair</span>.<span class="tok-nb">new</span>(<span class="tok-n">Right</span>, [<span class="tok-mi">2</span>,<span class="tok-mi">1</span>,<span class="tok-mi">0</span>]),
        <span class="tok-nb">Pair</span>.<span class="tok-nb">new</span>(<span class="tok-n">Down</span>,  [<span class="tok-mi">2</span>,<span class="tok-mi">1</span>,<span class="tok-mi">0</span>]),
        <span class="tok-nb">Pair</span>.<span class="tok-nb">new</span>(<span class="tok-n">Left</span>,  [<span class="tok-mi">6</span>,<span class="tok-mi">7</span>,<span class="tok-mi">8</span>]),
    ]);
    <span class="tok-k">self</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个公共方法调用两个私有方法（用！表示）;一个顺时针方向旋转一个侧面，第二个取对的列表，其中键是一个侧面，并且该值是一个位置列表。如果您想象顺时针旋转立方体的顶部，您可以看到位置正在从一个换成另一个。</p>
</div>
<div class="paragraph">
<p>请注意，我们从方法中返回自己;这允许我们按照原始设计中的方式调用方法调用。</p>
</div>
<div class="paragraph">
<p>单面的顺时针旋转显示正在传递的原始面，并使用阵列切片来改变原始面的顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># 0 1 2    6 3 0</span>
<span class="tok-c1"># 3 4 5 -&gt; 7 4 1</span>
<span class="tok-c1"># 6 7 8    8 5 2</span>
<span class="tok-k">method</span> !<span class="tok-n">rotate-clockwise</span>(<span class="tok-n">Side</span> \<span class="tok-n">side</span>) {
    <span class="tok-nv">%!Sides</span>{<span class="tok-n">side</span>}[<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">2</span>,<span class="tok-mi">3</span>,<span class="tok-mi">5</span>,<span class="tok-mi">6</span>,<span class="tok-mi">7</span>,<span class="tok-mi">8</span>] = <span class="tok-nv">%!Sides</span>{<span class="tok-n">side</span>}[<span class="tok-mi">6</span>,<span class="tok-mi">3</span>,<span class="tok-mi">0</span>,<span class="tok-mi">7</span>,<span class="tok-mi">1</span>,<span class="tok-mi">8</span>,<span class="tok-mi">5</span>,<span class="tok-mi">2</span>];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要为移动添加其余的符号，我们添加一些简单的包装方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">F2</span> { <span class="tok-k">self</span>.<span class="tok-n">F</span>.<span class="tok-n">F</span>; }
<span class="tok-k">method</span> <span class="tok-n">Fʼ</span> { <span class="tok-k">self</span>.<span class="tok-n">F</span>.<span class="tok-n">F</span>.<span class="tok-n">F</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>F2只需要移动两次; F&#8217;作弊：3个权利左转。</p>
</div>
<div class="paragraph">
<p>在这一点上，我必须确保我的回合正在做他们应该做的事情，所以我添加了一个gist方法（当一个对象用say输出时被调用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-n">Cube::Three</span>.<span class="tok-nb">new</span>.<span class="tok-n">U2</span>.<span class="tok-n">D2</span>.<span class="tok-n">F2</span>.<span class="tok-n">B2</span>.<span class="tok-n">R2</span>.<span class="tok-n">L2</span>;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>      <span class="tok-n">W</span> <span class="tok-n">Y</span> <span class="tok-n">W</span>
      <span class="tok-n">Y</span> <span class="tok-n">W</span> <span class="tok-n">Y</span>
      <span class="tok-n">W</span> <span class="tok-n">Y</span> <span class="tok-n">W</span>
<span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">O</span>
<span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">R</span>
<span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">O</span>
      <span class="tok-n">Y</span> <span class="tok-n">W</span> <span class="tok-n">Y</span>
      <span class="tok-n">W</span> <span class="tok-n">Y</span> <span class="tok-n">W</span>
      <span class="tok-n">Y</span> <span class="tok-n">W</span> <span class="tok-n">Y</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>gist 的源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">gist</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$result</span>;
    <span class="tok-nv">$result</span> = <span class="tok-nv">%!Sides</span>{<span class="tok-n">Up</span>}.<span class="tok-n">rotor</span>(<span class="tok-mi">3</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot;\n&quot;</span>).<span class="tok-n">indent</span>(<span class="tok-mi">6</span>);
    <span class="tok-nv">$result</span> ~= <span class="tok-s">&quot;\n&quot;</span>;

    <span class="tok-k">for</span> <span class="tok-mi">2</span>,<span class="tok-mi">1</span>,<span class="tok-mi">0</span> -&gt; <span class="tok-nv">$row</span> {
        <span class="tok-k">for</span> (<span class="tok-n">Left</span>, <span class="tok-n">Front</span>, <span class="tok-n">Right</span>, <span class="tok-n">Back</span>) -&gt; <span class="tok-nv">$side</span> {
            <span class="tok-k">my</span> <span class="tok-nv">@slice</span> = (<span class="tok-mi">0</span>,<span class="tok-mi">3</span>,<span class="tok-mi">6</span>) &gt;&gt;+&gt;&gt; <span class="tok-nv">$row</span>;
            <span class="tok-nv">$result</span> ~= ~<span class="tok-nv">%!Sides</span>{<span class="tok-nv">$side</span>}[<span class="tok-nv">@slice</span>].<span class="tok-nb">join</span>(<span class="tok-s">&#39; &#39;</span>) ~ <span class="tok-s">&#39; &#39;</span>;
        }
        <span class="tok-nv">$result</span> ~= <span class="tok-s">&quot;\n&quot;</span>;
    }
    <span class="tok-nv">$result</span> ~= <span class="tok-nv">%!Sides</span>{<span class="tok-n">Down</span>}.<span class="tok-n">rotor</span>(<span class="tok-mi">3</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot;\n&quot;</span>).<span class="tok-n">indent</span>(<span class="tok-mi">6</span>);
    <span class="tok-nv">$result</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有几件事要注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用.rotor（3）将9单元阵列分解为3个3单元列表。</p>
</li>
<li>
<p>.indent（6）预先在Up和Down两边加上空格。</p>
</li>
<li>
<p>（0,3,6）&gt;&gt; + &gt;&gt; $ row，这会增加列表中的每个值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个要点非常适合逐步检查，但为了调试，我们需要一些更紧凑的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">dump</span> {
    <span class="tok-k">gather</span> <span class="tok-k">for</span> (<span class="tok-n">Up</span>, <span class="tok-n">Front</span>, <span class="tok-n">Right</span>, <span class="tok-n">Back</span>, <span class="tok-n">Left</span>, <span class="tok-n">Down</span>) -&gt; <span class="tok-nv">$side</span> {
        <span class="tok-k">take</span> <span class="tok-nv">%!Sides</span>{<span class="tok-nv">$side</span>}.<span class="tok-nb">join</span>(<span class="tok-s">&#39;&#39;</span>);
    }.<span class="tok-nb">join</span>(<span class="tok-s">&#39;|&#39;</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将按照特定的顺序在边上迭代，然后使用gather take语法收集每一边的字符串表示形式，然后使用|将它们连接在一起。现在我们可以编写像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Test</span>; <span class="tok-k">use</span> <span class="tok-n">Cube::Three</span>;
<span class="tok-k">my</span> <span class="tok-nv">$a</span> = <span class="tok-n">Cube::Three</span>.<span class="tok-nb">new</span>();
<span class="tok-k">is</span> <span class="tok-nv">$a</span>.<span class="tok-n">R</span>.<span class="tok-n">U2</span>.<span class="tok-n">Rʼ</span>.<span class="tok-n">Uʼ</span>.<span class="tok-n">R</span>.<span class="tok-n">Uʼ</span>.<span class="tok-n">Rʼ</span>.<span class="tok-n">Lʼ</span>.<span class="tok-n">U2</span>.<span class="tok-n">L</span>.<span class="tok-n">U</span>.<span class="tok-n">Lʼ</span>.<span class="tok-n">U</span>.<span class="tok-n">L</span>.<span class="tok-n">dump</span>,
    <span class="tok-s">&#39;WWBWWWWWB|RRRRRRRRW|BBRBBBBBO|OOWOOOOOO|GGGGGGGGG|YYYYYYYYY&#39;</span>,
    <span class="tok-s">&#39;corners rotation&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实际上是算法最后一步中使用的方法。通过这个调试输出，我可以拍摄一个原始的立方体，自己动手，然后将生成的立方体状态快速转录成字符串进行测试。</p>
</div>
<div class="paragraph">
<p>虽然计算机不一定需要旋转立方体，但如果我们可以旋转立方体，则会更容易遵循该算法，因此我们为六个可能的旋转中的每一个添加一个，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">rotate-F-U</span> {
     <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-clockwise</span>(<span class="tok-n">Right</span>);
     <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-counter-clockwise</span>(<span class="tok-n">Left</span>);

     <span class="tok-c1"># In addition to moving the side data, have to</span>
     <span class="tok-c1"># re-orient the indices to match the new side.</span>
     <span class="tok-k">my</span> <span class="tok-nv">$temp</span> = <span class="tok-nv">%!Sides</span>{<span class="tok-n">Up</span>};
     <span class="tok-nv">%!Sides</span>{<span class="tok-n">Up</span>}    = <span class="tok-nv">%!Sides</span>{<span class="tok-n">Front</span>};
     <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-counter-clockwise</span>(<span class="tok-n">Up</span>);
     <span class="tok-nv">%!Sides</span>{<span class="tok-n">Front</span>} = <span class="tok-nv">%!Sides</span>{<span class="tok-n">Down</span>};
     <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-clockwise</span>(<span class="tok-n">Front</span>);
     <span class="tok-nv">%!Sides</span>{<span class="tok-n">Down</span>}  = <span class="tok-nv">%!Sides</span>{<span class="tok-n">Back</span>};
     <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-clockwise</span>(<span class="tok-n">Down</span>);
     <span class="tok-nv">%!Sides</span>{<span class="tok-n">Back</span>}  = <span class="tok-nv">$temp</span>;
     <span class="tok-k">self</span><span class="tok-o">!</span><span class="tok-n">rotate-counter-clockwise</span>(<span class="tok-n">Back</span>);
     <span class="tok-k">self</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们将立方体从正面转到向上时，我们将左侧和右侧旋转到位。由于细胞的方向随着我们改变面部而改变，因为我们从面部到面部复制细胞，我们也可能需要旋转它们以确保它们最终以正确的方向朝向。和以前一样，我们返回自我以允许方法链接。</p>
</div>
<div class="paragraph">
<p>在我们开始测试时，我们需要确保我们可以知道何时立方体已解决;我们不关心立方体的方向，所以我们验证中心颜色与脸上的所有其他颜色相匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">solved</span> {
    <span class="tok-k">for</span> (<span class="tok-n">Up</span>, <span class="tok-n">Down</span>, <span class="tok-n">Left</span>, <span class="tok-n">Right</span>, <span class="tok-n">Back</span>, <span class="tok-n">Front</span>) -&gt; <span class="tok-nv">$side</span> {
        <span class="tok-k">return</span> <span class="tok-nb">False</span> <span class="tok-k">unless</span>
            <span class="tok-nv">%!Sides</span>{<span class="tok-nv">$side</span>}.<span class="tok-nb">all</span> <span class="tok-o">eq</span> <span class="tok-nv">%!Sides</span>{<span class="tok-nv">$side</span>}[<span class="tok-mi">4</span>];
    }
    <span class="tok-k">return</span> <span class="tok-nb">True</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每一侧，我们使用一侧的所有颜色的交界处与中心细胞进行比较（总是位置4）。我们很早就失败了，只有通过所有方面才能成功。</p>
</div>
<div class="paragraph">
<p>接下来，我添加了一种方法来搅乱魔方，所以我们可以考虑实施一种解决方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">scramble</span> {
    <span class="tok-k">my</span> <span class="tok-nv">@random</span> = <span class="tok-s">&lt;U D F R B L&gt;</span>.<span class="tok-n">roll</span>(<span class="tok-mi">100</span>).<span class="tok-n">squish</span>[^<span class="tok-mi">10</span>];
    <span class="tok-k">for</span> <span class="tok-nv">@random</span> -&gt; <span class="tok-nv">$method</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$actual</span> = <span class="tok-nv">$method</span> ~ (<span class="tok-s">&quot;&quot;</span>, <span class="tok-s">&quot;2&quot;</span>, <span class="tok-s">&quot;ʼ&quot;</span>).<span class="tok-nb">pick</span>(<span class="tok-mi">1</span>);
        <span class="tok-k">self</span>.<span class="tok-s">&quot;$actual&quot;</span>();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要六个基本方法名称，挑选一堆随机值，然后挤压它们（确保连续没有模糊），然后选取前10个值。然后，我们可能会添加一个2或'。最后，我们使用间接方法语法按名称调用各个方法。</p>
</div>
<div class="paragraph">
<p>最后，我准备好开始解决问题了！这就是事情变得复杂的地方。初学者方法的第一步经常被描述为直观的。这意味着它很容易解释&#8230;&#8203;&#8230;&#8203;但不容易编码。所以，扰流警报，截至本文发布时，解决的第一步就完成了。对于第一步的完整算法，请查看链接的github网站。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">solve</span> {
    <span class="tok-k">self</span>.<span class="tok-n">solve-top-cross</span>;
}

<span class="tok-k">method</span> <span class="tok-n">solve-top-cross</span> {
    <span class="tok-k">sub</span> <span class="tok-n">completed</span> {
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Up</span>}[<span class="tok-mi">1</span>,<span class="tok-mi">3</span>,<span class="tok-mi">5</span>,<span class="tok-mi">7</span>].<span class="tok-nb">all</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;W&#39;</span> &amp;&amp;
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Front</span>}[<span class="tok-mi">5</span>] <span class="tok-o">eq</span> <span class="tok-s">&#39;R&#39;</span> &amp;&amp;
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Right</span>}[<span class="tok-mi">5</span>] <span class="tok-o">eq</span> <span class="tok-s">&#39;B&#39;</span> &amp;&amp;
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Back</span>}[<span class="tok-mi">5</span>]  <span class="tok-o">eq</span> <span class="tok-s">&#39;O&#39;</span> &amp;&amp;
        <span class="tok-nv">%!Sides</span>{<span class="tok-n">Left</span>}[<span class="tok-mi">5</span>]  <span class="tok-o">eq</span> <span class="tok-s">&#39;G&#39;</span>;
    }
    ...
    <span class="tok-n">MAIN:</span>
    <span class="tok-k">while</span> !<span class="tok-n">completed</span>() {
        <span class="tok-c1"># Move white-edged pieces in second row up to top</span>

        <span class="tok-c1"># Move incorrectly placed pieces in the top row to the middle</span>

        <span class="tok-c1"># Move pieces from the bottom to the top</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意非常具体的检查，看看我们是否完成;我们使用一个词汇子来弥补复杂性 - 虽然我们在这里有一个相当内部的检查，但是我们可以看到，我们可能想要将这个抽象描述为可以说“这个边缘部分是正确的”。首先，我们将坚持单个单元格。</p>
</div>
<div class="paragraph">
<p>目前解决十字架的内容长达100多行，所以我不会经历所有的步骤。这是“简单”部分</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@middle-edges</span> =
    [<span class="tok-n">Front</span>, <span class="tok-n">Right</span>],
    [<span class="tok-n">Right</span>, <span class="tok-n">Back</span>],
    [<span class="tok-n">Back</span>,  <span class="tok-n">Left</span>],
    [<span class="tok-n">Left</span>,  <span class="tok-n">Front</span>],
;

<span class="tok-k">for</span> <span class="tok-nv">@middle-edges</span> -&gt; <span class="tok-nv">$edge</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$side7</span> = <span class="tok-nv">$edge</span>[<span class="tok-mi">0</span>];
    <span class="tok-k">my</span> <span class="tok-nv">$side1</span> = <span class="tok-nv">$edge</span>[<span class="tok-mi">1</span>];
    <span class="tok-k">my</span> <span class="tok-nv">$color7</span> = <span class="tok-nv">%!Sides</span>{<span class="tok-nv">$side7</span>}[<span class="tok-mi">7</span>];
    <span class="tok-k">my</span> <span class="tok-nv">$color1</span> = <span class="tok-nv">%!Sides</span>{<span class="tok-nv">$side1</span>}[<span class="tok-mi">1</span>];
    <span class="tok-k">if</span> <span class="tok-nv">$color7</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;W&#39;</span> {
        <span class="tok-c1"># find number of times we need to rotate the top:</span>
        <span class="tok-k">my</span> <span class="tok-nv">$turns</span> = (
            <span class="tok-nv">@ordered-sides</span>.<span class="tok-nb">first</span>(<span class="tok-nv">$side1</span>, :<span class="tok-n">k</span>) -
            <span class="tok-nv">@ordered-sides</span>.<span class="tok-nb">first</span>(<span class="tok-nv">%expected-sides</span>{~<span class="tok-nv">$color1</span>}, :<span class="tok-n">k</span>)
        ) % <span class="tok-mi">4</span>;
        <span class="tok-k">self</span>.<span class="tok-n">U</span> <span class="tok-k">for</span> <span class="tok-mi">1</span>..<span class="tok-nv">$turns</span>;
        <span class="tok-k">self</span>.<span class="tok-s">&quot;$side1&quot;</span>();
        <span class="tok-k">self</span>.<span class="tok-n">Uʼ</span> <span class="tok-k">for</span> <span class="tok-mi">1</span>..<span class="tok-nv">$turns</span>;
        <span class="tok-k">next</span> <span class="tok-n">MAIN</span>;
    } <span class="tok-k">elsif</span> <span class="tok-nv">$color1</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;W&#39;</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$turns</span> = (
            <span class="tok-nv">@ordered-sides</span>.<span class="tok-nb">first</span>(<span class="tok-nv">$side7</span>, :<span class="tok-n">k</span>) -
            <span class="tok-nv">@ordered-sides</span>.<span class="tok-nb">first</span>(<span class="tok-nv">%expected-sides</span>{~<span class="tok-nv">$color7</span>}, :<span class="tok-n">k</span>)
        ) % <span class="tok-mi">4</span>;
        <span class="tok-k">self</span>.<span class="tok-n">Uʼ</span> <span class="tok-k">for</span> <span class="tok-mi">1</span>..<span class="tok-nv">$turns</span>;
        <span class="tok-k">self</span>.<span class="tok-s">&quot;$side1&quot;</span>();
        <span class="tok-k">self</span>.<span class="tok-n">U</span> <span class="tok-k">for</span> <span class="tok-mi">1</span>..<span class="tok-nv">$turns</span>;
        <span class="tok-k">next</span> <span class="tok-n">MAIN</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在真正的立方体上进行这一部分时，您可以旋转立方体而不考虑侧面部件，然后将十字架放在适当位置。为了让算法更“友好”一点，我们让这些中心保持在这个位置;我们将上侧旋转到位，然后将单个侧面旋转到顶部位置，然后将上侧旋转回原始位置。</p>
</div>
<div class="paragraph">
<p>这里有一些有趣的代码是.first（&#8230;&#8203;，：k）语法，它说找到匹配的第一个元素，然后返回匹配的位置。然后，我们可以在有序列表中查找事物，以便计算双方的相对位置。</p>
</div>
<div class="paragraph">
<p>请注意，解决方法只调用公共方法来转动立方体;虽然我们使用原始自省来获取立方体状态，但我们只使用“合法”的方式来解决问题。</p>
</div>
<div class="paragraph">
<p>有了这个方法的完整版本，我们现在用这个程序来解决白十字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!/usr/bin/env perl6</span>

<span class="tok-k">use</span> <span class="tok-n">Cube::Three</span>;
<span class="tok-k">my</span> <span class="tok-nv">$cube</span> = <span class="tok-n">Cube::Three</span>.<span class="tok-nb">new</span>();
<span class="tok-nv">$cube</span>.<span class="tok-n">scramble</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$cube</span>;
<span class="tok-nb">say</span> <span class="tok-s">&#39;&#39;</span>;
<span class="tok-nv">$cube</span>.<span class="tok-n">solve</span>;
<span class="tok-nb">say</span> <span class="tok-nv">$cube</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在给定这组移动的情况下产生这个输出（F&#8217;B2B2LR&#8217;U&#8217;RF&#8217;D2B2）。首先是争夺战，然后是解决白十字的版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-n">W</span> <span class="tok-n">G</span> <span class="tok-n">G</span>
      <span class="tok-n">Y</span> <span class="tok-n">W</span> <span class="tok-n">W</span>
      <span class="tok-n">Y</span> <span class="tok-n">Y</span> <span class="tok-n">Y</span>
<span class="tok-n">O</span> <span class="tok-n">O</span> <span class="tok-n">B</span> <span class="tok-n">R</span> <span class="tok-n">R</span> <span class="tok-n">R</span> <span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">O</span> <span class="tok-n">Y</span> <span class="tok-n">Y</span> <span class="tok-n">B</span>
<span class="tok-n">R</span> <span class="tok-n">G</span> <span class="tok-n">O</span> <span class="tok-n">B</span> <span class="tok-n">R</span> <span class="tok-n">R</span> <span class="tok-n">G</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">W</span> <span class="tok-n">O</span> <span class="tok-n">B</span>
<span class="tok-n">Y</span> <span class="tok-n">B</span> <span class="tok-n">B</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">W</span> <span class="tok-n">G</span> <span class="tok-n">G</span> <span class="tok-n">G</span> <span class="tok-n">W</span> <span class="tok-n">W</span> <span class="tok-n">O</span>
      <span class="tok-n">W</span> <span class="tok-n">W</span> <span class="tok-n">O</span>
      <span class="tok-n">Y</span> <span class="tok-n">Y</span> <span class="tok-n">O</span>
      <span class="tok-n">B</span> <span class="tok-n">R</span> <span class="tok-n">R</span>

      <span class="tok-n">Y</span> <span class="tok-n">W</span> <span class="tok-n">W</span>
      <span class="tok-n">W</span> <span class="tok-n">W</span> <span class="tok-n">W</span>
      <span class="tok-n">G</span> <span class="tok-n">W</span> <span class="tok-n">R</span>
<span class="tok-n">O</span> <span class="tok-n">G</span> <span class="tok-n">W</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">Y</span> <span class="tok-n">B</span> <span class="tok-n">B</span> <span class="tok-n">G</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">G</span>
<span class="tok-n">Y</span> <span class="tok-n">G</span> <span class="tok-n">G</span> <span class="tok-n">R</span> <span class="tok-n">R</span> <span class="tok-n">B</span> <span class="tok-n">R</span> <span class="tok-n">B</span> <span class="tok-n">Y</span> <span class="tok-n">R</span> <span class="tok-n">O</span> <span class="tok-n">G</span>
<span class="tok-n">O</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">Y</span> <span class="tok-n">O</span> <span class="tok-n">W</span> <span class="tok-n">O</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">W</span> <span class="tok-n">Y</span> <span class="tok-n">B</span>
      <span class="tok-n">G</span> <span class="tok-n">G</span> <span class="tok-n">B</span>
      <span class="tok-n">B</span> <span class="tok-n">Y</span> <span class="tok-n">Y</span>
      <span class="tok-n">Y</span> <span class="tok-n">B</span> <span class="tok-n">B</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子打印出用来进行争夺的动作，显示乱数立方体，“解决”这个难题（在撰写本文时，它只是白色的十字），然后打印出立方体的新状态。</p>
</div>
<div class="paragraph">
<p>请注意，随着我们的进一步发展，这些步骤变得不那么“直观”，并且根据我的估计，编码更容易。例如，最后一步需要检查四个部分的方向，必要时旋转立方体，然后执行14步移动。 （在上面的测试中显示）。</p>
</div>
<div class="paragraph">
<p>希望我对Cubing和Perl 6的喜爱让你期待你的下一个项目！</p>
</div>
<div class="paragraph">
<p>对于未来的读者，我将在模块解决完成后的评论中注明。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十五天_圣诞奖金_并发http服务器实施和scripter的方法">23. <a href="https://perl6advent.wordpress.com/2017/12/25/bonus-xmas-concurrent-http-server-implementation-and-the-scripters-approach/">第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先，我想强调 <a href="http://www.jnthn.net/">Jonathan Worthington</a> 在 <a href="http://rakudo.org/">Rakudo Perl6</a> 和 <a href="https://docs.perl6.org/type/IO::Socket::Async">IO::Socket::Async</a> 中的工作。谢谢 Jon！</p>
</div>
<div class="paragraph">
<p>我喜欢制作脚本;编写组织良好的动作序列，<strong>获得结果</strong>并对它们进行<strong>处理</strong>。</p>
</div>
<div class="paragraph">
<p>当我从 Perl6 开始时，我发现了一个壮观的生态系统，我可以<strong>按照自己喜欢的方式</strong>实践我的想法：<strong>脚本方式</strong>。其中一个想法是实现一个小型的 HTTP 服务器来玩玩。查看与 <strong>Perl6</strong>，HTTP 和套接字相关的其他项目和模块，我发现背后的作者是具有<strong>面向对象</strong>编程经验的程序员。</p>
</div>
<div class="sect2">
<h3 id="_perl6_范式">23.1. Perl6 范式</h3>
<div class="paragraph">
<p>Perl6 支持三种最流行的编程范式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>面向对象</p>
</li>
<li>
<p>函数式</p>
</li>
<li>
<p>过程式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我认为，当你设计一个<strong>将会增长</strong>的应用程序或服务时，<strong>面向对象</strong>的范式是很好的，它会做许多<strong>不同的事情</strong>并且会有<strong>很多变化</strong>。但我不喜欢那些变化太大，会有很多变化的东西;这就是为什么我喜欢使用原生过程式方法的脚本，因为它能够<strong>快速提升简单性和有效性</strong>。我喜欢小（一步一步）但能快速完成伟大东西的事物。</p>
</div>
<div class="paragraph">
<p><strong>函数式</strong>范式在我看来非常棒;你可以使用一个函数，并像 var 一样使用它，以及其他令人惊讶的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_perl6_supplies_就像一个_v12_引擎">23.2. Perl6 Supplies 就像一个 V12 引擎</h3>
<div class="paragraph">
<p>在我开始将 <a href="http://perl6intro.com/">perl6intro.com</a> 翻译成<a href="http://es.perl6intro.com/">西班牙语</a>后不久，我开始使用 Perl6。看看 <strong>Perl6</strong> 的文档，我发现了 <strong>Perl6</strong> 巨大的<strong>并发</strong>潜力。 Perl6在<a href="https://docs.perl6.org/language/concurrency">并发方面</a>比我想象的更加强大。</p>
</div>
<div class="paragraph">
<p>我使用 <strong>Perl6</strong> 的 HTTP 服务器的思想始于 <a href="https://docs.perl6.org/type/Supply">Perl6 Supplies</a>（具有多个订阅者的异步数据流），具体来说就是 <a href="https://docs.perl6.org/type/IO::Socket::Async">IO::Socket::Async</a>类。所有的套接字管理，数据传输和并发性实际上都是<strong>自动</strong>且易于理解的。制作并玩一玩小并发但强大的服务是极好的。</p>
</div>
<div class="paragraph">
<p>基于 <a href="https://docs.perl6.org/type/IO::Socket::Async">IO::Socket::Async</a> 文档的示例，我开始在 <a href="https://github.com/ramiroencinas/mini-http-cgi-server">mini-http-cgi-server</a> 项目中实现一个支持 pseudoCGI 的小型 HTTP 服务器，并且按照我的预期工作。当我得到我想要的东西时，我很满意，我离开了这个项目一段时间。我不喜欢事情发展太多。</p>
</div>
<div class="paragraph">
<p>但之后，为马德里 <a href="http://madrid.pm.org/workshop">Perl Workshop 2017</a> 做了一次演讲（感谢<a href="http://madrid.pm.org/">马德里 Perl Mongers</a> 和 <a href="http://barcelona.pm/">巴塞罗那 Perl Mongers</a> 团队为这次活动提供的支持），我有足够的动力去做<strong>更实际的</strong>事情，让网络<strong>前端</strong>编码人员可以完成他们的工作并且与 <strong>Perl6正在等待的后端</strong>进行交流。一方面是典型的<strong>公共 html 静态结构</strong>，另一方面是一个包含多个 web 服务的 <strong>Perl6</strong> 模块，用于等待来自前端人员的 web 请求。</p>
</div>
<div class="paragraph">
<p>然后 <a href="https://github.com/ramiroencinas/wap6">Wap6</a> 诞生了（Web App Perl6）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_wap6_的结构">23.3. Wap6 的结构</h3>
<div class="paragraph">
<p>我喜欢 Wap6 实现的 Web 应用程序的结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>public</p>
</li>
<li>
<p>webservices</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>公共</strong>文件夹包含友好的前端东西，比如静态 html，javascript，css 等，也就是<strong>前端</strong>开发者空间。 <strong>webservices</strong> 文件夹包含<strong>后端</strong>的东西：一个 <strong>Perl6</strong> 模块，包括每个 webservice 的一个函数。</p>
</div>
<div class="paragraph">
<p>相同的文件夹级别包含解决方案入口点，一个 <strong>Perl6</strong> 脚本，其中包括初始化服务器参数，其中包含路由和 webservices 之间的映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">%webservices</span> =
  <span class="tok-s">&#39;/ws1&#39;</span> =&gt; ( <span class="tok-nv">&amp;ws1</span>, <span class="tok-s">&#39;html&#39;</span> ),
  <span class="tok-s">&#39;/ws2&#39;</span> =&gt; ( <span class="tok-nv">&amp;ws2</span>, <span class="tok-s">&#39;json&#39;</span> )
;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，不仅路由被映射到相应的 webservices，而且还指定 webservice 的返回内容类型(content-type )（如 HMTL 或 JSON）。也就是说，在 Web 浏览器中键入 <a href="http://domain/ws1">http://domain/ws1</a>，ws1 函数会返回具有相应内容类型的响应数据，我们将在稍后看到。</p>
</div>
<div class="paragraph">
<p>所有到 webservices 的路由都在 <strong>％webservices</strong> 散列中，并通过其他有用的命名参数传递给主函数 <strong>wap</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">wap</span>(:<span class="tok-nv">$server-ip</span>, :<span class="tok-nv">$server-port</span>, :<span class="tok-nv">$default-html</span>, :<span class="tok-nv">%webservices</span>);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wap6_的核心">23.4. Wap6 的核心</h3>
<div class="paragraph">
<p><strong>wap</strong> 函数位于 Wap6 使用的核心 lib 模块的外面，并包含并发和优雅的 V12 引擎：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">react</span> {
  <span class="tok-n">whenever</span> <span class="tok-n">IO::Socket::Async</span>.<span class="tok-n">listen</span>(<span class="tok-nv">$server-ip</span>,<span class="tok-nv">$server-port</span>) -&gt; <span class="tok-nv">$conn</span> {
    <span class="tok-n">whenever</span> <span class="tok-nv">$conn</span>.<span class="tok-n">Supply</span>(:<span class="tok-n">bin</span>) -&gt; <span class="tok-nv">$buf</span> {
      <span class="tok-k">my</span> <span class="tok-nv">$response</span> = <span class="tok-n">response</span>(:<span class="tok-nv">$buf</span>, :<span class="tok-nv">$current-dir</span>, :<span class="tok-nv">$default-html</span>, :<span class="tok-nv">%webservices</span>);
      <span class="tok-nv">$conn</span>.<span class="tok-n">write:</span> <span class="tok-nv">$response</span>.<span class="tok-n">encode</span>(<span class="tok-s">&#39;UTF-8&#39;</span>);
      <span class="tok-nv">$conn</span>.<span class="tok-nb">close</span>;
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个三分（react – whenever – IO::Socket::Async）响应式，并发和异步的上下文。当传输从Web客户端（<strong>$conn</strong>）到达时，它将被放置在 bin 类型的新 Supply <strong>$buf</strong> (<strong>$conn.Suply(:bin)</strong>)中，<strong>$buf</strong> 和 <strong>％webservices</strong> 哈希等其他内容被发送到运行 HTTP 逻辑的响应函数。最后，响应函数的返回被写回到 Web 客户端。</p>
</div>
<div class="paragraph">
<p>响应函数（也位于核心库 lib 中）包含 <strong>HTTP 解析器</strong>的东西：它将传入数据（HTTP 实体）分割为头和主体，它执行验证，它需要基本的 HTTP 头信息，如方法（<strong>GET</strong> 或 <strong>POST</strong>）和 <strong>URI</strong>（统一资源标识符），它确定所请求的资源是 webservice（来自 webservices 文件夹）还是静态文件（来自公共文件夹），从资源中获取数据（来自静态文件或 webservice）并返回到 <strong>wap</strong> 函数以将响应写入 Web 客户端，如我们以前所见。</p>
</div>
</div>
<div class="sect2">
<h3 id="_webservices">23.5. Webservices</h3>
<div class="paragraph">
<p>响应函数验证 <strong>$buf</strong> 并从请求头中提取 HTTP 方法，可以是 <strong>GET</strong> 或 <strong>POST</strong>（我认为将来它不会支持更多的 HTTP 方法）。使用 <strong>GET</strong> 方法时，它将 URL 参数（如果有的话）放入 <strong>$get-params</strong>。 <strong>POST</strong> 方法的情况下，它将主体请求放入 <strong>$body</strong>。</p>
</div>
<div class="paragraph">
<p>然后是时候检查 Web 客户端是否请求了 webservice。 <strong>$get-params</strong> 包含了 <strong>URI</strong> 并用 <a href="https://github.com/perl6-community-modules/uri">URI 模块</a>提取，最终结果放在 <strong>$path</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">given</span> <span class="tok-nv">$path</span> {
  <span class="tok-k">when</span> <span class="tok-nv">%webservices</span>{<span class="tok-s">&quot;$_&quot;</span>}:<span class="tok-n">exists</span> {
    <span class="tok-k">my</span> ( <span class="tok-nv">&amp;ws</span>, <span class="tok-nv">$direct-type</span> ) = <span class="tok-nv">%webservices</span>{<span class="tok-s">&quot;$_&quot;</span>};
    <span class="tok-k">my</span> <span class="tok-nv">$type</span> = <span class="tok-n">content-type</span>(:<span class="tok-nv">$direct-type</span>);
    <span class="tok-k">return</span> <span class="tok-n">response-headers</span>(<span class="tok-mi">200</span>, <span class="tok-nv">$type</span>) ~ <span class="tok-nv">&amp;ws</span>(:<span class="tok-nv">$get-params</span>, :<span class="tok-nv">$body</span>);
  }
  ..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <strong>％webservices</strong> 哈希中存在 <strong>$path</strong>，则客户端需要一个 webservice。然后它从 <strong>％webservices</strong> 散列（是的，我也喜欢函数式范式:-)）和对应的内容类型中提取相应的 webservice 可调用函数 <strong>＆ws</strong>。然后它使用 <strong>$get-params</strong> 和请求 <strong>$body</strong> 参数调用 webservice 函数 <strong>＆ws</strong>。最后它返回连接的 HTTP 响应实体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有状态 HTTP 200 OK 和给定内容类型（来自内容类型函数）的响应头。</p>
</li>
<li>
<p>webservice 输出。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可调用 webservice <strong>＆ws</strong> 可以是 <strong>ws1</strong>，位于 webservices 文件夹的 Perl6 模块中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">ws1</span> ( :<span class="tok-nv">$get-params</span>, :<span class="tok-nv">$body</span> ) <span class="tok-k">is</span> <span class="tok-k">export</span> {
  <span class="tok-k">if</span> <span class="tok-nv">$get-params</span> { <span class="tok-k">return</span> <span class="tok-s">&#39;From ws1: &#39;</span> ~ <span class="tok-nv">$get-params</span>; }
  <span class="tok-k">if</span> <span class="tok-nv">$body</span> { <span class="tok-k">return</span> <span class="tok-s">&#39;From ws1: &#39;</span> ~ <span class="tok-nv">$body</span>; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个演示上下文中，webservice 简单地返回输入，即 <strong>$get-params</strong>（当 GET）或 <strong>$body</strong>（POST时）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_当客户端请求静态文件时">23.6. 当客户端请求静态文件时</h3>
<div class="paragraph">
<p>放弃所有其他可能性后，如果客户端请求公用文件夹中托管的静态文件（如html，js，css等），则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">given</span> <span class="tok-nv">$path</span> {
..
  <span class="tok-k">default</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$filepath</span> = <span class="tok-s">&quot;$current-dir/public/$path&quot;</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$type</span> = <span class="tok-n">content-type</span>(:<span class="tok-nv">$filepath</span>);
    <span class="tok-k">return</span> <span class="tok-n">response-headers</span>(<span class="tok-mi">200</span>, <span class="tok-nv">$type</span>) ~ <span class="tok-nb">slurp</span> <span class="tok-s">&quot;$current-dir/public/$path&quot;</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它返回包含匹配内容类型和请求文件内容的响应头。</p>
</div>
<div class="paragraph">
<p>这就是所有的了！以脚本过程式方式使用并发 Web服务：<strong>Wap6</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结语">23.7. 结语</h3>
<div class="paragraph">
<p>我很满意 <strong>Wap6</strong> 的结果。我并不假装它增长很多，但我总是想继续添加<strong>更多功能</strong>：SSL支持（完成！），会话管理（进行中），Cookie，文件上传等。</p>
</div>
<div class="paragraph">
<p>Perl6 为表执行并发网络操作提供了非常强大的方法：<a href="https://docs.perl6.org/type/IO::Socket::Async">IO::Socket::Async</a>，一个杰作。另外，使用 <strong>Perl6</strong>，您可以根据需要混合使用面向对象，过程式和函数式范式。借助这些功能，您可以设计一个并发异步服务并快速实现。</p>
</div>
<div class="paragraph">
<p>如果您希望在 <strong>Perl6</strong> 生态系统中使用 HTTP 服务和并发性更严肃的方法，请看看 <a href="http://cro.services/">Cro</a>，它代表了一个很好的机会，可以将 <strong>Perl6</strong> 作为 HTTP 服务空间中的强大实体。Jonathan Worthington 在同样的 Advent Calendar 的第九天写的就是<a href="https://perl6advent.wordpress.com/2017/12/09/http-and-web-sockets-with-cro">关于 Cro</a>。</p>
</div>
<div class="paragraph">
<p>同时，我将继续使用 <strong>Wap6</strong>，以脚本的方式，贡献 <strong>Perl6</strong> 生态系统，并从世界上最好的编程人员那里学习，我的意思是：<strong>Perl</strong> 和 <strong>Perl6</strong> 程序员，当然:-)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一天_移植_vigilance将perl_6与标准工具集成在一起">24. 第一天 - 移植 Vigilance，将Perl 6与标准工具集成在一起</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大家好，今天我们将采用基础设施脚本并将其从Perl 5移植到Perl 6.本文基于James Clark的一对帖子，你可以在这里找到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-1.html">第1部分</a></p>
</li>
<li>
<p><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-2.html">第2部分</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此脚本用于创建和验证MD5总和。 这些是128位值，可用于验证数据完整性。 虽然MD5已经被证明在防范恶意行为者方面不安全，但它对于检测磁盘损坏仍然很有用。</p>
</div>
<div class="paragraph">
<p>Perl 6生态系统正在发展，其中包含多种工具，这些工具可以从Perl 5 CPAN移植，也可以替代。 我将介绍原始脚本和移植的几个方面，并说明我为什么要进行一些特定的更改。 希望这会鼓励你出去移植你自己的小脚本。</p>
</div>
<div class="sect2">
<h3 id="_shebang_和导入">24.1. Shebang 和导入</h3>
<div class="paragraph">
<p>Perl 5版本使用一些基础设施和一些实用程序来处理Unicode并使命令行输出更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-ch">#!/usr/bin/perl -CSDA</span>

<span class="tok-k">use</span> <span class="tok-nn">strict</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">warnings</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">utf8</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Encode</span> <span class="tok-sx">qw/encode_utf8 decode_utf8/</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Getopt::Long</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Digest::MD5</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Term::ANSIColor</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Term::ProgressBar</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">File::Find</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">File::Basename</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Data::Dumper</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 6默认启用了警告和限制，并且内置了Unicode支持，因此我们可以将其保留。 Data::Dumper也已经实现，它具有非常有用的IO功能。 将所有这些加在一起我们可以得到一个非常精益的标头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!/usr/bin/env perl6</span>
<span class="tok-k">use</span> <span class="tok-n">v6</span>;

<span class="tok-k">use</span> <span class="tok-n">Digest::MD5</span>;
<span class="tok-k">use</span> <span class="tok-n">Terminal::ANSIColor</span>;
<span class="tok-k">use</span> <span class="tok-n">Terminal::Spinners</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命令行选项">24.2. 命令行选项</h3>
<div class="paragraph">
<p>Perl 5有许多用于处理命令行参数的很棒的模块，在我们使用 Getopt::Long 的原始脚本中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-c1"># Define our command-line arguments.</span>
<span class="tok-k">my</span> <span class="tok-nv">%opts</span> <span class="tok-o">=</span> <span class="tok-p">(</span> <span class="tok-s">&#39;blocksize&#39;</span> <span class="tok-o">=&gt;</span> <span class="tok-mi">16384</span> <span class="tok-p">);</span>
<span class="tok-n">GetOptions</span><span class="tok-p">(</span><span class="tok-o">\</span><span class="tok-nv">%opts</span><span class="tok-p">,</span> <span class="tok-s">&quot;verify=s&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;create=s&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;update=s&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;files&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;blocksize=s&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;help!&quot;</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Perl 6中，我们可以直接在MAIN方法中定义命令行选项。 我们使用多个调度来根据传递的参数来控制脚本的执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-n">MAIN</span> (<span class="tok-nb">Str</span> :<span class="tok-nv">$create</span>, *<span class="tok-nv">@files</span> <span class="tok-k">where</span> { <span class="tok-o">so</span> <span class="tok-nv">@files</span> }) { ... }
<span class="tok-k">multi</span> <span class="tok-n">MAIN</span> (<span class="tok-nb">Str</span> :<span class="tok-nv">$update</span>, *<span class="tok-nv">@files</span>) { ... }
<span class="tok-k">multi</span> <span class="tok-n">MAIN</span> (<span class="tok-nb">Str</span> :<span class="tok-nv">$verify</span>, *<span class="tok-nv">@files</span>) { ... }
<span class="tok-k">multi</span> <span class="tok-n">MAIN</span> (*<span class="tok-nv">@files</span> <span class="tok-k">where</span> { <span class="tok-o">so</span> <span class="tok-nv">@files</span> }) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也意味着我们不必定义帮助选项/sub，因为我们可以文档化我们的MAIN子例程，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#| Verify the MD5 sums in a file that conforms to md5sum output:</span>
<span class="tok-c1">#|</span>
<span class="tok-k">multi</span> <span class="tok-n">MAIN</span> (<span class="tok-nb">Str</span> :<span class="tok-nv">$verify</span>, *<span class="tok-nv">@files</span>) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能已经注意到Perl 6版本没有定义blocksize选项，我将回过头来看看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_io_读写文件">24.3. IO: 读写文件</h3>
<div class="paragraph">
<p>我们将校验和存储在一个文件中，其中每一行的格式都与GNU coreutils中的md5sum程序的输出相同：32个十六进制数字，两个空格和文件名。</p>
</div>
<div class="paragraph">
<p>一些基本的IO，我们使用正则表达式来解析每一行。 使用有意义的空格有助于保持每个正则表达式相当简洁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">load_md5sum_file</span>
{
	<span class="tok-k">my</span> (<span class="tok-nv">$filename</span>) = <span class="tok-nv">@_</span>;
	<span class="tok-k">my</span> <span class="tok-nv">@plan</span>;

	<span class="tok-nb">open</span>(<span class="tok-k">my</span> <span class="tok-nv">$fh</span>, <span class="tok-s">&#39;&lt;:utf8&#39;</span>, <span class="tok-nv">$filename</span>) <span class="tok-o">or</span> <span class="tok-k">die</span> <span class="tok-s">&quot;Couldn&#39;t open &#39;$filename&#39; : $!\n&quot;</span>;
	<span class="tok-k">my</span> <span class="tok-nv">$linenum</span> = <span class="tok-mi">0</span>;
	<span class="tok-k">while</span> (<span class="tok-k">my</span> <span class="tok-nv">$line</span> = <span class="tok-s">&lt;$fh&gt;</span>) {
		<span class="tok-nb">chomp</span> <span class="tok-nv">$line</span>;
		<span class="tok-nv">$linenum</span>++;
		<span class="tok-k">if</span> (<span class="tok-nv">$line</span> =~ /^(?\<span class="tok-n">p</span>{<span class="tok-n">ASCII_Hex_Digit</span>}{<span class="tok-mi">32</span>})  (?.*)<span class="tok-vg">$/</span>) {
			<span class="tok-c1"># Checksum and filename compatible with md5sum output.</span>
			<span class="tok-nb">push</span> <span class="tok-nv">@plan</span>, <span class="tok-n">create_plan_for_filename</span>($+{<span class="tok-n">filename</span>}, $+{<span class="tok-n">md5</span>});

		} <span class="tok-k">elsif</span> (<span class="tok-nv">$line</span> =~ /^(?\<span class="tok-n">p</span>{<span class="tok-n">ASCII_Hex_Digit</span>}{<span class="tok-mi">32</span>})  (?.*)<span class="tok-vg">$/</span>) {
			<span class="tok-c1"># Checksum and filename compatible with md5sum&#39;s manpage but not valid for the actual program.</span>
			<span class="tok-c1"># We&#39;ll use it, but complain.</span>
			<span class="tok-nb">print</span> <span class="tok-n">STDERR</span> <span class="tok-n">colored</span>(<span class="tok-s">&quot;Warning: &quot;</span>, <span class="tok-s">&#39;bold red&#39;</span>), <span class="tok-n">colored</span>(<span class="tok-s">&quot;md5sum entry &#39;&quot;</span>, <span class="tok-s">&#39;red&#39;</span>), <span class="tok-nv">$line</span>, <span class="tok-n">colored</span>(<span class="tok-s">&quot;&#39; on line $linenum of file $filename is using only one space, not two - this doesn&#39;t match the output of the actual md5sum program!.&quot;</span>, <span class="tok-s">&#39;red&#39;</span>), <span class="tok-s">&quot;\n&quot;</span>;
			<span class="tok-nb">push</span> <span class="tok-nv">@plan</span>, <span class="tok-n">create_plan_for_filename</span>($+{<span class="tok-n">filename</span>}, $+{<span class="tok-n">md5</span>});

		} <span class="tok-k">elsif</span> (<span class="tok-nv">$line</span> =~ /^\<span class="tok-o">s</span>*<span class="tok-vg">$/</span>) {
			<span class="tok-c1"># Blank line, ignore.</span>

		} <span class="tok-k">else</span> {
			<span class="tok-c1"># No idea. Best not to keep quiet, it could be a malformed checksum line and we don&#39;t want to just quietly skip the file if so.</span>
			<span class="tok-nb">print</span> <span class="tok-n">STDERR</span> <span class="tok-n">colored</span>(<span class="tok-s">&quot;Warning: &quot;</span>, <span class="tok-s">&#39;bold red&#39;</span>), <span class="tok-n">colored</span>(<span class="tok-s">&quot;Unrecognised md5sum entry &#39;&quot;</span>, <span class="tok-s">&#39;red&#39;</span>), <span class="tok-nv">$line</span>, <span class="tok-n">colored</span>(<span class="tok-s">&quot;&#39; on line $linenum of file $filename.&quot;</span>, <span class="tok-s">&#39;red&#39;</span>), <span class="tok-s">&quot;\n&quot;</span>;
			<span class="tok-nb">push</span> <span class="tok-nv">@plan</span>, { <span class="tok-n">error</span> =&gt; <span class="tok-s">&quot;Unrecognised md5sum entry&quot;</span> };
		}
	}
	<span class="tok-nb">close</span>(<span class="tok-nv">$fh</span>) <span class="tok-o">or</span> <span class="tok-k">die</span> <span class="tok-s">&quot;Couldn&#39;t close &#39;$filename&#39; : $!\n&quot;</span>;

	<span class="tok-k">return</span> <span class="tok-nv">@plan</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 6允许我们验证我们是否通过签名传递了实际存在的文件。 此外，我们用 grammar 替换正则表达式，如果需要，我们可以在脚本的不同位置使用该 grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">MD5SUM</span> {
	<span class="tok-k">token</span><span class="tok-n"> TOP</span>        {<span class="tok-sr"> &lt;md5&gt; &lt;spacer&gt; &lt;filehandle&gt; </span>}
	<span class="tok-k">token</span><span class="tok-n"> md5</span>        {<span class="tok-sr"> &lt;xdigit&gt; ** 32 </span>}
	<span class="tok-k">token</span><span class="tok-n"> spacer</span>     {<span class="tok-sr"> \s+ </span>}
	<span class="tok-k">token</span><span class="tok-n"> filehandle</span> {<span class="tok-sr"> .* </span>}
}

<span class="tok-k">sub</span> <span class="tok-n">load-md5sum-file</span> (<span class="tok-nb">Str</span> <span class="tok-nv">$filehandle</span> <span class="tok-k">where</span> { <span class="tok-nv">$filehandle</span>.<span class="tok-nb">IO</span>.<span class="tok-n">f</span> }) {
	<span class="tok-k">my</span> <span class="tok-n">MD5Plan</span> <span class="tok-nv">@plans</span>;

	<span class="tok-n">PARSE:</span> <span class="tok-k">for</span> <span class="tok-nv">$filehandle</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>(:<span class="tok-n">close</span>) -&gt; <span class="tok-nv">$line</span> {
		<span class="tok-k">next</span> <span class="tok-n">PARSE</span> <span class="tok-k">if</span> !<span class="tok-nv">$line</span>; <span class="tok-c1"># We don&#39;t get worked up over blank lines.</span>

		<span class="tok-k">my</span> <span class="tok-nv">$match</span> = <span class="tok-n">MD5SUM</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$line</span>);

		<span class="tok-k">if</span> (!<span class="tok-nv">$match</span>) {
			<span class="tok-nb">say</span> <span class="tok-vg">$*ERR:</span> <span class="tok-n">colored</span>(<span class="tok-s">&quot;Couldn&#39;t parse $line&quot;</span>, <span class="tok-nv">$ERROR_COLOUR</span>);
			<span class="tok-k">next</span> <span class="tok-n">PARSE</span>;
		}

		<span class="tok-k">if</span> (!<span class="tok-nv">$match&lt;filehandle&gt;</span>.<span class="tok-nb">IO</span>.<span class="tok-n">f</span>) {
			<span class="tok-nb">say</span> <span class="tok-vg">$*ERR:</span> <span class="tok-n">colored</span>(<span class="tok-s">&quot;{ $match&lt;filehandle&gt; } isn&#39;t an existing file.&quot;</span>, <span class="tok-nv">$ERROR_COLOUR</span>);
			<span class="tok-k">next</span> <span class="tok-n">PARSE</span>;
		}

		<span class="tok-k">if</span> (<span class="tok-nv">$match&lt;spacer&gt;</span>.<span class="tok-nb">chars</span> == <span class="tok-mi">2</span>) {
			<span class="tok-nv">@plans</span>.<span class="tok-nb">push</span>(<span class="tok-n">MD5Plan</span>.<span class="tok-nb">new</span>(<span class="tok-nv">$match&lt;filehandle&gt;</span>.<span class="tok-nb">Str</span>, <span class="tok-nv">$match&lt;md5&gt;</span>.<span class="tok-nb">Str</span>));
		}
		<span class="tok-k">else</span> {
			<span class="tok-nb">say</span> <span class="tok-vg">$*ERR:</span> <span class="tok-n">colored</span>(<span class="tok-s">&quot;&#39;$line&#39; does not match the output of md5sum: wrong number of spaces.&quot;</span>, <span class="tok-nv">$WARNING_COLOUR</span>);
			<span class="tok-nv">@plans</span>.<span class="tok-nb">push</span>(<span class="tok-n">MD5Plan</span>.<span class="tok-nb">new</span>(<span class="tok-nv">$match&lt;filehandle&gt;</span>.<span class="tok-nb">Str</span>, <span class="tok-nv">$match&lt;md5&gt;</span>.<span class="tok-nb">Str</span>));
		}
	}

	 <span class="tok-k">return</span> <span class="tok-nv">@plans</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>写出数据非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">sub</span> <span class="tok-nf">save_md5sum_file</span>
<span class="tok-p">{</span>
	<span class="tok-k">my</span> <span class="tok-p">(</span><span class="tok-nv">$filename</span><span class="tok-p">,</span> <span class="tok-nv">@plan</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-nv">@_</span><span class="tok-p">;</span>

	<span class="tok-k">my</span> <span class="tok-nv">$fh</span><span class="tok-p">;</span>
	<span class="tok-k">unless</span> <span class="tok-p">(</span><span class="tok-nb">open</span><span class="tok-p">(</span><span class="tok-nv">$fh</span><span class="tok-p">,</span> <span class="tok-s">&#39;&gt;:utf8&#39;</span><span class="tok-p">,</span> <span class="tok-nv">$filename</span><span class="tok-p">))</span> <span class="tok-p">{</span>
		<span class="tok-o">...</span>
	<span class="tok-p">}</span>
	<span class="tok-k">foreach</span> <span class="tok-k">my</span> <span class="tok-nv">$plan_entry</span> <span class="tok-p">(</span><span class="tok-nv">@plan</span><span class="tok-p">)</span> <span class="tok-p">{</span>
		<span class="tok-k">next</span> <span class="tok-k">unless</span> <span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">correct_md5</span><span class="tok-p">}</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">filename</span><span class="tok-p">};</span>
		<span class="tok-k">print</span> <span class="tok-nv">$fh</span> <span class="tok-s">&quot;$plan_entry-&gt;{correct_md5}  $plan_entry-&gt;{filename}\n&quot;</span><span class="tok-p">;</span>
	<span class="tok-p">}</span>
	<span class="tok-nb">close</span><span class="tok-p">(</span><span class="tok-nv">$fh</span><span class="tok-p">)</span> <span class="tok-ow">or</span> <span class="tok-nb">die</span> <span class="tok-s">&quot;Couldn&#39;t close &#39;$filename&#39; : $!\n&quot;</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，Perl 6默认以Unicode格式写入文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">save-md5sum-file</span> (<span class="tok-nb">Str</span> <span class="tok-nv">$filehandle</span>, <span class="tok-nv">@plans</span>) {
	<span class="tok-k">my</span> <span class="tok-nv">$io</span> = <span class="tok-nv">$filehandle</span>.<span class="tok-nb">IO</span>.<span class="tok-n">open:</span> :<span class="tok-n">w</span>;

	<span class="tok-n">WRITE:</span> <span class="tok-k">for</span> <span class="tok-nv">@plans</span> -&gt; <span class="tok-nv">$plan</span> {
		<span class="tok-k">next</span> <span class="tok-n">WRITE</span> <span class="tok-k">unless</span> <span class="tok-nv">$plan</span>.<span class="tok-n">computed-md5</span> &amp;&amp; <span class="tok-nv">$plan</span>.<span class="tok-n">filehandle</span>;

		<span class="tok-nv">$io</span>.<span class="tok-nb">say</span>(<span class="tok-s">&quot;{ $plan.computed-md5 }  { $plan.filehandle }&quot;</span>);
	}

	<span class="tok-nv">$io</span>.<span class="tok-nb">close</span>;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_获得md5校验和">24.4. 获得MD5校验和</h3>
<div class="paragraph">
<p>Perl 5版本的Digest::MD5使用了相当多的XS来提高性能。 XS中包含了以块的形式添加数据以进行整体解析的方法。 这允许我们使用ProgressBar向用户展示用户等待时的进度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">sub</span> <span class="tok-nf">run_md5_file</span>
<span class="tok-p">{</span>
	<span class="tok-k">my</span> <span class="tok-p">(</span><span class="tok-nv">$plan_entry</span><span class="tok-p">,</span> <span class="tok-nv">$progress_fn</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-nv">@_</span><span class="tok-p">;</span>

	<span class="tok-c1"># We use the OO interface to Digest::MD5 so we can feed it data a chunk at a time.</span>
	<span class="tok-k">my</span> <span class="tok-nv">$md5</span> <span class="tok-o">=</span> <span class="tok-nn">Digest::MD5</span><span class="tok-o">-&gt;</span><span class="tok-k">new</span><span class="tok-p">();</span>
	<span class="tok-k">my</span> <span class="tok-nv">$current_bytes_read</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
	<span class="tok-k">my</span> <span class="tok-nv">$buffer</span><span class="tok-p">;</span>
	<span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">start_time</span><span class="tok-p">}</span> <span class="tok-o">=</span> <span class="tok-nb">time</span><span class="tok-p">();</span>
	<span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">elapsed_time</span><span class="tok-p">}</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
	<span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">elapsed_bytes</span><span class="tok-p">}</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

	<span class="tok-c1"># 3 argument form of open() allows us to specify &#39;raw&#39; directly instead of using binmode and is a bit more modern.</span>
	<span class="tok-nb">open</span><span class="tok-p">(</span><span class="tok-k">my</span> <span class="tok-nv">$fh</span><span class="tok-p">,</span> <span class="tok-s">&#39;&lt;:raw&#39;</span><span class="tok-p">,</span> <span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">filename</span><span class="tok-p">})</span> <span class="tok-ow">or</span> <span class="tok-nb">die</span> <span class="tok-s">&quot;Couldn&#39;t open file $plan_entry-&gt;{filename}, $!\n&quot;</span><span class="tok-p">;</span>

	<span class="tok-c1"># Read the file in chunks and feed into md5.</span>
	<span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-nv">$current_bytes_read</span> <span class="tok-o">=</span> <span class="tok-nb">read</span><span class="tok-p">(</span><span class="tok-nv">$fh</span><span class="tok-p">,</span> <span class="tok-nv">$buffer</span><span class="tok-p">,</span> <span class="tok-nv">$opts</span><span class="tok-p">{</span><span class="tok-n">blocksize</span><span class="tok-p">}))</span> <span class="tok-p">{</span>
		<span class="tok-nv">$md5</span><span class="tok-o">-&gt;</span><span class="tok-n">add</span><span class="tok-p">(</span><span class="tok-nv">$buffer</span><span class="tok-p">);</span>
		<span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">elapsed_bytes</span><span class="tok-p">}</span> <span class="tok-o">+=</span> <span class="tok-nv">$current_bytes_read</span><span class="tok-p">;</span>
		<span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">elapsed_time</span><span class="tok-p">}</span> <span class="tok-o">=</span> <span class="tok-nb">time</span><span class="tok-p">()</span> <span class="tok-o">-</span> <span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">start_time</span><span class="tok-p">};</span>
		<span class="tok-o">&amp;</span><span class="tok-nv">$progress_fn</span><span class="tok-p">(</span><span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">elapsed_bytes</span><span class="tok-p">});</span>
	<span class="tok-p">}</span>
	<span class="tok-c1"># The loop will exit as soon as read() returns 0 or undef. 0 is normal EOF, undef indicates an error.</span>
	<span class="tok-nb">die</span> <span class="tok-s">&quot;Error while reading $plan_entry-&gt;{filename}, $!\n&quot;</span> <span class="tok-k">if</span> <span class="tok-p">(</span> <span class="tok-o">!</span> <span class="tok-nb">defined</span> <span class="tok-nv">$current_bytes_read</span><span class="tok-p">);</span>

	<span class="tok-nb">close</span><span class="tok-p">(</span><span class="tok-nv">$fh</span><span class="tok-p">)</span> <span class="tok-ow">or</span> <span class="tok-nb">die</span> <span class="tok-s">&quot;Couldn&#39;t close file $plan_entry-&gt;{filename}, $!\n&quot;</span><span class="tok-p">;</span>

	<span class="tok-c1"># We made it out of the file alive. Store the md5 we computed. Note that this resets the Digest::MD5 object.</span>
	<span class="tok-nv">$plan_entry</span><span class="tok-o">-&gt;</span><span class="tok-p">{</span><span class="tok-n">computed_md5</span><span class="tok-p">}</span> <span class="tok-o">=</span> <span class="tok-nv">$md5</span><span class="tok-o">-&gt;</span><span class="tok-n">hexdigest</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 6版本使用纯Perl并且缺少添加功能，因此我使用微调器而不是进度条。 我们还需要专门设置我们的编码，以避免在将二进制数据读取为Unicode时出现的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">calc-md5-sum</span> (<span class="tok-n">MD5Plan</span> <span class="tok-nv">$plan</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$md5</span> = <span class="tok-n">Digest::MD5</span>.<span class="tok-nb">new</span>;

    <span class="tok-nb">print</span> <span class="tok-s">&quot;Calculating MD5 sum for { $plan.filehandle }       &quot;</span>; <span class="tok-c1"># We need some space for the spinner to take up.</span>
	                                                             <span class="tok-c1"># I like &#39;bounce&#39;, so I need 6 spaces for the spinner</span>
	                                                             <span class="tok-c1"># + an extra one to separate it from the filehandle.</span>

	<span class="tok-k">my</span> <span class="tok-nb">Buf</span> <span class="tok-nv">$buffer</span> = <span class="tok-nv">$plan</span>.<span class="tok-n">filehandle</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">slurp</span>(:<span class="tok-n">close</span>, :<span class="tok-n">bin</span>);

	<span class="tok-k">my</span> <span class="tok-nv">$decoded</span> = <span class="tok-nv">$buffer</span>.<span class="tok-n">decode</span>(<span class="tok-s">&#39;iso-8859-1&#39;</span>);

	<span class="tok-k">my</span> <span class="tok-nv">$spinner</span> = <span class="tok-n">Spinner</span>.<span class="tok-nb">new</span>(<span class="tok-n">type</span> =&gt; <span class="tok-s">&#39;bounce&#39;</span>);

	<span class="tok-k">my</span> <span class="tok-nv">$promise</span> = <span class="tok-n">Promise</span>.<span class="tok-n">start</span>({
		<span class="tok-nv">$md5</span>.<span class="tok-n">md5_hex</span>(<span class="tok-nv">$decoded</span>)
	});

	<span class="tok-k">until</span> <span class="tok-nv">$promise</span>.<span class="tok-n">status</span> {
		<span class="tok-nv">$spinner</span>.<span class="tok-k">next</span>;
	}

	<span class="tok-nb">say</span> <span class="tok-s">&#39;&#39;</span>; <span class="tok-c1"># Add a new line after the spinner.</span>

	<span class="tok-nv">$plan</span>.<span class="tok-n">computed-md5</span> = <span class="tok-nv">$promise</span>.<span class="tok-n">result</span>;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结束之前的思考">24.5. 结束之前的思考</h3>
<div class="paragraph">
<p>我没有在我的系统上使用Perl 6版本因为Digest::MD5的低性能，在我的系统上我用md5sum调用替换它。 其他可能性是使用Inline::Perl5和Perl 5版本的Digest::MD5，或使用惊人的Perl 6原生调用接口来运行C实现。 我希望这篇文章能激发您将一些自己的Perl 5脚本移植到Perl 6，或者至少为您提供一些命令行交互的技巧。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_like_6_perls_in_a_pod_document_everything">25. 第二天 – Like 6 Perls in a Pod: document everything</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞节即将到来，圣诞老人很沮丧。 他的收件箱被来自全国各地的男孩和女孩的来信塞爆了。</p>
</div>
<div class="paragraph">
<p>但，</p>
</div>
<div class="paragraph">
<p>这些信是写给圣诞老人的吗？ 是否通过签名正确识别了孩子，以便将礼物送给对的人而不是给其他可能不值得的人？ 他们是针对圣诞老人的，而不是那些冒名顶替者，复活节兔子，或者更糟糕的是，三个所谓的 - 我不知道为什么 - 来自东方的智者？ 最糟糕的是，他个人是否必须通过他的王室和神圣的自我来检查所有这些东西？</p>
</div>
<div class="paragraph">
<p>没有。</p>
</div>
<div class="paragraph">
<p>Perl 6 以下面的方式来救援：</p>
</div>
<div class="paragraph">
<p><a href="https://docs.perl6.org/syntax/Creating%20grammars">grammar</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">unit</span> <span class="tok-k">grammar</span> <span class="tok-n">Santa-Letter</span>;

<span class="tok-k">token</span><span class="tok-n"> TOP</span>           {<span class="tok-sr"> &lt;dear&gt; \v+ &lt;paragraph&gt; [\v+ &lt;paragraph&gt;]* \v+ &lt;signature&gt;\v*</span>}
<span class="tok-k">token</span><span class="tok-n"> paragraph</span>     {<span class="tok-sr"> &lt;superword&gt;[ \h+ &lt;superword&gt;]+ </span>}
<span class="tok-k">token</span><span class="tok-n"> superword</span>     {<span class="tok-sr"> &lt;word&gt; | &lt;enhanced-word&gt;       </span>}
<span class="tok-k">token</span><span class="tok-n"> word</span>          {<span class="tok-sr"> \w+                            </span>}
<span class="tok-k">token</span><span class="tok-n"> enhanced-word</span> {<span class="tok-sr"> &lt;word&gt; [\,|\.|\:]              </span>}
<span class="tok-k">token</span><span class="tok-n"> dear</span>          {<span class="tok-sr"> Dear \h+ [S|s]anta [\,|\:]?    </span>}
<span class="tok-k">token</span><span class="tok-n"> signature</span>     {<span class="tok-sr"> \h+ \w+ \h* \w*                </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该单位向圣诞老人宣布一封致敬的信，其后是一个或多个段落，最后是一个签名，其前面应有一个水平的空格，如 <code>\h</code> 所示。</p>
</div>
<div class="paragraph">
<p>像这样的信件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Dear</span> <span class="tok-n">Santa:</span>

<span class="tok-n">This</span> <span class="tok-n">year</span> <span class="tok-n">I</span> <span class="tok-n">have</span> <span class="tok-n">been</span> <span class="tok-n">a</span> <span class="tok-n">really</span> <span class="tok-n">good</span> <span class="tok-n">boy</span>, <span class="tok-n">I</span> <span class="tok-n">have</span> <span class="tok-n">been</span> <span class="tok-n">in</span> <span class="tok-nb">all</span> <span class="tok-n">Squashathons</span>.

<span class="tok-n">So</span> <span class="tok-n">I</span> <span class="tok-nb">want</span> <span class="tok-n">a</span> <span class="tok-n">plush</span> <span class="tok-n">Camelia</span> <span class="tok-n">studded</span> <span class="tok-n">with</span> <span class="tok-n">diamonds</span>.

 <span class="tok-n">JJ</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个简单的脚本将使用该 grammar 并在单封信中获取签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Santa-Letter</span>;

<span class="tok-k">sub</span> <span class="tok-n">MAIN</span> ( <span class="tok-nb">Str</span> <span class="tok-nv">$file</span> = <span class="tok-s">&quot;letter.txt&quot;</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">$letter</span> =<span class="tok-nv">$file</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">slurp</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$parsed</span> = <span class="tok-n">Santa-Letter</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$letter</span>);
    <span class="tok-nb">say</span> <span class="tok-nv">$parsed&lt;signature&gt;</span>.<span class="tok-nb">trim</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好，很不错，但圣诞老人需要将这些数据与信件和索引一起提供给北极的CRM，同时他不得不与贸易战给他们造成严重破坏的供应商打交道&#8230;&#8203;所以他叫上他最亲密的IT精灵，来跟他一起做事。</p>
</div>
<div class="paragraph">
<p>演讲结束后，IT精灵站在那里，他的耳朵在颤抖。</p>
</div>
<div class="paragraph">
<p>“什么？”，圣诞老人咆哮道。 当然是以神圣的方式。</p>
</div>
<div class="paragraph">
<p>耳朵的尖变红了，并伴随着颤抖的辐射热量，使小冰柱融化并落到地上。</p>
</div>
<div class="paragraph">
<p>“你可以阅读消息来源，对吧？”</p>
</div>
<div class="paragraph">
<p>鲁道夫被冰柱融化的噪音惊醒，因为那是他的超级能量之一，介入。</p>
</div>
</div>
</div>
<h1 id="_大多数人都可以阅读源代码但每个人都可以阅读文档" class="sect0">大多数人都可以阅读源代码，但每个人都可以阅读文档。</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>鲁道夫说。</p>
</div>
<div class="paragraph">
<p>“而且每个人都应该写下这些文件”，他劝告道，他的头部前面有红色的鼻子。</p>
</div>
<div class="paragraph">
<p>圣诞老人嘟嚷着，但最终检查了他的 Santa-Letter grammar 的主分支并开始着手研究它。 当然，使用 Pod 6</p>
</div>
</div>
</div>
<h1 id="_pod_6_stands_for_plain_old_documentation_for_perl_6" class="sect0">Pod 6 stands for “Plain Old documentation for Perl 6”</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>它（显然）不是首字母缩略词。 Pod6 是一个帮助 Perl 6 编码人员编写文档的 DSL。 它是一种标记语言，它使用 <code>=</code> 来启动命令和段落级标记。 我们会做到这一点，但目前，Santa 意识到最好的事情之一是它如何与 Perl 6 本身集成。 因此，他对检查程序进行了第二次迭代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#| This reads a letter file</span>
<span class="tok-k">sub</span> <span class="tok-n">MAIN</span> ( <span class="tok-nb">Str</span> <span class="tok-nv">$file</span> = <span class="tok-s">&quot;letter.txt&quot;</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">$letter</span> =<span class="tok-nv">$file</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">slurp</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$parsed</span> = <span class="tok-n">Santa-Letter</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$letter</span>);
    <span class="tok-nb">say</span> <span class="tok-nv">$parsed&lt;signature&gt;</span>.<span class="tok-nb">trim</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在注释中有一个有趣的标志，<code>|</code>。 该标志将其与注释背后的代码联系起来。 在这种情况下，它是MAIN子例程。</p>
</div>
<div class="paragraph">
<p>圣诞老人将该程序发布到了生产环境。 IT精灵试图运行该程序，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>./get-signed.p6 --help</code></pre>
</div>
</div>
<div class="paragraph">
<p>它得到了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>Usage:
  ./get-signed.p6 <span class="tok-o">[]</span> -- This reads a letter file</code></pre>
</div>
</div>
<div class="paragraph">
<p>“有文档比没有文档更好”，他想。 但这还不够。 他完全使用自由软件进入北极票务系统，并要求提供更多文档并将任务分配给圣诞老人。 圣诞老人大声抗议，但顺从了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-cm">#|{ This reads a letter file in text format.</span>
<span class="tok-cm">With no arguments, it will read the C&lt;letter.txt&gt; file.</span>
<span class="tok-cm">}</span>
<span class="tok-k">sub</span> <span class="tok-n">MAIN</span> ( <span class="tok-nb">Str</span> <span class="tok-nv">$file</span> = <span class="tok-s">&quot;letter.txt&quot;</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">$letter</span> =<span class="tok-nv">$file</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">slurp</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$parsed</span> = <span class="tok-n">Santa-Letter</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$letter</span>);
    <span class="tok-nb">say</span> <span class="tok-nv">$parsed&lt;signature&gt;</span>.<span class="tok-nb">trim</span>;
    <span class="tok-nb">say</span> <span class="tok-nv">$=pod</span>[<span class="tok-mi">0</span>].<span class="tok-nb">perl</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>--help</code> 调用时，这会打印相同的消息。 这是文档。 运行时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">perl6</span> --<span class="tok-n">doc</span> <span class="tok-n">get-signed</span>.<span class="tok-n">p6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(
	<span class="tok-nb">Str</span> <span class="tok-nv">$file</span> = <span class="tok-s">&quot;letter.txt&quot;</span>,
)
<span class="tok-n">This</span> <span class="tok-n">reads</span> <span class="tok-n">a</span> <span class="tok-n">letter</span> <span class="tok-n">file</span> <span class="tok-n">in</span> <span class="tok-n">text</span> <span class="tok-n">format</span>. <span class="tok-n">With</span> <span class="tok-n">no</span> <span class="tok-n">arguments</span>, <span class="tok-n">it</span> <span class="tok-k">will</span> <span class="tok-nb">read</span> <span class="tok-n">the</span> <span class="tok-n">C</span> <span class="tok-n">file</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以Perl 6理解注释和附加到它的代码，并自动打印两者。 记录例程就像这样简单。</p>
</div>
<div class="paragraph">
<p>此外，当在实际文件上运行时，最后一句被踢了，它打印出来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Pod::Block::Declarator</span>.<span class="tok-nb">new</span>(<span class="tok-n">WHEREFORE</span> =&gt; <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (<span class="tok-nb">Str</span> <span class="tok-nv">$file</span> = <span class="tok-s">&quot;letter.txt&quot;</span>) { <span class="tok-cm">#`(Sub|81308800)</span> ... }, <span class="tok-n">config</span> =&gt; {}, <span class="tok-n">contents</span> =&gt; [])</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他语言中用于注释的其他DSL不同，例如Perl 5中的Markdown或Pod本身，Pod 6不仅是用于注释的DSL，它还是Perl 6本身的一部分，因此，它由Perl 6解析器解释，其内部结构可用于 <code>$=pod</code> 变量中的内省。 在这种情况下，注释是一个 <code>Pod::Block::Declarator</code>，该数据结构包含`WHEREFORE`键，其中包含声明的函数和注释。 但是，`contents`和`config`为空。 他们不应该这样做。</p>
</div>
<div class="paragraph">
<p>更重要的是，注释中使用的一点点实际格式不起作用。 更不用说实际模块没有真正文档化。 现在是圣诞老人不高兴了。</p>
</div>
</div>
</div>
<h1 id="_给模块添加文档" class="sect0">给模块添加文档</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>在编写实际代码之前，编写文档可能是您应该做的第一件事。 文档适用于模块客户端，但首先，它是作者的指南，模块应该做什么以及应该如何做的路线图。 如上所述，使用Pod 6可以很容易地记录单个方法或例程; 但是，模块的大图片视图也很方便。 这里是`Santa-Letter`的Pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="pod"><span></span>=begin pod

=head1 NAME

Santa-Letter - A grammar for letters to Santa for the L&lt;Perl 6 Advent Calendar|https://perl6advent.wordpress.com&gt;

=head1 SYNOPSIS

Parses letters formatted nicely and written by all good kids in the world.

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便地放在文件的末尾，当用`perl6 -doc Santa-Letter.pm6`调用时，或简单地`perl6 --doc Santa-Letter`如果它
已安装，甚至`p6doc Santa-Letter`如果是`perl6/doc`的
在场，会写出类似的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="pod"><span></span>NAME

Santa-Letter - A grammar for letters to Santa for the Perl 6 Advent
Calendar

SYNOPSIS

Parses letters formatted nicely and written by all good kids in the
world.</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是你会注意到这种类型的输出已经消除了一段标记。 `L`创建链接，但显然只有在输出格式支持时才这样做。 那么让我们试试其中一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>perl6 --doc<span class="tok-o">=</span>HTML Santa-Letter.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p>将输出大量代码，其中包括以下行：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Santa-Letter - A grammar for letters to Santa for the <a href="https://perl6advent.wordpress.com/">Perl 6 Advent Calendar</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>清楚地显示链接的输出。</p>
</div>
<div class="paragraph">
<p>事实上，此命令将使用 <code>Pod::To::HTML</code> 模块将 Pod 数据结构转换为 HTML。 使用任何其他东西将调用相应的模块，并且生态系统上有许多可用的<a href="https://modules.perl6.org/search/?q=pod%3A%3Ato">模块</a>。 例如，<code>Pod::To::Pager</code> 将使用系统的分页使东西更美观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>perl6 --doc<span class="tok-o">=</span>Pager Santa-Letter.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p>会输出这个</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/pager.png">img</a></p>
</div>
<div class="paragraph">
<p>此外，该文档遵循所有模块中使用的约定。 <code>NAME</code> 应描述名称和简短的 oneliner，告诉模块的内容，而 <code>SYNOPSIS</code> 包含更长的描述。 虽然这很好，但真正的文档应包含示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="pod"><span></span>=begin code

use Santa-Letter;

say Santa-Letter.parse(&quot;Dear Santa\nAll I want for Christmas\nIs you\n Mariah&quot;);

=end code</code></pre>
</div>
</div>
<div class="paragraph">
<p>示例包含在代码块中，从Pod6的角度来看，它们是 `Pod::Block::Code`对象。 实际上，这是一件好事。 让我们将这一小段代码添加到我们的 grammar 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">our</span> <span class="tok-nv">$pod</span> = <span class="tok-nv">$=pod</span>[<span class="tok-mi">0</span>];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Grammar 是类，它们具有类作用域的变量。 我们无法导出 <code>$=pod</code> 变量以避免与其他人发生冲突，但我们可以导出它，然后在我们的程序中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-nv">$Santa-Letter::pod</span>.<span class="tok-nb">perl</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，甚至更好， 安装 <code>Data::Dump</code> 并写下这样的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-n">Dump</span>( <span class="tok-nv">$Santa-Letter::pod</span>, :<span class="tok-n">indent</span>(<span class="tok-mi">4</span>), :<span class="tok-mi">3</span><span class="tok-n">max-recursion</span> );</code></pre>
</div>
</div>
<div class="paragraph">
<p>它使用我们声明的 <code>pod</code> 类变量, 并且它是这样打印的:</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/structure.png">img</a></p>
</div>
<div class="paragraph">
<p>这个树可以称为POM（Pod对象模型），除了与每个块一起使用的已知的 <code>name</code> 和 <code>config</code> 元数据外，还包括同一级别的Pod6块数组。 每个人都有通用属性和特定属性，例如标题中的级别。 无论如何，有趣的是我们作为示例使用的代码本身可以作为 <code>Pod::Block::Code</code> 对象的内容。</p>
</div>
<div class="paragraph">
<p>圣诞老人想，“哼哼”。 我们可以做得更好。 我们真的可以检查包含的代码是否有效吗？ 我们可以！ 我们来扩展一下 <code>SYNOPSIS</code> 部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="pod"><span></span>=head1 SYNOPSIS

Parses letters formatted nicely and written by all good kids in the world.

=begin code

use Santa-Letter;

say Santa-Letter.parse(&quot;Dear Santa\nAll I want for Christmas\nIs you\n Mariah&quot;);

=end code

You can also access particular elements in the letter, as long as they are included on the grammar

    my $letter=&quot;Dear Santa,\nI have not been that good.\nJust a paper clip will do\n Donald&quot;
    say Santa-Letter.parse($letter)&lt;signature&gt;

Also

=for code :notest :reason(&quot;Variable defined above&quot;)
say &quot;The letter signed by &quot;, Santa-Letter.parse($letter),
    &quot; has &quot;, Santa-Letter.parse($letter).elems, &quot; paragraphs&quot;;

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码可以在Pod中以不同方式表示。 第一个是已知的; 第二个使用缩进，即Markdown，来表示同一件事情。 我们也可以使用 <code>=for</code> 作为段落块，在这种情况下使用代码类型声明，并将继续直到下一个空白行。 这是一种不需要 <code>=end</code> 指令的缩写方式。 但是还有更多的东西：配置变量 <code>:notest :reason("Variable defined above")</code>。 这些配置变量是任意的，我们可以添加任意多个。 他们将转到块的 <code>config</code> 属性，我们可以使用它们。 这正是我们将在此脚本中处理代码示例的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">for</span> <span class="tok-nv">$Santa-Letter::pod</span>.<span class="tok-n">contents</span> -&gt; <span class="tok-nv">$block</span> {
    <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$block</span> !~~ <span class="tok-n">Pod::Block::Code</span>;
    <span class="tok-k">if</span> <span class="tok-nv">$block</span>.<span class="tok-n">config</span><span class="tok-s">&lt;notest&gt;</span> {
        <span class="tok-nb">say</span> <span class="tok-s">&quot;→ Block\n\t&quot;</span>~ <span class="tok-nv">$block</span>.<span class="tok-n">contents</span>
            ~ <span class="tok-s">&quot;\n\t❈ Not tested since \&#39;&quot;</span> ~ <span class="tok-nv">$block</span>.<span class="tok-n">config</span><span class="tok-s">&lt;reason&gt;</span> ~ <span class="tok-s">&quot;\&#39;&quot;</span>;
    } <span class="tok-k">else</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$code</span> = <span class="tok-nv">$block</span>.<span class="tok-n">contents</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot;&quot;</span>);
        <span class="tok-nb">say</span> <span class="tok-s">&quot;→ Block\n\t&quot;</span>~ <span class="tok-nv">$block</span>.<span class="tok-n">contents</span>;
        <span class="tok-k">try</span> {
            <span class="tok-n">EVAL</span> <span class="tok-nv">$code</span>;
        }
        <span class="tok-k">if</span> ( <span class="tok-vg">$!</span> ) {
            <span class="tok-nb">say</span> <span class="tok-s">&quot;\n\t✘ Produces error \&quot;$!\&quot;&quot;</span>, <span class="tok-s">&quot;\n&quot;</span> <span class="tok-o">xx</span> <span class="tok-mi">2</span>;
        } <span class="tok-k">else</span> {
            <span class="tok-nb">say</span> <span class="tok-s">&quot;✔ is OK\n&quot;</span>;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们在上面的结构中看到的那样，<code>contents`属性将包含一个第一级Pod块的数组，在我们的例子中包括我们想要求值的所有三个块（或者可能不包括）。 跳过非代码块（但也可以检查拼写）。 我们在这里做了两件有趣的事情：我们通过 `$block.config</code> 检查配置中的 <code>notest</code> 标志，如果是这种情况我们打印一些注释，但是如果它应该被测试，那么它是`EVAL`ed（我们需要使用`MONKEY-SEE-NO-EVAL` 指令。</p>
</div>
<div class="paragraph">
<p>圣诞老人在文档上运行它，瞧瞧！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>→ <span class="tok-nb">Block</span>
	<span class="tok-k">my</span> <span class="tok-nv">$letter</span>=<span class="tok-s">&quot;Dear Santa,\nI have not been that good.\nJust a paper clip will do\n Donald&quot;</span>
<span class="tok-nb">say</span> <span class="tok-n">Santa-Letter</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$letter</span>)

	✘ <span class="tok-n">Produces</span> <span class="tok-n">error</span> <span class="tok-s">&quot;Two terms in a row across lines (missing semicolon or comma?)&quot;</span>(

)</code></pre>
</div>
</div>
<div class="paragraph">
<p>他立刻感到高兴和谦卑。 一个简单的分号破坏了示例的质量。 它始终是分号。 他把分号放回到示例中，模块文档以快速的颜色通过了测试。</p>
</div>
</div>
</div>
<h1 id="_回到生产" class="sect0">回到生产</h1>
<div class="openblock partintro">
<div class="content">
提供了这个<a href="https://github.com/JJ/my-perl6-examples/blob/master/grammars/Santa-Letter.pm6">文档模块</a>，IT精灵非常高兴，他的耳朵停止颤抖和发红。 他也可以给每个 token 编写文档，但足够了，至少他有一些例子可以让应用程序运行。 鲁道夫睡得很熟，现在他必须在信件接收微服务和客户关系宏服务之间建立桥梁。 他可能会使用 <a href="https://cro.services/">Cro</a>，但这是另一天的主题。
</div>
</div>
<div class="sect1">
<h2 id="_第三天_perl_6_跳转到那儿">26. 第三天 – Perl 6 – 跳转到那儿</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a>是一个Perl 6驱动的命令行程序，我每天都使用它来浏览成堆的Perl并快速跳转到我的$EDITOR。 我尝试在编码时保持<a href="https://perl6advent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">流状态</a>，并且能够快速搜索文件然后直接跳转到编辑器中。</p>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 是一个简单的基于终端的前端到您最喜欢的代码搜索工具（例如，rgrep，ag，ack，git grep等）。 它会显示一个搜索结果列表，您可以在跳转到编辑文件之前快速浏览（例如，vim，nano，<a href="https://commaide.com/">comma</a>等）。</p>
</div>
<div class="paragraph">
<p>它的工作原理如下：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/11/jmp2-final.gif?w=600&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>最近我重构了 <strong>jmp</strong>，以便在 <a href="https://github.com/ab5tract/Terminal-Print">Terminal::Print</a> 模块的帮助下改进用户界面。 Terminal::Print 提供了一个方便的二维网格，用于在终端屏幕上绘图。 还有一个用于异步处理用户输入的模块。</p>
</div>
<div class="paragraph">
<p>这是 <strong>jmp</strong> 代码，只要用户按下某个键，它就会响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$in-supply</span> = <span class="tok-n">decoded-input-supply</span>;
<span class="tok-k">my</span> <span class="tok-nv">$timer</span>     = <span class="tok-n">Supply</span>.<span class="tok-n">interval</span>(<span class="tok-mi">1</span>).<span class="tok-n">map:</span> { <span class="tok-n">Tick</span> };
<span class="tok-k">my</span> <span class="tok-nv">$supplies</span>  = <span class="tok-n">Supply</span>.<span class="tok-n">merge</span>(<span class="tok-nv">$in-supply</span>, <span class="tok-nv">$timer</span>);

<span class="tok-n">react</span> {
    <span class="tok-n">whenever</span> <span class="tok-nv">$supplies</span> -&gt; <span class="tok-nv">$_</span> {
        <span class="tok-k">when</span> <span class="tok-n">Tick</span> {}
        <span class="tok-k">when</span> <span class="tok-s">&#39;CursorUp&#39;</span>                 { <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-n">cursor-up</span>;   }
        <span class="tok-k">when</span> <span class="tok-s">&#39;CursorDown&#39;</span>               { <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-n">cursor-down</span>; }
        <span class="tok-k">when</span> <span class="tok-s">&#39;CursorRight&#39;</span> | <span class="tok-s">&#39;PageDown&#39;</span> { <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-k">next</span>;        }
        <span class="tok-k">when</span> <span class="tok-s">&#39;CursorLeft&#39;</span>  | <span class="tok-s">&#39;PageUp&#39;</span>   { <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-n">previous</span>;    }
        <span class="tok-k">when</span> <span class="tok-s">&#39;x&#39;</span> | <span class="tok-s">&#39;X&#39;</span>                  { <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-n">exit-page</span>;   }
        <span class="tok-k">when</span> <span class="tok-s">&#39;e&#39;</span> | <span class="tok-s">&#39;E&#39;</span> {
             <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-n">edit-selected</span>(<span class="tok-nv">$!editor</span>);
        }
        <span class="tok-k">when</span> <span class="tok-nv">$_</span> ~~ <span class="tok-nb">Str</span> <span class="tok-o">and</span> <span class="tok-nv">$_</span>.<span class="tok-nb">ord</span> == <span class="tok-mi">13</span> {
             <span class="tok-c1"># the user pressed ENTER</span>
             <span class="tok-k">self</span>.<span class="tok-n">pager</span>.<span class="tok-n">edit-selected</span>(<span class="tok-nv">$!editor</span>);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码设置用户输入事件的异步 supply，并且只要事件触发（例如，用户按下PageUp），它就会做出反应。 但是如果用户一次按下很多键会发生什么？ 如何以有序的方式更新终端屏幕？</p>
</div>
<div class="paragraph">
<p>由于 Jonathan Worthington的 <a href="https://github.com/jnthn/oo-monitors">OO::Monitors</a> 模块和 <strong>monitor</strong> 关键字，解决方案在 <a href="https://github.com/ab5tract/Terminal-Print/blob/master/lib/Terminal/Print/Grid.pm6">Terminal::Print::Grid</a> 中找到。 这确保了一次只有一个线程可以在 grid 对象的方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">OO::Monitors</span>;
<span class="tok-n">unit</span> <span class="tok-n">monitor</span> <span class="tok-n">Terminal::Print::Grid</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>制作自己的 Perl 6 驱动的命令行工具是学习该语言的好方法。 如果您需要终端接口，请查看 <a href="https://github.com/ab5tract/Terminal-Print">Terminal::Print</a>。 为了加速命令行工具，将代码放在模块中是一个很好的技巧，因此Perl 6可以预编译它以加快启动时间（例如，<a href="https://github.com/nige123/jmp.nigelhamilton.com/blob/master/lib/JMP/CLI.pm">CLI.pm</a>）。</p>
</div>
<div class="paragraph">
<p>要安装jmp的第2版，首先安装<a href="https://perl6.org/downloads/">Perl 6</a>，然后使用<a href="https://github.com/ugexe/zef">zef</a> Perl 6模块管理器来安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>shell&gt; zef install jmp   <span class="tok-c1"># or zef upgrade jmp</span>
shell&gt; jmp config        <span class="tok-c1"># set up jmp to use your tools</span>
shell&gt; jmp find sub MAIN <span class="tok-c1"># find files containing &quot;sub MAIN&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>随着我们越来越接近圣诞节，请留意更多的命令行工具会被打开。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_献给新年的_perl_6_pod_新功能">27. 第四天 - 献给新年的 Perl 6 Pod 新功能</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_3">27.1. 介绍</h3>
<div class="paragraph">
<p>Rakudo NQP 文件包含解析 Perl 6 输入文件并将其转换为正在运行的 Perl 6 程序的代码。 本文将重点介绍最近使用 Rakudo NQP 文件时的经验所学到的一些细节。 这项工作涉及实现一些尚未实现的（NYI）Perl 6 POD 功能，我希望尽快合并这些更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="_准备">27.2. 准备</h3>
<div class="paragraph">
<p>使用的 NQP 文件保存在 <a href="https://github.com/rakudo/rakudo/tree/master/src/Perl6">https://github.com/rakudo/rakudo/src/Perl6</a> 的git存储库中。 有关我的开发设置和工作流的更多背景信息，请参阅 <a href="https://perl6advent.wordpress.com/2017/12/08/">https://perl6advent.wordpress.com/2017/12/08/</a> 上的 2017 年 Perl 6 Advent 条目。</p>
</div>
</div>
<div class="sect2">
<h3 id="_背景_2">27.3. 背景</h3>
<div class="paragraph">
<p>在我实现 NYI POD 功能的过程中，我已经给我添加到 Rakudo 仓库中的文档添加了注释: <a href="https://github.com/rakudo/rakudo/blob/master/docs/rakudo-nqp-and-pod-notes.md">rakudo/docs/rakudo-nqp-and-pod-notes.md</a>。我更新它，因为我发现了可能没有记录的新内容或者可能不容易找到其文档。该文件还包含一份完整的清单，通过我的计算，NYI POD 功能。以下是我已经工作了几个月的 NYI POD 功能列表，我希望在今年或新年初完成（以及每个功能的 roast 测试）:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NYI: %config :numbered 对于段落或分隔的POD块，使用'#'别名</p>
</li>
<li>
<p>NYI: POD 数据块</p>
</li>
<li>
<p>NYI: 以defn块术语格式化代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺少的项目描述在由 Damian Conway 博士撰写的精美制作的<a href="https://design.perl6.org/S26.html">概要S26</a>中，Larry Wall 是多产的得力男人 - 世界知名的 Perl 专家和著名的 Perl 作者。（请注意，现在很少有人在积极研究 POD，我的 NYI 功能列表可能不完整. S26 写得非常密实，如果不高度集中就不容易理解。我花了不少时间试图实现一个我认为已被描述的功能但我误读了文档！）</p>
</div>
<div class="paragraph">
<p>受许多因素的影响, 这项工作比我预期的时间更长，因为我将简要讨论，希望它可以帮助未来的开发人员。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rakudo_nqp_grammar_和_actions_学到的东西">27.4. Rakudo NQP grammar 和 actions: 学到的东西</h3>
<div class="sect3">
<h4 id="_match_对象">27.4.1. Match 对象</h4>
<div class="paragraph">
<p>在 token 上完成一个 grammar 匹配会产生一个匹配对象。 如果 token 具有与该 token 同名的 action 操作方法，则使用匹配对象作为隐式或显式参数调用该 action 方法。 按照惯例，'$/' 用作显式参数，但可以使用另一个名称（不要这样做！）。 我不建议依赖隐式参数。 如果需要，可以添加其他参数。</p>
</div>
<div class="paragraph">
<p>请注意，随着解析的继续，匹配数据将保留在匹配对象中，因为它在其他 token 和方法中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_断言">27.4.2. 断言</h4>
<div class="paragraph">
<p>断言在 POD 处理中发现的动态 grammar 中很重要。 在主匹配期间，通常必须选择几种匹配路径。 调试错误使用给我带来很多麻烦的一个例子是在定义分隔文本块的 token 内。</p>
</div>
<div class="paragraph">
<p>触发问题的测试用例是文件&#8217;b.t':</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-cm">=begin pod</span>
<span class="tok-cm">text</span>
<span class="tok-cm">=end pod</span>

<span class="tok-k">my</span> <span class="tok-nv">$o</span> = <span class="tok-nv">$=pod</span>[<span class="tok-mi">0</span>];
<span class="tok-nb">say</span> <span class="tok-nv">$o</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我对它运行perl6时，我得到了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ ./<span class="tok-n">perl6</span> <span class="tok-n">b</span>.<span class="tok-n">t</span>
<span class="tok-n">Preceding</span> <span class="tok-nb">context</span> <span class="tok-n">expects</span> <span class="tok-n">a</span> <span class="tok-n">term</span>, <span class="tok-k">but</span> <span class="tok-n">found</span> <span class="tok-nb">infix</span> = <span class="tok-n">instead</span>.
<span class="tok-n">Did</span> <span class="tok-n">you</span> <span class="tok-k">make</span> <span class="tok-n">a</span> <span class="tok-n">mistake</span> <span class="tok-n">in</span> <span class="tok-n">Pod</span> <span class="tok-n">syntax</span>?
<span class="tok-n">at</span> /<span class="tok-n">usr</span><span class="tok-o">/</span><span class="tok-n">local</span><span class="tok-o">/</span><span class="tok-n">people</span><span class="tok-o">/</span><span class="tok-n">tbrowde</span><span class="tok-o">/</span><span class="tok-n">mydata</span><span class="tok-o">/</span><span class="tok-n">tbrowde-home-bzr</span><span class="tok-o">/</span><span class="tok-n">perl6</span><span class="tok-o">/</span><span class="tok-n">perl6-repo-forks</span><span class="tok-o">/</span><span class="tok-n">rakudo</span><span class="tok-o">/</span><span class="tok-n">b</span>.<span class="tok-n">t:1</span>
------&gt; =<span class="tok-n">begin</span> ⏏<span class="tok-n">pod</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>不是很有帮助！ 然后我尝试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ ./<span class="tok-n">perl6</span> <span class="tok-n">b</span>.<span class="tok-n">t</span> --<span class="tok-n">ll-exception</span> <span class="tok-n">b</span>.<span class="tok-n">t</span>
<span class="tok-n">Preceding</span> <span class="tok-nb">context</span> <span class="tok-n">expects</span> <span class="tok-n">a</span> <span class="tok-n">term</span>, <span class="tok-k">but</span> <span class="tok-n">found</span> <span class="tok-nb">infix</span> = <span class="tok-n">instead</span>.
<span class="tok-n">Did</span> <span class="tok-n">you</span> <span class="tok-k">make</span> <span class="tok-n">a</span> <span class="tok-n">mistake</span> <span class="tok-n">in</span> <span class="tok-n">Pod</span> <span class="tok-n">syntax</span>?
   <span class="tok-n">at</span> <span class="tok-n">SETTING::src</span><span class="tok-o">/</span><span class="tok-n">core</span><span class="tok-o">/</span><span class="tok-nb">Exception</span>.<span class="tok-n">pm6:57</span>  (./<span class="tok-n">CORE</span>.<span class="tok-n">setting</span>.<span class="tok-n">moarvm:throw</span>)
 <span class="tok-nb">from</span> <span class="tok-n">src</span><span class="tok-o">/</span><span class="tok-n">Perl6</span><span class="tok-o">/</span><span class="tok-n">World</span>.<span class="tok-n">nqp:4955</span>  (<span class="tok-n">blib</span><span class="tok-o">/</span><span class="tok-n">Perl6</span><span class="tok-o">/</span><span class="tok-n">World</span>.<span class="tok-n">moarvm:throw</span>)
 <span class="tok-nb">from</span> <span class="tok-n">gen</span><span class="tok-o">/</span><span class="tok-n">moar</span><span class="tok-o">/</span><span class="tok-n">Perl6-Grammar</span>.<span class="tok-n">nqp:301</span>  (<span class="tok-n">blib</span><span class="tok-o">/</span><span class="tok-n">Perl6</span><span class="tok-o">/</span><span class="tok-nb">Grammar</span>.<span class="tok-n">moarvm:typed_panic</span>)
 <span class="tok-nb">from</span> <span class="tok-n">gen</span><span class="tok-o">/</span><span class="tok-n">moar</span><span class="tok-o">/</span><span class="tok-n">Perl6-Grammar</span>.<span class="tok-n">nqp:3609</span>  (<span class="tok-n">blib</span><span class="tok-o">/</span><span class="tok-n">Perl6</span><span class="tok-o">/</span><span class="tok-nb">Grammar</span>.<span class="tok-n">moarvm:</span>)
 ...<span class="tok-n">more</span> <span class="tok-n">files</span> <span class="tok-o">and</span> <span class="tok-n">line</span> <span class="tok-n">numbers</span>...</code></pre>
</div>
</div>
<div class="paragraph">
<p>更没用了！ 我尝试手动调查列出的文件，并且无法很好地解密代码以获得线索。</p>
</div>
<div class="paragraph">
<p>然后我尝试了另一个似乎有效的类似测试用例，文件&#8217;b2.t'：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-cm">=begin table</span>
<span class="tok-cm">text</span>
<span class="tok-cm">=end table</span>

<span class="tok-k">my</span> <span class="tok-nv">$o</span> = <span class="tok-nv">$=pod</span>[<span class="tok-mi">0</span>];
<span class="tok-nb">say</span> <span class="tok-nv">$o</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我对它运行perl6时，我得到了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ ./<span class="tok-n">perl6</span> <span class="tok-n">b2</span>.<span class="tok-n">t</span>
<span class="tok-n">Pod::Block::Table</span>
  <span class="tok-n">text</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>成功了！</p>
</div>
<div class="paragraph">
<p>但是这个失败的测试案例导致我几周尝试各种调试技术，直到最后，再次查看 Grammar.nqp 中的 <strong>delimited</strong> token 并在心里计算每个子匹配组正在做什么。 然后我仔细查看了包含<strong>断言</strong>的这个组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>[
    <span class="tok-c1"># defn-line is all text to the newline</span>
    <span class="tok-s">&lt;?{ ~$&lt;type&gt;</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;defn&#39;</span> }&gt; <span class="tok-c1"># &lt;== assertion: this is a &#39;defn&#39; type</span>
    \<span class="tok-o">s</span>* <span class="tok-s">&lt;defn-line&gt;</span>
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <strong>delimited</strong> 块 token 定义中，该组是顺序的而不是备选分支的一部分，必须匹配或全部 token 失败。不幸的是，失败的结果是 LTA , 对于这种情况是例外（这在 NQP 中并不常见，并且在其中工作的危险之一），并且我在寻找原因的过程中犯了太长时间的错误。欺骗我的一件事就是认为在一个没有得到满足的小组中的断言就像是'?'量词意味着忽略失败的匹配。在我仔细研究之后，我认为绝对不是这样！该组是否匹配，因此如果不匹配是可接受的，则量词必须在那里。</p>
</div>
<div class="paragraph">
<p>当我将 <strong>delimited</strong> token 的代码与 <strong>delimited_table</strong> 块 token 的起作用代码（之前我曾做过很多次）进行比较时，我看到 <strong>delimited_table</strong> 块中的同一匹配组具有'?'量词。在我给 <strong>delimited</strong> 块 token 中的组添加'?'后, 坏的测试用例再次起作用！</p>
</div>
</div>
<div class="sect3">
<h4 id="_调试">27.4.3. 调试</h4>
<div class="paragraph">
<p>对我来说最有用的 grammar 和 actions 调试技术是经典的：print 语句用于显示执行期间变量的值。该方法取决于哪种文件类型以及希望显示的值。以下是一些例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1、显示匹配对象的内容：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">do-foo</span>(<span class="tok-vg">$/</span>) {
    <span class="tok-nb">say</span>(<span class="tok-s">&quot;DEBUG: dumping method &#39;do-foo&#39; match:&quot;</span>);
    <span class="tok-nb">say</span>(<span class="tok-vg">$/</span>.<span class="tok-n">dump</span>);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>2、显示 grammar 匹配期间的结果</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">token</span><span class="tok-n"> blah</span> {<span class="tok-sr"></span>
<span class="tok-sr">    \h* $&lt;tok&gt; = [ foo | bar ] </span><span class="tok-c1"># &lt;== note &#39;=&#39; instead of &#39;:=&#39;</span><span class="tok-sr"></span>
<span class="tok-sr">    </span>{ <span class="tok-nb">say</span>(<span class="tok-s">&quot;DEBUG: \$&lt;tok&gt; value: &#39;{$&lt;tok&gt;}&#39;&quot;</span>); }<span class="tok-sr"></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，say 语句位于由花括号定义的块内。另请注意，即使在 NQP 源文件中，grammar 中使用的匹配对象的赋值运算符（'='）也不是绑定运算符（':='）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_动态变量">27.4.4. 动态变量</h4>
<div class="paragraph">
<p>grammar 和 action 大量使用动态变量（带有 <code>*</code> twigil 的变量，例如 <strong>$*IN-DEFN-BLOCK</strong>）。当需要在解析树中深入更改变量时，它们显示了它们的多功能性，并且该值在该解析的剩余部分（调用者）和子解析操作期间保持不变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_make_made_和_ast">27.4.5. make, made 和 ast</h4>
<div class="paragraph">
<p>尽管在所有已发表的 Perl 6 书籍中都有解释，但 grammar 和 action 中使用的术语 “make”，“made” 和 “ast”一直让我很困惑。感谢 Perl 6 作者 <strong>Moritz Lenz</strong> 对 <strong>IRC#perl6-dev</strong> 的问题的进一步解释和回答，他们更清楚了。</p>
</div>
<div class="paragraph">
<p>基本上，在 action 方法中，使用 <code>make</code> 会将当前值分配给匹配对象的 <code>.ast</code> 属性（或其别名 <code>.made</code>）和方法的名字。因此，给出以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">do-foo</span>(<span class="tok-vg">$/</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$val</span> = <span class="tok-mi">6</span>;
    <span class="tok-k">make</span> <span class="tok-nv">$val</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或可选地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">do-foo</span>(<span class="tok-vg">$/</span>) {
    <span class="tok-vg">$/</span>.<span class="tok-n">ast</span> := <span class="tok-mi">6</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们以后可以用这些惯用法中的一个来获得这个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span>(<span class="tok-s">&quot;do-foo.ast = {$&lt;do-foo&gt;.ast}&quot;</span>);  <span class="tok-c1"># output: 6</span>
<span class="tok-nb">say</span>(<span class="tok-s">&quot;do-foo.ast = {$&lt;do-foo&gt;.made}&quot;</span>); <span class="tok-c1"># output: 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>选择属性名称 <code>.ast</code> 是误导性的，因为它通常是指抽象语法树（AST），但在这种情况下，它与 AST 无关（尽管它可能具有 QAST 节点或任何其他类型的 NQP 对象值）。</p>
</div>
<div class="paragraph">
<p>请注意，分配给 <code>.ast</code> 属性的任何值都可能在 grammar 或 action 的稍后阶段被覆盖或删除。</p>
</div>
</div>
<div class="sect3">
<h4 id="_推迟生成qast节点">27.4.6. 推迟生成QAST节点</h4>
<div class="paragraph">
<p>有时在现有 grammar 中过早生成QAST节点阻止了正确的POD功能实现。一个例子是POD块的%config部分，它具有稍后解析所需的一些值。我正在做的部分工作需要重新编写%config匹配代码，因此在父对象（通常是POD类）的所有部分都已根据需要进行计算或构建之前，不会生成QAST节点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_隔离pod_only代码">27.4.7. 隔离POD-only代码</h4>
<div class="paragraph">
<p>当前的 grammar 和 grammar action 代码是复杂的，并且有些谜题，因为插入了块并且超过15年没有再次触及。因此，很难避免合并冲突与大而必要的变化。核心开发人员提出的一个建议是帮助将 POD 代码与其他代码分开，这就是创建一个与其他现有方言类似的单独POD方言（子语言）。我曾经认为这将是一个有用的改变，但现在，在理解了更多的代码后，创建一个单独的POD方言似乎并不是特别有利。但是，将所有 POD-only 代码移动到封闭类或 grammar 块的末尾将有助于在个人合并重叠代码时最小化版本控制意外和冲突。</p>
</div>
<div class="paragraph">
<p>因此，几个星期前我抓住机会（1）询问了几个关键开发人员，如 @lizmat 和 @jnthn，如果他们对该计划没有问题，（2）创建并测试这样的更改作为拉取请求（PR），（3）合并相当大的PR。不幸的是，这一重大变化令一些开发人员感到意外，并在 IRC#perl6-dev 上引发了一些惊讶的评论和投诉！幸运的是，发布经理 @AlexDaniel 运用了他惯用的外交和 git 代码讽刺风度，因为他让人群平静下来，并演示了改变实际上只是一个简单（但很大）的代码转换。所以我即将推出的PR不应该导致合并问题，因为我所知道的其他人都不会在同一个区域工作。</p>
</div>
<div class="paragraph">
<p>您可以通过在每个文件中搜索 POD-ONLY 来查看 Grammar.nqp 和 Actions.nqp 中 POD-only 代码的起点，您会发现：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#================================================================
# POD-ONLY CODE HANDLERS
#================================================================
# move ALL Pod-only [grammar|action] objects here</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">27.5. 总结</h3>
<div class="paragraph">
<p>我逐渐了解了如何改进 Rakudo Perl 6 grammar 和实现一些 NYI POD 功能的 actions，我希望尽快交付它们。在工作期间，我从困难的方式学到了许多课程，并希望我对 POD 解析的黑暗角落有所了解。</p>
</div>
<div class="paragraph">
<p>从任何主要编码项目中拿走的最后一课：为合并提交制作，测试和提交小的（即有限的）更改！我在 POD 特征的有时弯曲的解析路径中被包裹起来，我做了太多的改变，并且不能轻易地撤消它们。我希望我不要重蹈覆辙。</p>
</div>
<div class="paragraph">
<p>我希望你和你的 Perl 6ish 圣诞快乐和新年快乐，并且用 Charles Dickens 的 Tiny Tim（圣诞颂歌）不朽的话来说，“上帝保佑我们，每一个人！”
== 第五天 - 变量</p>
</div>
<div class="paragraph">
<p>这么简单的事，不是吗？ 变量是一个保存着值的名字。</p>
</div>
<div class="paragraph">
<p>有时候，它持有的值可能会被另一个值所取代 - 因此就是名字。 （根据外科医生的说法，没有经常变化的变量应该看医生，并要求被诊断为常数。）</p>
</div>
<div class="paragraph">
<p>虽然它们很容易掌握，而且基本上每种语言都有它们，但我今天的目标是让你相信变量实际上非常棘手。 好的方式！ 我的目的是让你被这篇博文绊倒，茫然，喃喃自语“我以为我知道变量，但我真的不知道&#8230;&#8203;&#8230;&#8203;”。</p>
</div>
<div class="paragraph">
<p>接近最后，<a href="http://github.com/masak/007/">实验语言007</a>也将会出现，我考虑变量这么多完全是这种语言的过错。</p>
</div>
</div>
<div class="sect2">
<h3 id="_左还是右">27.6. 左还是右？</h3>
<div class="paragraph">
<p>变量奇怪的第一种方式是它们以两种完全不同的方式使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$x</span> = <span class="tok-s">&quot;Christmas&quot;</span>;

<span class="tok-nb">say</span>(<span class="tok-s">&quot;Merry &quot;</span> ~ <span class="tok-nv">$x</span>);       <span class="tok-c1"># reading</span>
<span class="tok-nv">$x</span> = <span class="tok-s">&quot;Easter&quot;</span>;            <span class="tok-c1"># writing</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有时我们使用变量来读取值，有时我们使用它们来写一个值。但在这两种情况下，语法看起来完全一样！一些较旧的语言（例如Forth）实际上对这两种用法有不同的语法，我喜欢它们。但是这样的惯例似乎并没有幸存到现代。</p>
</div>
<div class="paragraph">
<p>相反，我们通过语法位置来区分这两种用法。如果你在赋值的左侧，那么你就被写了。否则，你正在被读取。</p>
</div>
<div class="paragraph">
<p>在文献中，这两种用途分别称为 <strong>lvalues</strong> 和 <strong>rvalues</strong>。分别为“左”和“右”。</p>
</div>
<div class="paragraph">
<p>Rvalues 非常正常，与我们对变量的一般考虑方式相对应;他们只是计算它们包含的值。然而，Lvalues 很奇怪。它们更像是盒子，你可以把东西放入（或内存位置？引用？），或者如果不是盒子本身，那么分离的能力放入其中。如果 lvalues 有一个类型，它看起来像 <code>(T) &#8594; void</code>，接受 <code>T</code> 但不返回任何东西的东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数">27.7. 参数</h3>
<div class="paragraph">
<p>变量对现代编程至关重要。 还有一个原则表明它们完全没有必要。</p>
</div>
<div class="paragraph">
<p>那就对了！ Tennent 的通信原则！ （我知道你在想什么。不，我说的不是那个 <a href="https://en.wikipedia.org/wiki/Tenth_Doctor">Tennant</a>。</p>
</div>
<div class="paragraph">
<p>这个原则主要指向一种在程序中重写所有变量声明的方法，因此它们是参数声明。 一个例子应该足以展示一般原则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># Before</span>
<span class="tok-k">my</span> <span class="tok-nv">$veggie</span> = <span class="tok-s">&quot;potato&quot;</span>;
<span class="tok-nb">say</span> <span class="tok-s">&quot;$veggie, and that&#39;s all I have to say about that!&quot;</span>;

<span class="tok-c1"># After</span>
(-&gt; <span class="tok-nv">$veggie</span> {
    <span class="tok-nb">say</span> <span class="tok-s">&quot;$veggie, and that&#39;s all I have to say about that!&quot;</span>;
})(<span class="tok-s">&quot;potato&quot;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>看看变量声明如何变成参数声明，相应的赋值转变为参数？有经验的（或者我应该说是饱受争吵蹂躏的）JavaScript开发人员将这种结构视为 <a href="https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript">IIFE</a>。</p>
</div>
<div class="paragraph">
<p>由于我们总能进行这种转换，因此我们并不需要变量。只有参数。我主要是告诉你这个，所以你可以有点特别感谢你不必用参数编写你的代码。</p>
</div>
<div class="paragraph">
<p>关于Tennent的通信原则的最后注释：它的原始用法在<a href="https://en.wikipedia.org/wiki/S-algol#Semantic_principles">维基百科</a>上有简要描述。它基本上被遗忘了，直到Java即将获得闭包并且它的名称被调用并且原则<a href="https://softwareengineering.stackexchange.com/questions/116395/what-is-the-good-explanation-of-tennents-correspondence-principle">被过度使用了一些</a>，也许。</p>
</div>
</div>
<div class="sect2">
<h3 id="_动态范围">27.8. 动态范围</h3>
<div class="paragraph">
<p>在Perl 6中，只要变量范围偏离词法范围，变量就会产生额外的“twigil”（sigil之后的可选符号）。这些替代范围中最重要的可能只是动态范围。</p>
</div>
<div class="paragraph">
<p>同样，我们最好用一个例子来说明差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$lexical</span> = <span class="tok-s">&quot;mainline&quot;</span>;
<span class="tok-k">my</span> <span class="tok-vg">$*dynamic</span> = <span class="tok-s">&quot;mainline&quot;</span>;

<span class="tok-k">sub</span> <span class="tok-n">foo</span>() {
    <span class="tok-k">my</span> <span class="tok-nv">$lexical</span> = <span class="tok-s">&quot;foo&quot;</span>;
    <span class="tok-k">my</span> <span class="tok-vg">$*dynamic</span> = <span class="tok-s">&quot;foo&quot;</span>;
    <span class="tok-n">bar</span>();
}

<span class="tok-k">sub</span> <span class="tok-n">bar</span>() {
    <span class="tok-nb">say</span> <span class="tok-nv">$lexical</span>;       <span class="tok-c1"># &quot;mainline&quot;</span>
    <span class="tok-nb">say</span> <span class="tok-vg">$*dynamic</span>;      <span class="tok-c1"># &quot;foo&quot;</span>
}

<span class="tok-n">foo</span>();</code></pre>
</div>
</div>
<div class="paragraph">
<p>忘记处女座和Saggitarius以及其他占星术的迹象。对于你更深层次的个性而言，值得做的唯一区别就是你是在做词法查找还是动态查找。毕竟，只有两种人。</p>
</div>
<div class="paragraph">
<p>无论我们喜不喜欢，查找都是一个过程。我们给了一个名字，然后我们去找相应的值。我知道，这令人沮丧。但无论如何，让我们这样做，看看它在哪里。</p>
</div>
<div class="paragraph">
<p>对于 <code>$lexical</code>，通过查看程序文本本身来进行查找。该变量是否定义在我们所在的最小范围内，那个 <code>bar</code> sub？ （事实并非如此。）然后我们向外走，直到周围的范围 - 这最终成为整个计划的范围。它是在那里定义的吗？是!真幸运的是我们从查找中获得胜利，其值为 <code>“mainline”</code>。</p>
</div>
<div class="paragraph">
<p><code>$*dynamic</code> - 请注意名字中的星号？我告诉过你有占星术！ - 我们也从最里面的范围，<code>bar</code> sub开始，并在那里寻找定义。 （我们找不到。）但现在发生了一些不同的事情。我们不会向外跟随块结构，而是向上跟随调用链。谁调用给我们？ <code>foo</code>。这就是我们的目标。那里有定义吗？是!所以我们已经完成并且成功了。</p>
</div>
<div class="paragraph">
<p>从历史的角度来看，动态查找是“明显的”，大多数语言最初都有它。词汇查找只是逐渐证明了它的价值，现在已成为流行病。 Perl 5实际上跨越了这段历史，而我的变量是词法，但较旧的我们/包变量是动态的。这就是你在历史发生时从身边得到的东西。</p>
</div>
<div class="paragraph">
<p>在Perl 6中，我们也通过禁止术语“父范围”来履行自己的职责。在一个词法和动态查找的世界里，它太混乱了。相反，我们更喜欢术语 <code>OUTER</code>（用于词法查找）和`CALLER`（用于动态查找）。</p>
</div>
<div class="paragraph">
<p>如果可能的话，Perl 6中的一些结构（例如`return`和`next`）会尝试词法，但如果找不到任何词汇周围的东西来“附加”，则会回归到动态。这种类型的行为似乎没有真正的学术术语，所以Perl 6的概要称它为“lexotic”。</p>
</div>
</div>
<div class="sect2">
<h3 id="_宏里面的变量">27.9. 宏里面的变量</h3>
<div class="paragraph">
<p>还在我这儿？礼包。 我们来谈谈宏。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">experimental</span> :<span class="tok-n">macros</span>;

<span class="tok-k">macro</span> <span class="tok-n">moo</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$counter</span> = <span class="tok-mi">0</span>;
    <span class="tok-nb">quasi</span> {
        <span class="tok-nb">say</span> ++<span class="tok-nv">$counter</span>;
    }
}

<span class="tok-k">for</span> ^<span class="tok-mi">10</span> {
    <span class="tok-n">moo</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个简单的宏，只是将代码中的 <code>++$counter</code> 注入到 <code>for</code> 循环中。该程序将在各行上打印从1到10的所有数字。</p>
</div>
<div class="paragraph">
<p>很好，但&#8230;&#8203;&#8230;&#8203;怎么样？请注意，宏扩展代码引用 <code>$counter</code>，但词法查找（如上所述）将找不到在周围词法范围内声明的变量。但是，这个程序仍然有效，或者更确切地说，是有效的。</p>
</div>
<div class="paragraph">
<p>那么使程序运作的基本原则是什么呢？事实证明，通过一个非常幸运的偶然事件，在宏体内定义的变量可以被“无法统一”并被左值替换。注入的代码说 <code>$counter` 实际上看起来更像是 `☐</code>，其中 <code>☐</code> 代表那个（代表不可代理的）左值。</p>
</div>
<div class="paragraph">
<p>我知道这是一件小事，但是当我最终把它放在一起时我很高兴。事实上，我很高兴我把它写成<a href="https://github.com/masak/007/issues/410">github iuuse</a>，只是为了确保细节都能解决。请继续关注此项的实现，从而保持卫生。</p>
</div>
<div class="paragraph">
<p>（对于那些在家中保持分数的人来说，卫生宏是<a href="http://news.perlfoundation.org/2011/09/hague-grant-application-implem.html">本拨款申请</a>中的里程碑D3。）</p>
</div>
<div class="paragraph">
<p>需要明确的是 - 这更像是一种实现意图。 Perl 6（和007）尚未实现完全卫生。但是，拥有明确的前进道路令人振奋。</p>
</div>
<div class="paragraph">
<p>无论如何，这是变数。他们很可爱，有点奇怪，但最后我们很高兴他们在那里。快乐的历险。☺</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_懒惰精灵与勤劳精灵">28. 第六天 - 懒惰精灵与勤劳精灵</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对圣诞老人来说，圣诞节总是一年中最忙碌的时刻。 幸运的是，圣诞老人有很多帮手。 他们总是做一些小工作和家务，只是为了创造最好的假日季节体验！</p>
</div>
<div class="paragraph">
<p><a href="https://modules.perl6.org/dist/Object::Delayed">Object::Delayed</a> 模块为圣诞老人的快乐精灵添加了两个非常有趣的精灵！ 他们的名字是 <code>slack</code> 和 <code>catchup</code>!</p>
</div>
<div class="sect2">
<h3 id="_lazy_slack">28.1. Lazy slack</h3>
<div class="paragraph">
<p>那个懒散的(<code>slack</code>)精灵确实非常懒惰。 懒散(<code>slack</code>)精灵不会做任何事情，直到你真的需要他去做。 虽然人们可以认为这是精灵中非常糟糕的性格特征，但它也是一种非常生态的特征。 人们可以认为这个懒散的(<code>slack</code>)精灵是他们所有人中最环保的精灵！ 你有多少次要求精灵为你做点事情，然后却没用过那个精灵辛苦工作的结果？ 即使它只是到处移动的被回收的电子，但仍然需要能量来移动它们！ 特别是, 如果那些电子被用来告诉其他精灵做一些遥远的事情，就像在外部数据库中一样！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Object::Delayed</span>;
<span class="tok-k">my</span> <span class="tok-nv">$dbh</span> = <span class="tok-n">slack</span> { <span class="tok-n">DBIish</span>.<span class="tok-nb">connect</span>(...) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是你需要的 <code>$dbh</code> 变量，它只在实际需要时才与数据库建立连接。 当然，如果你想对该数据库进行查询，那么也可以使其懒惰！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Object::Delayed</span>;
<span class="tok-k">my</span> <span class="tok-nv">$dbh</span> = <span class="tok-n">slack</span> { <span class="tok-n">DBIish</span>.<span class="tok-nb">connect</span>(...) }
<span class="tok-k">my</span> <span class="tok-nv">$sth</span> = <span class="tok-n">slack</span> { <span class="tok-nv">$dbh</span>.<span class="tok-n">prepare</span>(...) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于语句句柄也是懒惰的，因此在实际需要之前它实际上不会进行查询准备。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Object::Delayed</span>;
<span class="tok-k">my</span> <span class="tok-nv">$dbh</span> = <span class="tok-n">slack</span> { <span class="tok-n">DBIish</span>.<span class="tok-nb">connect</span>(...) }
<span class="tok-k">my</span> <span class="tok-nv">$sth</span> = <span class="tok-n">slack</span> { <span class="tok-nv">$dbh</span>.<span class="tok-n">prepare</span>(...) }
<span class="tok-c1"># lotsa program</span>
<span class="tok-k">if</span> <span class="tok-nv">$needed</span> {
    <span class="tok-nv">$sth</span>.<span class="tok-n">execute</span>;  <span class="tok-c1"># opens database handle + prepares query</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如果 <code>$needed</code> 为 true，调用 <code>.execute</code> 函数将使 <code>$sth</code> 成为一个真正的 statemement 句柄，因为它使 <code>$dbh</code> 成为真正的数据库句柄。 那不是很好吗？ 因为如果你不需要它，所有进行查询准备的精灵都可以做其他的事情，而建立数据库连接的精灵也可以做其他事情。 更不用说数据库中的精灵们根本不知道你最初计划建立一个数据库连接！</p>
</div>
<div class="paragraph">
<p>当然，如果您确实需要数据库连接，那么告诉数据库的精灵们您已经完成了这一点总是一个好主意。 在 Perl 6 中，这不会自动发生，因为圣诞老人不会跟踪每个精灵的行为。 圣诞老人喜欢委派责任！ 当您离开需要数据库句柄的代码部分时，通常会告诉数据库精灵您已完成的工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">LEAVE</span> .<span class="tok-n">disconnect</span> <span class="tok-n">with</span> <span class="tok-nv">$dbh</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAVE</code> 精灵的特殊之处在于，当你离开被称为 <code>LEAVE</code> 精灵的街区时，它将完成被告知要做的事情。 在这种情况下，如果 <code>$dbh</code> 被定义，则在 <code>$<em></code> 上调用 <code>.disconnect</code> 方法：<code>with</code> 精灵不仅测试是否定义了给定值，还设置 <code>$</em></code>。</p>
</div>
<div class="paragraph">
<p>但是，但是，不会检查 <code>$dbh</code> 是否实际定义了与数据库的连接？ 不，这个懒散的精灵足够聪明，如果你问的是某个东西是 <code>.defined</code>，还是真或假，它实际上不会开始为你做这项工作。 这与 <code>catchup</code> 精灵有什么不同！</p>
</div>
</div>
<div class="sect2">
<h3 id="_尽力追赶">28.2. 尽力追赶</h3>
<div class="paragraph">
<p>如果懒惰精灵是圣诞老人雇佣的最环保的精灵，那么 <code>catchup</code> 肯定是最红的精灵。 因为你总是试图赶上 <code>catchup</code> 精灵。 但是追赶精灵似乎只是非常勤奋。</p>
</div>
<div class="paragraph">
<p>当你告诉 <code>catchup</code> 精灵做某事时，<code>catchup</code> 精灵会立即找到另一个精灵去做实际的工作并告诉你它完成了。 最有可能的不是。 当你真正想要使用你要求 <code>catchup</code> 精灵做的结果时，有两种可能性：如果另一个精灵完成并且结果可用，你将立即从`catchup` 精灵那里得到它。 如果其他精灵尚未完成，它将让你等到另一个精灵完成：它会迫使你赶上！ 那看起来怎么样？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Object::Delayed</span>;
<span class="tok-k">my</span> <span class="tok-nv">$foo</span> = <span class="tok-n">catchup</span> { <span class="tok-nb">sleep</span> <span class="tok-mi">5</span>; <span class="tok-s">&quot;Merry&quot;</span> }      <span class="tok-c1"># sleep is just</span>
<span class="tok-k">my</span> <span class="tok-nv">$bar</span> = <span class="tok-n">catchup</span> { <span class="tok-nb">sleep</span> <span class="tok-mi">9</span>; <span class="tok-s">&quot;Christmas&quot;</span> }  <span class="tok-c1"># another word</span>
<span class="tok-k">my</span> <span class="tok-nv">$baz</span> = <span class="tok-n">catchup</span> { <span class="tok-nb">sleep</span> <span class="tok-mi">8</span>; <span class="tok-s">&quot;everyone&quot;</span> }   <span class="tok-c1"># for baking</span>
<span class="tok-nb">say</span> “<span class="tok-nv">$foo</span> <span class="tok-nv">$bar</span>, <span class="tok-nv">$baz</span>!”;
<span class="tok-nb">say</span> “<span class="tok-n">Took</span> { <span class="tok-n">now</span> - <span class="tok-k">INIT</span> <span class="tok-n">now</span> } <span class="tok-n">seconds</span>”;
<span class="tok-c1"># Merry Christmas, everybody!</span>
<span class="tok-c1"># Took 9.008 seconds</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，<code>catchup</code> 精灵有另外3个精灵正在制作那些带有甜味硬壳釉的精美烘焙刻字，每个字母花费大约一秒钟。 如果只有一个精灵这样做，它至少需要5 + 9 + 8 = 22秒。 感谢 <code>catchup</code> 精灵，只用了9秒多一点！ 快了两倍多！</p>
</div>
<div class="paragraph">
<p>当然，如果所有其他精灵都在忙着做其他事情，那实际上可能需要一点时间而不是超过9秒。 或者甚至超过22秒，如果其他精灵正在处理更重要的事情，而不是用正确的玻璃烘焙字母。 所以你的精灵里程可能会有所不同。 你不想过度劳累你的精灵，也不要太久。 几秒钟应该没问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_use_the_right_elf">28.3. Use the right elf</h3>
<div class="paragraph">
<p>如果你想尽可能的绿色，请使用 <code>slack</code> 精灵。 如果你想要它，并且你现在想要它（嗯，尽快），那么如果你能够合理地确定有足够的其他精灵来完成实际的工作，那么使用 <code>catchup</code> 精灵是一个选择！</p>
</div>
<div class="paragraph">
<p>参与此博客文章的所有精灵们都欢呼！ 你真的非常确定没有任何快速，慢速或任何其他精灵以任何方式受到伤害。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_细胞自动机">29. 第七天 – 细胞自动机</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天的降临日历帖子涉及Cellular Automata。</p>
</div>
<div class="paragraph">
<p>什么是细胞自动机？我很高兴你问！它们是由几个部分组成的系统：由细胞组成的一种场或“世界”，每个细胞可以在任何点处的一组状态，描述每个细胞可见的细胞的“邻域” ，以及一套规则，用于管理一个单元将其状态改变为什么状态以及其邻域中所有单元的状态。</p>
</div>
<div class="paragraph">
<p>当然，这是一个非常抽象的描述，所以让我举一些个别部分的例子，希望能让你了解你在细胞自动机中看到的内容：</p>
</div>
<div class="paragraph">
<p>在典型的世界中，你可能会发现细胞像串珠一样排列，或者像国际象棋或中国跳棋板上的字段。您还可以组成更多奇特的配置：任何二维场都可以映射到任何表面，例如<a href="https://en.wikipedia.org/wiki/Stanford_bunny">斯坦福兔子</a></p>
</div>
<div class="paragraph">
<p>你可以在野外找到的状态集是“从0到n的数字”，“这里有细菌”，“黑白颜色”（或更多）。由于您基本上可以将任何信息表示为“数字”，并且允许任意数量的状态，因此还可以存在表示“此时此单元格中有多少粒子在上升，下降，向左或向右移动的状态？ “作为整数或甚至浮点数。</p>
</div>
<div class="paragraph">
<p>邻域可以被认为是细胞“连接在一起”的模式。典型的社区将是“前面的一个，后面的一个”的“串珠”字段，以及“北，东，南，西”或“北，东北，东，东南，南，西南，西，西北“对于棋盘场 - 这两个分别是冯诺依曼附近和摩尔附近。</p>
</div>
<div class="paragraph">
<p>管理每个单元的邻域中的状态的一组规则将导致哪个状态转到其他状态可被视为特定元胞自动机的核心。</p>
</div>
<div class="paragraph">
<p>在今天的降临日历中，我们将探索您可能称之为最简单的自动机。我们将字段串起来像字符串上的珠子，我们将尝试一个或两个和一些不同的状态集。</p>
</div>
<div class="paragraph">
<p>为了让家里的人感兴趣，我将为您提供链接，让您在浏览器中运行示例代码，或在家中使用您的本地perl6编译器！</p>
</div>
<div class="sect2">
<h3 id="_为学习而做">29.1. 为学习而做</h3>
<div class="paragraph">
<p>让我们开始，然后：</p>
</div>
<div class="paragraph">
<p>首先，我们需要什么？世界上必须有存储空间，需要一些代码来获得一个符合条件的邻居，以及一些代码来计算一个单元的下一个状态，给定它自己的状态和邻居的状态。最重要的是，我们想看看发生了什么，所以我们也有一些代码。</p>
</div>
<div class="paragraph">
<p>在确定每个单元可以具有哪些状态之后，我们将知道什么存储适合于我们的世界。使用8位整数数组将允许我们从任何不超过255个单独状态的状态集中进行选择。不过，让我们现在共计3个州。我们可以随心所欲地初始化世界，但是将每个字段设置为随机有效状态是一个很好的起点。另一个是将一个状态的单个单元放在中间，并使每个其他单元具有不同的状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">constant</span> <span class="tok-n">number-of-states</span> = <span class="tok-mi">3</span>;
<span class="tok-k">constant</span> <span class="tok-n">field-width</span> = <span class="tok-mi">60</span>;

<span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@field</span>;

<span class="tok-k">sub</span> <span class="tok-n">init-field</span> {
    <span class="tok-nv">@field</span> = (^<span class="tok-n">number-of-states</span>).<span class="tok-n">roll</span>(<span class="tok-n">field-width</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示字段非常简单，具体取决于我们使用的输出。 这是一段可以在任何控制台中运行的代码，下面是一个6pad的链接，它在pad的HTML部分输出很少的彩色方块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">output-a-row</span> {

    <span class="tok-k">for</span> <span class="tok-nv">@field</span> {
        <span class="tok-c1"># Using the unicode characters &quot;Light shade&quot;, &quot;Medium shade&quot;, and &quot;Dark shade&quot;</span>
        <span class="tok-c1"># and printing each field twice so they look square rather than slim and tall.</span>
        <span class="tok-nb">print</span> [<span class="tok-s">&quot;\x2591&quot;</span>, <span class="tok-s">&quot;\x2592&quot;</span>, <span class="tok-s">&quot;\x2593&quot;</span>][<span class="tok-nv">$_</span>] <span class="tok-o">x</span> <span class="tok-mi">2</span>
    }

    <span class="tok-nb">say</span> <span class="tok-s">&quot;&quot;</span>;
}

<span class="tok-n">init-field</span>;
<span class="tok-n">output-a-row</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<a href="https://perl6.github.io/6pad/#baa305eff795ed1f7a1957b83a9d4b26">浏览器</a>中运行此代码。 你将不得不等待几秒钟来获得当前相当大的perl6编译器在javascript中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_走在前面">29.2. 走在前面</h3>
<div class="paragraph">
<p>从单个行到单元格的自动机的模拟运行需要一次完成一大堆部分。</p>
</div>
<div class="paragraph">
<p>根据他们的定义，细胞自动机将同时推进其所有细胞。 我们当然不会去云端获得拥有与我们领域中的单元一样多的cpu内核的机器。 我们将通过一个简单的循环遍历所有字段来解决“根据它们的相邻单元格在上一步中计算每个单元格的下一步”。</p>
</div>
<div class="paragraph">
<p>对此的直接方法是在每个步骤之后有一个额外的字段来放置计算结果并将结果复制到“真实”字段数组中。 让我们尝试一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">simulate-step</span> {
    <span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@output</span>;

    <span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
        <span class="tok-c1"># do some calculations here</span>
    }

    <span class="tok-nv">@field</span> = <span class="tok-nv">@output</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看我们需要什么来进行计算：新状态将取决于邻域和单元本身。 我们可能会选择最明显的社区：一个小区，它是该领域的前身和继承者。 但等等，第一个和最后一个细胞会发生什么？ 让我们假装他们有一个额外的邻居，它总是处于0状态。这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">simulate-step</span> {
    <span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@output</span>;

    <span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$left</span>   = <span class="tok-nv">$x</span> - <span class="tok-mi">1</span> &lt; <span class="tok-mi">0</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> - <span class="tok-mi">1</span>];
        <span class="tok-k">my</span> <span class="tok-nv">$middle</span> = <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span>];
        <span class="tok-k">my</span> <span class="tok-nv">$right</span>  = <span class="tok-nv">$x</span> + <span class="tok-mi">1</span> &gt;= <span class="tok-n">field-width</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];

        <span class="tok-c1"># do some calculation with $left, $middle, and $right</span>
        <span class="tok-c1"># then push the result into @output</span>
    }

    <span class="tok-nv">@field</span> = <span class="tok-nv">@output</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，我们终于到了我们需要决定我们的细胞自动机实际上应该首先做什么的地方。 但是，当我们甚至没有赋予“0,1和2”状态的含义时，我们应该如何弄清楚它应该做什么？</p>
</div>
<div class="paragraph">
<p>答案很简单！ 从字面上理解这一切。</p>
</div>
</div>
<div class="sect2">
<h3 id="_制作东西">29.3. 制作东西</h3>
<div class="paragraph">
<p>我的意思是，我们目前并不关心细胞自动机的作用，只要看起来不错。 那么为什么不预先通过滚动一些想象中的骰子来预先决定应该发生什么呢？</p>
</div>
<div class="paragraph">
<p>为此目的，它有助于知道有多少可能的“配置”甚至是单元及其邻居所在的。幸运的是，这很简单。 您可以将三个单元格想象为由三位数组成的数字，并且每个数字都允许为0,1或2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mo">000</span>  <span class="tok-mo">001</span>  <span class="tok-mo">002</span>
<span class="tok-mo">010</span>  <span class="tok-mo">011</span>  <span class="tok-mo">012</span>
<span class="tok-mo">020</span>  <span class="tok-mo">021</span>  <span class="tok-mo">022</span>
<span class="tok-mi">100</span>  <span class="tok-mi">101</span>  <span class="tok-mi">102</span>
<span class="tok-mi">110</span>  <span class="tok-mi">111</span>  <span class="tok-mi">112</span>
<span class="tok-mi">120</span>  <span class="tok-mi">121</span>  <span class="tok-mi">122</span>
<span class="tok-mi">200</span>  <span class="tok-mi">201</span>  <span class="tok-mi">202</span>
<span class="tok-mi">210</span>  <span class="tok-mi">211</span>  <span class="tok-mi">212</span>
<span class="tok-mi">220</span>  <span class="tok-mi">221</span>  <span class="tok-mi">222</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我没有陷入困境，那就是左，中，右单元组成的所有可能性。 就像四位二进制数可以是2⁴数之一一样，这个三位三进制数可以是  3³。 这意味着我们只需要在0到2之间选择  3³ 个数字，上面表格中每个数字一个。</p>
</div>
<div class="paragraph">
<p>这样做真的很愉快！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@lookup-table</span> = (^<span class="tok-n">number-of-states</span>).<span class="tok-n">roll</span>(<span class="tok-mi">3</span><span class="tok-n">³</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且给定 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 变量，我们可以将第一个与9相乘，第二个与3相乘，并将三者相加以获得查询表中的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">simulate-step</span> {
    <span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@output</span>;

    <span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$left</span>   = <span class="tok-nv">$x</span> - <span class="tok-mi">1</span> &lt; <span class="tok-mi">0</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> - <span class="tok-mi">1</span>];
        <span class="tok-k">my</span> <span class="tok-nv">$middle</span> = <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span>];
        <span class="tok-k">my</span> <span class="tok-nv">$right</span>  = <span class="tok-nv">$x</span> + <span class="tok-mi">1</span> &gt;= <span class="tok-n">field-width</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];

        <span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$left</span> * <span class="tok-mi">9</span> + <span class="tok-nv">$middle</span> * <span class="tok-mi">3</span> + <span class="tok-nv">$right</span>;

        <span class="tok-nv">@output</span>.<span class="tok-nb">push</span>(<span class="tok-nv">@lookup-table</span>[<span class="tok-nv">$index</span>]);
    }

    <span class="tok-nv">@field</span> = <span class="tok-nv">@output</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行这个已经让我们看起来很闪亮。 我们需要做的就是连接潜艇：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">constant</span> <span class="tok-n">number-of-states</span> = <span class="tok-mi">3</span>;
<span class="tok-k">constant</span> <span class="tok-n">field-width</span> = <span class="tok-mi">60</span>;

<span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@field</span>;

<span class="tok-k">sub</span> <span class="tok-n">init-field</span> {
    <span class="tok-nv">@field</span> = (^<span class="tok-n">number-of-states</span>).<span class="tok-n">roll</span>(<span class="tok-n">field-width</span>);
}
<span class="tok-n">init-field</span>;

<span class="tok-k">sub</span> <span class="tok-n">output-a-row</span> {

    <span class="tok-k">for</span> <span class="tok-nv">@field</span> {
        <span class="tok-c1"># Using the unicode characters &quot;Light shade&quot;, &quot;Medium shade&quot;, and &quot;Dark shade&quot;</span>
        <span class="tok-c1"># and printing each field twice so they look square rather than slim and tall.</span>
        <span class="tok-nb">print</span> [<span class="tok-s">&quot;\x2591&quot;</span>, <span class="tok-s">&quot;\x2592&quot;</span>, <span class="tok-s">&quot;\x2593&quot;</span>][<span class="tok-nv">$_</span>] <span class="tok-o">x</span> <span class="tok-mi">2</span>
    }

    <span class="tok-nb">say</span> <span class="tok-s">&quot;&quot;</span>;
}

<span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@lookup-table</span> = (^<span class="tok-n">number-of-states</span>).<span class="tok-n">roll</span>(<span class="tok-mi">3</span><span class="tok-n">³</span>);

<span class="tok-k">sub</span> <span class="tok-n">simulate-step</span> {
    <span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@output</span>;

    <span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$left</span>   = <span class="tok-nv">$x</span> - <span class="tok-mi">1</span> &lt; <span class="tok-mi">0</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> - <span class="tok-mi">1</span>];
        <span class="tok-k">my</span> <span class="tok-nv">$middle</span> = <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span>];
        <span class="tok-k">my</span> <span class="tok-nv">$right</span>  = <span class="tok-nv">$x</span> + <span class="tok-mi">1</span> &gt;= <span class="tok-n">field-width</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];

        <span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$left</span> * <span class="tok-mi">9</span> + <span class="tok-nv">$middle</span> * <span class="tok-mi">3</span> + <span class="tok-nv">$right</span>;

        <span class="tok-nv">@output</span>.<span class="tok-nb">push</span>(<span class="tok-nv">@lookup-table</span>[<span class="tok-nv">$index</span>]);
    }

    <span class="tok-nv">@field</span> = <span class="tok-nv">@output</span>;
}

<span class="tok-k">for</span> ^<span class="tok-mi">100</span> {
    <span class="tok-n">simulate-step</span>;
    <span class="tok-n">output-a-row</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果在某些时候看起来非常有趣！ 当然，我们需要通过随机查找表获得幸运。 如果你有很多无趣的东西，我喜欢这里的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@lookup-table</span> = <span class="tok-s">&lt;0 0 2 0 0 0 1 2 0 0 1 1 2 1 1 2 1 1 1 0 1 2 2 0 2 1 1&gt;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是<a href="https://perl6.github.io/6pad/#cb1856d301959e3d3dca95925eab2bee">6pad</a>的链接，您可以在浏览器中试用它。</p>
</div>
<div class="paragraph">
<p>第三，这是我的机器的截图，以防您在移动设备上阅读或其他无法运行perl6的内容。</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/fish-tmp_112.png">img</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_改变">29.4. 改变</h3>
<div class="paragraph">
<p>现在我们的模拟器完成了它应该做的事情，让我们通过一些调整获得一些乐趣。</p>
</div>
<div class="paragraph">
<p>首先，让我们看看增加不同状态数量需要做些什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">constant</span> <span class="tok-n">number-of-states</span> = <span class="tok-mi">4</span>;

<span class="tok-c1"># the size of the lookup table should be based on the number of states</span>
<span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@lookup-table</span> = (^<span class="tok-n">number-of-states</span>).<span class="tok-n">roll</span>(<span class="tok-n">number-of-states³</span>);

<span class="tok-k">sub</span> <span class="tok-n">output-a-row</span> {

    <span class="tok-k">for</span> <span class="tok-nv">@field</span> {
        <span class="tok-c1"># add unicode character &quot;Full block&quot; for the fourth state</span>
        <span class="tok-nb">print</span> [<span class="tok-s">&quot;\x2591&quot;</span>, <span class="tok-s">&quot;\x2592&quot;</span>, <span class="tok-s">&quot;\x2593&quot;</span>, <span class="tok-s">&quot;\x2588&quot;</span>][<span class="tok-nv">$_</span>] <span class="tok-o">x</span> <span class="tok-mi">2</span>
    }

    <span class="tok-nb">say</span> <span class="tok-s">&quot;&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且计算也需要基于状态数进行计算：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$left</span> * <span class="tok-n">number-of-states</span> * <span class="tok-n">number-of-states</span>
            + <span class="tok-nv">$middle</span> * <span class="tok-n">number-of-states</span>
            + <span class="tok-nv">$right</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那已经是它了！ 到目前为止，甚至都不是很难。</p>
</div>
</div>
<div class="sect2">
<h3 id="_改变邻居">29.5. 改变邻居</h3>
<div class="paragraph">
<p>现在这个更有趣了。 更改邻域将需要我们的计算循环来为索引计算获取更多变量，并且查找表也将再次更改其大小。</p>
</div>
<div class="paragraph">
<p>让我们回到3个状态而不是4个状态，用一个只有一个单元格的单元替换邻域：我们将采用单元格的前任及其后继者，但忽略单元格本身。 然后我们添加了前任的前任和后继者的继任者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># three states, but four neighbors</span>
<span class="tok-k">constant</span> <span class="tok-n">number-of-states</span> = <span class="tok-mi">3</span>;
<span class="tok-k">constant</span> <span class="tok-n">number-of-neighbors</span> = <span class="tok-mi">4</span>;

<span class="tok-c1"># ...</span>

<span class="tok-c1"># exponentiate number-of-states with number-of-neighbors, like</span>
<span class="tok-c1"># you would to get a number-of-neighbors number in base number-of-states.</span>
<span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@lookup-table</span> = (^<span class="tok-n">number-of-states</span>).<span class="tok-n">roll</span>(<span class="tok-n">number-of-states</span> ** <span class="tok-n">number-of-neighbors</span>);

<span class="tok-k">sub</span> <span class="tok-n">simulate-step</span> {
   <span class="tok-k">my</span> <span class="tok-nb">int8</span> <span class="tok-nv">@output</span>;

   <span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
       <span class="tok-k">my</span> <span class="tok-nv">$leftleft</span>   = <span class="tok-nv">$x</span> &lt;= <span class="tok-mi">1</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> - <span class="tok-mi">2</span>];
       <span class="tok-k">my</span> <span class="tok-nv">$left</span>       = <span class="tok-nv">$x</span> == <span class="tok-mi">0</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> - <span class="tok-mi">1</span>];

       <span class="tok-k">my</span> <span class="tok-nv">$right</span>      = <span class="tok-nv">$x</span> == <span class="tok-n">field-width</span> - <span class="tok-mi">1</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];
       <span class="tok-k">my</span> <span class="tok-nv">$rightright</span> = <span class="tok-nv">$x</span> &gt;= <span class="tok-n">field-width</span> - <span class="tok-mi">2</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">2</span>];

       <span class="tok-c1"># many multiplications later ...</span>
       <span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$leftleft</span> * <span class="tok-n">number-of-states</span> * <span class="tok-n">number-of-states</span> * <span class="tok-n">number-of-states</span>
                   + <span class="tok-nv">$left</span>   * <span class="tok-n">number-of-states</span> * <span class="tok-n">number-of-states</span>
                   + <span class="tok-nv">$right</span>  * <span class="tok-n">number-of-states</span>
                   + <span class="tok-nv">$rightright</span>;

       <span class="tok-nv">@output</span>.<span class="tok-nb">push</span>(<span class="tok-nv">@lookup-table</span>[<span class="tok-nv">$index</span>]);
   }

   <span class="tok-nv">@field</span> = <span class="tok-nv">@output</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/fish-tmp_113.png">img</a></p>
</div>
<div class="paragraph">
<p>这是试用它的 <a href="https://perl6.github.io/6pad/#98c06c9c9aafaf36c9c4fbf320d9c9cc">6pad</a></p>
</div>
<div class="paragraph">
<p>可悲的是，它似乎只是让输出变得更加混乱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_优化机会">29.6. 优化机会？</h3>
<div class="paragraph">
<p>目前，代码是高性能和可读性之间的折衷。 它也可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">for</span> (<span class="tok-mi">0</span>, |<span class="tok-nv">@field</span>, <span class="tok-mi">0</span>).<span class="tok-n">rotor</span>(<span class="tok-mi">3</span> =&gt; -<span class="tok-mi">2</span>) -&gt; (<span class="tok-nv">$left</span>, <span class="tok-nv">$middle</span>, <span class="tok-nv">$right</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$index</span> = :<span class="tok-mi">3</span>[<span class="tok-nv">$right</span>, <span class="tok-nv">$middle</span>, <span class="tok-nv">$left</span>];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然我的直觉告诉我，这会明显变慢。</p>
</div>
<div class="paragraph">
<p>但是我们可以使代码更快一点，甚至不会牺牲太多的可读性！</p>
</div>
<div class="paragraph">
<p>有一件事我们的计算循环太多了：数组访问！ 连续三次访问每个单元格：一旦它变为 <code>$right</code>，再次变为 <code>$middle</code>，另一次变为 <code>$left</code>。</p>
</div>
<div class="paragraph">
<p>那么我们怎样才能做得更好呢？ 我想到的第一件事是让变量 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 在迭代之间保持不变并通过以下方式移动单元格值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$left</span>   = <span class="tok-mi">0</span>;
<span class="tok-k">my</span> <span class="tok-nv">$middle</span> = <span class="tok-nv">@field</span>[<span class="tok-mi">0</span>];
<span class="tok-k">my</span> <span class="tok-nv">$right</span>  = <span class="tok-nv">@field</span>[<span class="tok-mi">1</span>];

<span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$left</span> * <span class="tok-n">number-of-states</span> * <span class="tok-n">number-of-states</span>
            + <span class="tok-nv">$middle</span> * <span class="tok-n">number-of-states</span>
            + <span class="tok-nv">$right</span>;

    <span class="tok-nv">@output</span>.<span class="tok-n">push:</span> <span class="tok-nv">@lookup-table</span>[<span class="tok-nv">$index</span>];
    <span class="tok-nv">$left</span> = <span class="tok-nv">$middle</span>;
    <span class="tok-nv">$middle</span> = <span class="tok-nv">$right</span>;
    <span class="tok-nv">$right</span> = <span class="tok-nv">$x</span> + <span class="tok-mi">1</span> &gt;= <span class="tok-n">field-width</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很酷，我们甚至已经摆脱了 <code>$x</code> vs field-width的检查！ 但是还有另一件事情一遍又一遍地发生，我们可以做一点点简单。 我们可以让 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 变量已经保存了添加所需的确切值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$left</span>   = <span class="tok-mi">0</span>;
<span class="tok-k">my</span> <span class="tok-nv">$middle</span> = <span class="tok-nv">@field</span>[<span class="tok-mi">0</span>] * <span class="tok-mi">3</span>;
<span class="tok-k">my</span> <span class="tok-nv">$right</span>  = <span class="tok-nv">@field</span>[<span class="tok-mi">1</span>];

<span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$left</span> + <span class="tok-nv">$middle</span> + <span class="tok-nv">$right</span>;

    <span class="tok-nv">@output</span>.<span class="tok-n">push:</span> <span class="tok-nv">@lookup-table</span>[<span class="tok-nv">$index</span>];
    <span class="tok-nv">$left</span> = <span class="tok-nv">$middle</span> * <span class="tok-mi">3</span>;
    <span class="tok-nv">$middle</span> = <span class="tok-nv">$right</span> * <span class="tok-mi">3</span>;
    <span class="tok-nv">$right</span> = <span class="tok-nv">$x</span> + <span class="tok-mi">1</span> &gt;= <span class="tok-n">field-width</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我认为看起来很整洁！</p>
</div>
</div>
<div class="sect2">
<h3 id="_其他变化">29.7. 其他变化？</h3>
<div class="paragraph">
<p>我遇到的一种细胞自动机是每个细胞都有机会在每一步上进行计算的细胞自动机，否则只需保持其状态一步。 让我们看看它是如何实现的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">constant</span> <span class="tok-n">probability</span> = <span class="tok-mf">0.75e0</span>;

<span class="tok-k">my</span> <span class="tok-nv">$left</span>   = <span class="tok-mi">0</span>;
<span class="tok-k">my</span> <span class="tok-nv">$middle</span> = <span class="tok-nv">@field</span>[<span class="tok-mi">0</span>] * <span class="tok-mi">3</span>;
<span class="tok-k">my</span> <span class="tok-nv">$right</span>  = <span class="tok-nv">@field</span>[<span class="tok-mi">1</span>];

<span class="tok-k">for</span> ^<span class="tok-n">field-width</span> -&gt; <span class="tok-nv">$x</span> {
    <span class="tok-k">if</span> <span class="tok-nb">rand</span> &lt; <span class="tok-n">probability</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$index</span> = <span class="tok-nv">$left</span> + <span class="tok-nv">$middle</span> + <span class="tok-nv">$right</span>;

        <span class="tok-nv">@output</span>.<span class="tok-n">push:</span> <span class="tok-nv">@lookup-table</span>[<span class="tok-nv">$index</span>];
    }
    <span class="tok-k">else</span> {
        <span class="tok-nv">@output</span>.<span class="tok-n">push:</span> <span class="tok-nv">$middle</span>;
    }
    <span class="tok-nv">$left</span> = <span class="tok-nv">$middle</span> * <span class="tok-mi">3</span>;
    <span class="tok-nv">$middle</span> = <span class="tok-nv">$right</span> * <span class="tok-mi">3</span>;
    <span class="tok-nv">$right</span> = <span class="tok-nv">$x</span> + <span class="tok-mi">1</span> &gt;= <span class="tok-n">field-width</span> ?? <span class="tok-mi">0</span> !! <span class="tok-nv">@field</span>[<span class="tok-nv">$x</span> + <span class="tok-mi">1</span>];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>较低的概率很容易被发现，因为它们会使得到的图像看起来垂直拉伸。 较高的概率可以导致完全规则的模式保持大部分完整，但在某些时候可以在一两个点被分解。</p>
</div>
<div class="paragraph">
<p>这是给你的截图！</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/fish-tmp_114.png">img</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_这有用吗">29.8. 这有用吗？</h3>
<div class="paragraph">
<p>细胞自动机通常是非常通用的，甚至非常简单的自动机也可以处理通用计算，如“<a href="http://mathworld.wolfram.com/Rule110.html">规则110</a>”。还有更复杂的自动机，如<a href="https://en.wikipedia.org/wiki/Von_Neumann_universal_constructor">Von Neumann的能够自我复制的机器</a>和WireWorld，它已被用来构建<a href="https://www.quinapalus.com/wires11.html">一台可以计算素数并在七段显示器上显示它们的小机器</a>。</p>
</div>
<div class="paragraph">
<p>非常令人惊讶的是，有一台<a href="http://conwaylife.com/wiki/Turing_machine">图灵机</a>带有一个由非常受欢迎的生命游戏构建的文字磁带，并且可能更令人惊讶的是，它可以计算并显示<a href="http://conwaylife.com/wiki/OTCA_metapixel">生命游戏的生命游戏配置</a>。</p>
</div>
<div class="paragraph">
<p>总而言之，我发现细胞自动机是一个引人入胜的话题。在这篇文章中几乎没有提到二维细胞自动机，但除了本节已经提到的那些之外，还有许多有趣的自动机。</p>
</div>
<div class="paragraph">
<p>实施方面，您很可能不会使用CPU代码来模拟细胞自动机。至少，你不会使用遍历每个单独单元的循环 - 请参阅奇妙的<a href="http://conwaylife.com/wiki/Hashlife">HashLife算法</a>，该算法将世界切换为经常出现的越来越大的块，并立即执行许多全世界的步骤。否则，您很可能会在GPU上模拟CA，当每个单元的代码运行相同时，它会提供极高的并行度。</p>
</div>
<div class="paragraph">
<p>感谢您通过这个非常长的帖子陪伴我！</p>
</div>
<div class="paragraph">
<p>我希望我甚至可以唤醒对细胞自动机的奇妙和广阔世界的空洞兴趣！</p>
</div>
<div class="paragraph">
<p>每个人都有一个可爱的十二月！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_让你的_perl_6_grammar_紧凑一点">30. 第八天 — 让你的 Perl 6 grammar 紧凑一点</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎来到今年的 Perl 6 Advent Calendar 的第8天！</p>
</div>
<div class="paragraph">
<p>Grammars 是使 Perl 6 成为一种优秀编程语言的众多因素之一。 我甚至不会尝试预测轮询的结果，以便在 grammars，Unicode 支持，并发功能，超运算符或集合语法之间进行选择，或者选择 Whatever star。 谷歌发现了自己在互联网上发布的最好的 Perl 6 功能列表。</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/screen-shot-2018-12-01-at-13-15-01.png">img</a></p>
</div>
<div class="paragraph">
<p>无论如何，今天我们将讨论 Perl 6 grammars，我将分享一些技巧，用于使 grammars 更紧凑。</p>
</div>
<div class="sect2">
<h3 id="_1_拆分_actions">30.1. 1.拆分 actions</h3>
<div class="paragraph">
<p>假设您正在编写 grammar 来解析 Perl 的变量声明。 您希望它与以下语句匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$s</span>; <span class="tok-k">my</span> <span class="tok-nv">@a</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们都声明了一个变量，因此我们可以制定一个通用规则来解析这两种情况。 下面是完整的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">G</span> {
    <span class="tok-k">rule</span><span class="tok-n"> TOP</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;variable-declaration&gt;* %% &#39;;&#39;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">rule</span><span class="tok-n"> variable-declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">        | &lt;scalar-declaration&gt;</span>
<span class="tok-sr">        | &lt;array-declaration&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">rule</span><span class="tok-n"> scalar-declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;my&#39; &#39;$&#39; &lt;variable-name&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">rule</span><span class="tok-n"> array-declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;my&#39; &#39;@&#39; &lt;variable-name&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">token</span><span class="tok-n"> variable-name</span> {<span class="tok-sr"></span>
<span class="tok-sr">        \w+</span>
<span class="tok-sr">    </span>}
}

<span class="tok-k">class</span> <span class="tok-n">A</span> {
    <span class="tok-k">has</span> <span class="tok-nv">%!var</span>;

    <span class="tok-k">method</span> <span class="tok-n">TOP</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-n">dd</span> <span class="tok-nv">%!var</span>;
    }

    <span class="tok-k">method</span> <span class="tok-n">variable-declaration</span>(<span class="tok-vg">$/</span>) {
        <span class="tok-k">if</span> <span class="tok-nv">$&lt;scalar-declaration&gt;</span> {
            <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;scalar-declaration&gt;&lt;variable-name&gt;</span>} = <span class="tok-mi">0</span>;
        }
        <span class="tok-k">elsif</span> <span class="tok-nv">$&lt;array-declaration&gt;</span> {
            <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;array-declaration&gt;&lt;variable-name&gt;</span>} = [];
        }
    }
}

<span class="tok-n">G</span>.<span class="tok-n">parse</span>(<span class="tok-s">&#39;my $s; my @a;&#39;</span>, :<span class="tok-n">actions</span>(<span class="tok-n">A</span>.<span class="tok-nb">new</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不解释这个程序的每一点; 如果您有兴趣，可以在最近的 <a href="http://perl.nl/amsterdam">Amsterdam.pm</a> 会议上观看<a href="https://www.youtube.com/watch?v=YWTmd4Hdfa4">80分钟的视频</a>。</p>
</div>
<div class="paragraph">
<p>现在感兴趣的对象是规则 <code>variable-declaration</code> 及其相应的 action。</p>
</div>
<div class="paragraph">
<p>该规则包含两个选项：是否声明了标量或数组。 该 action 还在选项之间进行选择，并使用 <code>if-else</code> 块执行该 action 操作。 Perl 6 允许你省略布尔条件周围的括号，但是，整个结构仍然很大。 例如，想想如果添加哈希声明，则需要添加另一个 <code>elsif</code> 分支。</p>
</div>
<div class="paragraph">
<p>为每个子分支分别采取 action 操作会更清楚：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">scalar-declaration</span>(<span class="tok-vg">$/</span>) {
    <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>} = <span class="tok-mi">0</span>;
}

<span class="tok-k">method</span> <span class="tok-n">array-declaration</span>(<span class="tok-vg">$/</span>) {
    <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>} = [];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，每个方法的主体包含单行代码，你可以立即看到它正在做什么。 更不用说它变得不那么容易出错了。</p>
</div>
<div class="paragraph">
<p>在我们继续讨论下一个技巧之前，你可能需要实现另一个优化：<code>my</code> 关键字出现在任一声明中，因此请使用非捕获括号并将公用字符串从它们之中移出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">rule</span><span class="tok-n"> variable-declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">    &#39;my&#39; [</span>
<span class="tok-sr">        | &lt;scalar-declaration&gt;</span>
<span class="tok-sr">        | &lt;array-declaration&gt;</span>
<span class="tok-sr">    ]</span>
}

<span class="tok-k">rule</span><span class="tok-n"> scalar-declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">    &#39;$&#39; &lt;variable-name&gt;</span>
}

<span class="tok-k">rule</span><span class="tok-n"> array-declaration</span> {<span class="tok-sr"></span>
<span class="tok-sr">    &#39;@&#39; &lt;variable-name&gt;</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_multi_方法">30.2. 使用 multi 方法</h3>
<div class="paragraph">
<p>让我们改进 grammar 以允许使用目标语言进行赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$s</span>; <span class="tok-k">my</span> <span class="tok-nv">@a</span>; <span class="tok-nv">$s</span> = <span class="tok-mi">3</span>; <span class="tok-nv">$a</span>[<span class="tok-mi">1</span>] = <span class="tok-mi">4</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，赋值是以 Perl 5 样式完成的，数组元素为 sigil。 有了这个，可以使用以美元开头的单个规则来完成赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">G</span> {
    <span class="tok-k">rule</span><span class="tok-n"> TOP</span> {<span class="tok-sr"></span>
<span class="tok-sr">        [</span>
<span class="tok-sr">            | &lt;variable-declaration&gt;</span>
<span class="tok-sr">            | &lt;assignment&gt;</span>
<span class="tok-sr">        ]</span>
<span class="tok-sr">        * %% &#39;;&#39;</span>
<span class="tok-sr">    </span>}

    <span class="tok-c1"># . . .</span>

    <span class="tok-k">rule</span><span class="tok-n"> assignment</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;$&#39; &lt;variable-name&gt; &lt;index&gt;? &#39;=&#39; &lt;value&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">rule</span><span class="tok-n"> index</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;[&#39; &lt;value&gt; &#39;]&#39;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">token</span><span class="tok-n"> value</span> {<span class="tok-sr"></span>
<span class="tok-sr">        \d+</span>
<span class="tok-sr">    </span>}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，<code>assignment</code> action 操作必须推断出它目前正在处理的赋值类型。</p>
</div>
<div class="paragraph">
<p>同样，您可以使用我们的老朋友，action 操作中的 <code>if-else</code> 块。 根据索引的存在，您可以确定这是一个简单的标量还是数组的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">assignment</span>(<span class="tok-vg">$/</span>) {
    <span class="tok-k">if</span> <span class="tok-nv">$&lt;index&gt;</span> {
        <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>}[<span class="tok-nv">$&lt;index&gt;&lt;value&gt;</span>] = +<span class="tok-nv">$&lt;value&gt;</span>;
    }
    <span class="tok-k">else</span> {
        <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>} = +<span class="tok-nv">$&lt;value&gt;</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码也可以轻松简化，但这次使用 multi 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">assignment</span>(<span class="tok-vg">$/</span> <span class="tok-k">where</span> !<span class="tok-nv">$&lt;index&gt;</span>) {
    <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>} = +<span class="tok-nv">$&lt;value&gt;</span>;
}

<span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">assignment</span>(<span class="tok-vg">$/</span> <span class="tok-k">where</span> <span class="tok-nv">$&lt;index&gt;</span>) {
    <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>}[<span class="tok-nv">$&lt;index&gt;&lt;value&gt;</span>] = +<span class="tok-nv">$&lt;value&gt;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>where</code> 子句允许 Perl 6 决定哪个候选方法在给定情况下更适合。</p>
</div>
<div class="paragraph">
<p>另请注意在第二个 multi 方法中如何使用 <code>&lt;value&gt;</code> 键两次。 <code>&lt;value&gt;</code> 的每个条目指的是目标代码的不同部分：一个用于索引值，另一个用于右侧值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_让_perl_完成这项工作">30.3. 3. 让 Perl 完成这项工作</h3>
<div class="paragraph">
<p>有时，Perl 可以为我们完成工作，特别是如果你想实现 Perl 熟悉的东西。 例如，让我们在赋值中允许不同类型的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$a</span>; <span class="tok-k">my</span> <span class="tok-nv">$b</span>; <span class="tok-nv">$a</span> = <span class="tok-mi">3</span>; <span class="tok-nv">$b</span> = -<span class="tok-mf">3.14</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 grammar 中引入浮点数比较容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">token</span><span class="tok-n"> value</span> {<span class="tok-sr"></span>
<span class="tok-sr">    | &#39;-&#39;? \d+</span>
<span class="tok-sr">    | &#39;-&#39;? \d+ &#39;.&#39; \d+</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您想添加其他类型的数字，请参阅 <a href="https://www.perl.com/article/perl-6-grammers-part-1/">perl.com</a> 上的文章。 现在，我们可以用上面两个选项限制 grammar，因为这足以阐明这个技巧。</p>
</div>
<div class="paragraph">
<p>如果您使用更改运行代码，您可能会对获得所需结果感到惊讶。 两个变量都接收值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">Hash</span> <span class="tok-nv">%!var</span> = {:<span class="tok-n">a</span>(<span class="tok-mi">3</span>), :<span class="tok-n">b</span>(-<span class="tok-mf">3.14</span>)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，都触发了相同的 action 操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">assignment</span>(<span class="tok-vg">$/</span> <span class="tok-k">where</span> !<span class="tok-nv">$&lt;index&gt;</span>) {
    <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>} = +<span class="tok-nv">$&lt;value&gt;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值的右侧，我们看到 <code>+$&lt;value&gt;</code>，这是从 Match 对象转换为数字的类型。 grammar 将 <code>3</code> 或 <code>-3.14</code> 放在 <code>$&lt;value&gt;</code> 中，两者都作为字符串。 <code>+</code> 这个一元运算符尝试将字符串转换为数字。 两个字符串都是有效数字，因此 Perl 6 不会抱怨。</p>
</div>
<div class="paragraph">
<p>自己编写代码将字符串转换为数字会更加困难，因为需要考虑数值的所有不同形式。 要了解 Perl 6 知道的其他格式，请查看 <a href="https://github.com/rakudo/rakudo/blob/master/src/Perl6/Grammar.nqp">Perl 6 grammar</a> 中 <code>numish</code> 标记的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">token</span><span class="tok-n"> numish</span> {<span class="tok-sr"></span>
<span class="tok-sr">    [</span>
<span class="tok-sr">    | &#39;NaN&#39; &gt;&gt;</span>
<span class="tok-sr">    | &lt;integer&gt;</span>
<span class="tok-sr">    | &lt;dec_number&gt;</span>
<span class="tok-sr">    | &lt;rad_number&gt;</span>
<span class="tok-sr">    | &lt;rat_number&gt;</span>
<span class="tok-sr">    | &lt;complex_number&gt;</span>
<span class="tok-sr">    | &#39;Inf&#39; &gt;&gt;</span>
<span class="tok-sr">    | $&lt;uinf&gt;=&#39;∞&#39;</span>
<span class="tok-sr">    | &lt;unum=:No+:Nl&gt;</span>
<span class="tok-sr">    ]</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您在自己的 grammar 中允许任何上述类型，Perl 将能够为您转换它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_使用_multi_rules_和_multi_tokens">30.4. 4. 使用 multi-rules 和 multi-tokens</h3>
<div class="paragraph">
<p>它不仅是方法，也可以是 multi-things。 grammar 的规则和标记也是方法，您也可以创建它们的多个变体。</p>
</div>
<div class="paragraph">
<p>让我们更新我们的 grammar，以允许在赋值的右侧使用数学表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$a</span>; <span class="tok-nv">$a</span> = <span class="tok-mi">6</span> + <span class="tok-mi">5</span> * (<span class="tok-mi">4</span> - <span class="tok-mi">3</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的新问题是解析表达式并处理运算符优先级和括号。 您可以通过以下方式描述任何表达式：</p>
</div>
<div class="paragraph">
<p>1、表达式是由 <code>+</code> 或 <code>-</code> 分隔的项的序列。
2、上一个规则中的任何项都是由 <code>*</code> 或 <code>/</code> 分隔的项的序列。
3、括号内的任何内容都是另一个表达式，因此请转到规则1。</p>
</div>
<div class="paragraph">
<p>话虽如此，您最终会得到以下 grammar 变更：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">G</span> {
    <span class="tok-c1"># . . .</span>

    <span class="tok-k">rule</span><span class="tok-n"> assignment</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;$&#39; &lt;variable-name&gt; &lt;index&gt;? &#39;=&#39; &lt;expression&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">multi</span> <span class="tok-k">token</span><span class="tok-n"> op</span>(<span class="tok-mi">1</span>) {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;+&#39; | &#39;-&#39;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">multi</span> <span class="tok-k">token</span><span class="tok-n"> op</span>(<span class="tok-mi">2</span>) {<span class="tok-sr"></span>
<span class="tok-sr">        &#39;*&#39; | &#39;/&#39;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">rule</span><span class="tok-n"> expression</span> {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;expr(1)&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">multi</span> <span class="tok-k">rule</span><span class="tok-n"> expr</span>(<span class="tok-nv">$n</span>) {<span class="tok-sr"></span>
<span class="tok-sr">        &lt;expr($n + 1)&gt;+ %% &lt;op($n)&gt;</span>
<span class="tok-sr">    </span>}

    <span class="tok-k">multi</span> <span class="tok-k">rule</span><span class="tok-n"> expr</span>(<span class="tok-mi">3</span>) {<span class="tok-sr"></span>
<span class="tok-sr">        | &lt;value&gt;</span>
<span class="tok-sr">        | &#39;(&#39; &lt;expression&gt; &#39;)&#39;</span>
<span class="tok-sr">    </span>}

    <span class="tok-c1"># . . .</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，rules 和 tokes 都是 multi 方法，它采用反映表达式深度的单个整数值。 操作符也是如此：在第一级，你期望 <code>+</code> 和 <code>-</code> ，在第二级 -  <code>*</code> 和 <code>/</code>。</p>
</div>
<div class="paragraph">
<p>不要忘记 Perl 6 中的 multi 方法（以及 multi-subs）可以基于常量进行调度，这就是为什么你可以, 例如, 使用你在 <code>multi token op(2)</code> 中看到的签名。</p>
</div>
<div class="paragraph">
<p><code>expr($n)</code> 规则通过 <code>expr($n + 1)</code> 递归定义。 <code>$n</code> 达到3时递归停止，Perl 6 选择最后一个候选 <code>multi rule expr(3)</code>。</p>
</div>
<div class="paragraph">
<p>让我懒惰，并使用以前的建议让 Perl 计算表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">assignment</span>(<span class="tok-vg">$/</span> <span class="tok-k">where</span> !<span class="tok-nv">$&lt;index&gt;</span>) {
    <span class="tok-k">use</span> <span class="tok-n">MONKEY-SEE-NO-EVAL</span>;
    <span class="tok-nv">%!var</span>{<span class="tok-nv">$&lt;variable-name&gt;</span>} = <span class="tok-n">EVAL</span>(<span class="tok-nv">$&lt;expression&gt;</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般来说，我建议只在神奇的圣诞节期间使用 <code>EVAL</code>。 在今年余下的时间里，请自己计算表达式并使用抽象语法树和 <code>make</code> 和 <code>made</code> 方法对儿保存部分结果。 例如，请参阅此处的<a href="https://github.com/ash/lingua/blob/master/LinguaActions.pm">示例</a>。</p>
</div>
<div class="paragraph">
<p>我还建议一些额外的阅读，以便更好地了解如何使用 <code>multi</code> 和 <code>proto</code> 关键字：</p>
</div>
<div class="paragraph">
<p>1、<a href="https://perl6.online/2017/12/21/the-proto-keyword/">Perl 6 中的 proto 关键字</a>
2、<a href="https://perl6.online/2018/02/21/63-more-on-the-proto-keyword-in-perl-6/">有关 Perl 6 中 proto 关键字的更多信息</a></p>
</div>
<div class="paragraph">
<p>此时此刻，令人惊叹的 Perl 6 grammar 之旅就要结束了。 你可以在 <a href="https://github.com/ash/advent-2018-day8">GitHub</a> 上找到今天帖子的完整例子。 祝你读完其余的 Perl Advent Calendars，祝你愉快！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_perl_6_中的常量">31. 第九天 - Perl 6 中的常量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我自豪地告诉人们在<a href="https://act.yapc.eu/lpw2018">伦敦 Perl 工作室</a>前一天我写了我的第一个 Perl 6 程序（也就是一个能工作的程序）。 所以，JJ 说：“为什么不为 Perl 6 写一个 Advent 日历帖？”</p>
</div>
<div class="paragraph">
<p>我名下只有区区一个程序，我该写些什么呢？ 嗯&#8230;&#8203;&#8230;&#8203;我在 Perl 5 中创作了 <a href="https://metacpan.org/pod/Astro::Constants">Astro::Constants</a>，那么将它迁移到 Perl 6 有多难？</p>
</div>
<div class="paragraph">
<p>话匣子打开就关不上了，我给你讲一个 Perl 5 模块作者在 Perl 6 的领地中徘徊的故事。</p>
</div>
<div class="paragraph">
<p>如果在<a href="https://perl6advent.wordpress.com/2018/12/04/day-5-variables/">第5天</a>你被“诊断”为常数，那么你正好需要今天的帖子。</p>
</div>
<div class="paragraph">
<p>我们习惯使用变量来计算东西和持有东西。 随着我们获得更多“东西”，总量会发生变化。 <a href="https://docs.perl6.org/language/variables#The_constant_prefix">常量</a>是那些永远不会改变的值。 像一天中的秒数或光速。 当然，我们在计算中使用它们就像使用变量一样，但是你不想通过赋值意外地改变常量</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nv">$SPEED_LIGHT</span> = <span class="tok-mi">30</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至意外地当你打算测试它是否等于某个值时，就像这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">if</span> ( <span class="tok-nv">$SECONDS_IN_A_DAY</span> = <span class="tok-nv">$seconds_waited</span>) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你真正想的是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">if</span> ( <span class="tok-nv">$SECONDS_IN_A_DAY</span> == <span class="tok-nv">$seconds_waited</span>) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些情况下，你希望编译器说“对不起，戴夫。 恐怕我不能这样做。“ Perl 编译器关闭了。 如果你尝试运行第一行，你会得到</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Cannot</span> <span class="tok-n">modify</span> <span class="tok-n">an</span> <span class="tok-n">immutable</span> <span class="tok-nb">Num</span> (<span class="tok-mi">299792458</span>)
  <span class="tok-n">in</span> <span class="tok-n">block</span>  <span class="tok-n">at</span> <span class="tok-n">im_sorry_dave</span>.<span class="tok-n">p6</span> <span class="tok-n">line</span> <span class="tok-mi">12</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>单击此处获取<a href="https://docs.perl6.org/language/terms#Constants">完整解释</a></p>
</div>
<div class="sect2">
<h3 id="_如何制作一个常数">31.1. 如何制作一个常数</h3>
<div class="paragraph">
<p>要使变量保持不变，请使用 <code>constant</code> 关键字声明它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">constant</span> <span class="tok-nv">$tau</span> = <span class="tok-nb">pi</span> * <span class="tok-mi">2</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>嘿！ sigil 是可选的，所以我可以使用我最喜欢的样式进行常量声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-k">constant</span> <span class="tok-n">SPEED_LIGHT</span> <span class="tok-k">is</span> <span class="tok-k">export</span> = <span class="tok-mf">2.99792458e8</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些乐趣不仅仅适用于<a href="https://docs.perl6.org/type/Scalar">标量</a>。 <a href="https://docs.perl6.org/type/List">列表</a>和<a href="https://docs.perl6.org/type/Hash">散列</a>也可以声明为常量！</p>
</div>
<div class="paragraph">
<p>为什么要使 List 保持不变？ 一年中的月份是列表吧, 它阻止这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-k">constant</span> <span class="tok-nv">@months</span> = ;
...
<span class="tok-nv">@months</span>[<span class="tok-mi">9</span>] = <span class="tok-s">&#39;Hacktober&#39;</span>;   <span class="tok-c1"># changing a name</span>
<span class="tok-nb">push</span> <span class="tok-nv">@months</span>, <span class="tok-s">&#39;Hogmannay&#39;</span>;  <span class="tok-c1"># we&#39;d all like more time after Christmas</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你尝试其中任何一个，你得到</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Cannot</span> <span class="tok-n">modify</span> <span class="tok-o">and</span> <span class="tok-n">immutable</span> <span class="tok-nb">Str</span> (<span class="tok-n">D</span>)       <span class="tok-c1"># error for the assignment</span>
<span class="tok-c1"># or</span>
<span class="tok-n">Cannot</span> <span class="tok-n">call</span> <span class="tok-s">&#39;push&#39;</span> <span class="tok-n">on</span> <span class="tok-n">an</span> <span class="tok-n">immutable</span> <span class="tok-s">&#39;List&#39;</span> <span class="tok-c1"># error for the push</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>顺便说一句，<code>tau</code>，<code>pi</code>，<code>e</code> 和 <code>i</code> 都是 Perl 6 中的内置常量，以及它们的 Unicode 等价物，<code>τ</code>，<code>π</code> 和 <code>𝑒</code>。 似乎你可以使用<a href="https://docs.perl6.org/language/variables#Sigilless_variables">无 sigil 变量</a>获得相同的行为但是今天暂且不表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从模块导出常量">31.2. 从模块导出常量</h3>
<div class="paragraph">
<p>如果你要在代码中反复使用相同的常量，那么将它们放在一个模块（一个单独的文件）中并将其加载到程序中是有意义的。 现在我不得不在这里加一些土鳖编程，但这对我有用，我会尽力解释它的能力。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">v6</span>;
<span class="tok-n">unit</span> <span class="tok-k">class</span> <span class="tok-n">Astro::Constants:ver</span><span class="tok-s">&lt;0.0.1&gt;</span>:<span class="tok-n">auth</span>;

<span class="tok-k">my</span> <span class="tok-k">constant</span> <span class="tok-n">SPEED_LIGHT</span> <span class="tok-k">is</span> <span class="tok-k">export</span> = <span class="tok-mf">2.99792458e8</span>;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>第1行</strong> - 轻松入手。<code>use v6;</code> 告诉编译器这是一个 Perl 6 程序。等等！我不需要它。这只是编写程序的一个习惯。我可以摆脱它。</p>
</div>
<div class="paragraph">
<p><strong>第2行</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.perl6.org/language/module-packages#The_unit_keyword">unit</a> 表示此文件只提供一个模块 - 不知道这意味着什么</p>
</li>
<li>
<p><a href="https://docs.perl6.org/syntax/class">class</a> 创建文件的词法范围 - 但我可能已经使用了<a href="https://docs.perl6.org/language/module-packages">模块</a>，而不是用于不属于类的代码。嗯，我想我必须更深入地考虑我的代码设计。但它仍然奏效！</p>
</li>
<li>
<p><code>Astro::Constants</code>  - 模块名称</p>
</li>
<li>
<p><code>ver&lt;0.0.1&gt;</code>  - 版本字符串，现在在包声明中。</p>
</li>
<li>
<p><code>auth</code>  - 嗯，这是作者。为包名添加更高的维度有点怪，但它确实允许您指定要使用的模块的版本。在 PAUSE 中没有名称空间露营的问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>第N行</strong> <code>my</code> 词汇范围; <code>constant</code> 使其成为只读; <code>SPEED_LIGHT</code> 是常量的名称; <code>is export</code> 允许常量<a href="https://docs.perl6.org/language/modules#Exporting_and_selective_importing">在模块外部使用</a>，即在代码中使用; <code>2.99792458e8</code> 只是 Perl 表达 <code>2.99×10⁸</code> 的方式。</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;为了完整起见，加上版本方法和一些<a href="https://perl6advent.wordpress.com/2015/12/10/day-10-perl-6-pod/">文档</a>来完成模块怎么样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">ver</span> { <span class="tok-n">v0</span><span class="tok-mf">.0.1</span> }

<span class="tok-cm">=begin pod</span>

<span class="tok-cm">=head1 DESCRIPTION</span>

<span class="tok-cm">A set of constants used in Physics, Chemistry and Math</span>

<span class="tok-cm">=end pod</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将常量放入模块的一个副作用是它们<a href="https://docs.perl6.org/language/traps#Constants_are_computed_at_compile_time">在编译时计算</a>。它应该使您的代码运行得更快，但编译后的模块仍然存在。 这对于常量非常有用，但如果您的模块包含您可能想要更改的内容，则需要重新编译它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在程序中使用模块">31.3. 在程序中使用模块</h3>
<div class="paragraph">
<p>一旦你有了一个模块，你如何在程序中使用它？</p>
</div>
<div class="paragraph">
<p>在这个例子中，我创建了一个目录 <code>mylib/Astro</code>，并将该模块放在一个名为 <code>mylib/Astro/Constants.pm6</code> 的文件中。 这是我的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">v6</span>;
<span class="tok-k">use</span> <span class="tok-n">lib</span> ;
<span class="tok-k">use</span> <span class="tok-n">Astro::Constants</span>;

<span class="tok-nb">say</span> <span class="tok-s">&quot;speed of light =\t&quot;</span>, <span class="tok-n">SPEED_LIGHT</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它<strong>起作用了</strong>！ 解释一下前3行：<code>use v6</code> 说使用 Perl 6; <code>use lib</code> 表示把路径添加到库搜索路径; <code>use Astro::Constants</code> 表示在库路径中搜索文件 <code>Astro/Constants.pm6</code> 并加载它。</p>
</div>
<div class="sect3">
<h4 id="_我必须做这一切吗_不">31.3.1. 我必须做这一切吗？ &#8230;&#8203;&#8230;&#8203;不。</h4>
<div class="paragraph">
<p>为什么要重新发明轮子？ 前面提到的JJ有<a href="https://github.com/JJ/p6-math-constants">以前的常量形式</a>，但你需要一个包管理器来完成它的安装工作。 在 Fedora 28 中，使用 <code>dnf install rakudo-zef</code> 来安装包管理器 <strong>zef</strong>。 然后，您可以搜索任何处理常量的模块。运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>zef search Constants</code></pre>
</div>
</div>
<div class="paragraph">
<p>将为您提供至少15个在生态系统中注册的软件包，并非所有软件包都是你正在寻找的软件包。您可以立即开始使用 <code>zef install Math::Constants</code> 并使用JJ的模块，或者您可以使用搜索来查看我是否已经找到时间上传我的尝试（当时可能名为 <strong>*Physics::Constants</strong>），即将于2019年发布。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_最后对代码维护进行了一些注释">31.4. 最后，对代码维护进行了一些注释</h3>
<div class="paragraph">
<p>对我来说，代码维护是科学编程中最重要的考虑因素。想想那位走进美学院门口的新科学专业的学生，​​并在第1天交给你维护的代码。在第20天保证，他们被要求做出改变。为了他们的缘故，我喜欢为了清晰而不是简洁而写作，因为科学中存在如此多的重载符号。因此，我对将符号投入计算时很谨慎。也许我什么都不担心，但找到答案的唯一方法就是去做，看看是否有害。</p>
</div>
<div class="paragraph">
<p>我现在发生的一种可能性是能够指定你所指的常数。这个组成的例子看起来有点像 Python。可能值得偷窃。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">import</span> <span class="tok-n">GRAVITATIONAL</span> <span class="tok-k">as</span> <span class="tok-n">G</span>;
...
<span class="tok-nv">$F_between_two_bodies</span> = <span class="tok-n">G</span> * <span class="tok-nv">$mass1</span> * <span class="tok-nv">$mass2</span> / <span class="tok-nv">$distance</span><span class="tok-o">**</span><span class="tok-mi">2</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我将在圣诞节阅读 <a href="https://www.packtpub.com/application-development/perl-6-deep-dive">Perl 6 Deep Dive</a>，我会告诉你我明年的表现。</p>
</div>
<div class="paragraph">
<p>快乐地搞科学！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_跳转_开启你的工作流">32. 第十天 - 跳转, 开启你的工作流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是另一个版本的 <a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a> 供你在圣诞节前解开。</p>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 是一个命令行工具，用于搜索成堆的代码，然后快速跳转到 <code>$EDITOR</code>。这有助于<a href="https://perl6advent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">保持流动</a>。</p>
</div>
<div class="paragraph">
<p>然而，计算机编程具有许多潜在的<a href="https://perl6advent.wordpress.com/2016/12/19/fixing-flow/">流阻塞器</a>。要在编码时保持流状态，通常需要在其他情况下快速<strong>跳转</strong>(jmp)到一行代码：修复错误，运行测试，检查日志文件，检查git状态等. <strong>jmp</strong> 也可以帮助加速这些任务吗？</p>
</div>
<div class="paragraph">
<p>幸运的是，重构 <strong>jmp</strong> 以容纳这些额外的使用场景相对容易。最新版本的 <strong>jmp</strong> 现在的工作原理如下：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/demo.gif?w=600&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>在命令前加上 <strong>jmp</strong> 将导致命令再次执行，并且其输出会被吞噬并被分页。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#| find matching lines</span>
<span class="tok-k">method</span> <span class="tok-n">find-files-in-command-output</span> (<span class="tok-nv">$command</span>) {

    <span class="tok-c1"># execute the command</span>
    <span class="tok-k">my</span> <span class="tok-nv">$shell-cmd</span> = <span class="tok-n">shell</span> <span class="tok-nv">$command</span>, :<span class="tok-n">out</span>, :<span class="tok-n">err</span>;

    <span class="tok-c1"># join STDOUT and STDERR</span>
    <span class="tok-k">my</span> <span class="tok-nv">$result</span> = <span class="tok-nb">join</span>(<span class="tok-s">&quot;\n&quot;</span>, <span class="tok-nv">$shell-cmd</span>.<span class="tok-n">out</span>.<span class="tok-nb">slurp</span>,
                            <span class="tok-nv">$shell-cmd</span>.<span class="tok-n">err</span>.<span class="tok-nb">slurp</span>);

    <span class="tok-c1"># don&#39;t actually look for filenames just yet</span>
    <span class="tok-c1"># do that lazily on demand by the user</span>
    <span class="tok-k">return</span> <span class="tok-nv">$result</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">map</span>({
               <span class="tok-n">JMP::File::HitLater</span>.<span class="tok-nb">new</span>(<span class="tok-nb">context</span> =&gt; <span class="tok-nv">$_</span>)
           });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 为每一行创建结果提示，并对结果进行分页。然后，如果需要，您可以快速浏览输出并将 <strong>jmp</strong> 导入文本编辑器（请参阅 <strong>jmp config</strong> 以将其更改为您最喜欢的编辑器）。</p>
</div>
<div class="paragraph">
<p>速度对命令行工具很重要。<strong>jmp</strong> 只在用户选择编辑特定行时查找文件名, 而不是提前扫描每一行的文件名。这是懒惰地解析查找文件的行的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">submethod</span> <span class="tok-n">find-file-path</span> {

    <span class="tok-k">given</span> <span class="tok-k">self</span>.<span class="tok-nb">context</span> {

        <span class="tok-c1"># matches Perl 5 error output (e.g., at SomePerl.pl line 12)</span>
        <span class="tok-k">when</span> /<span class="tok-n">at</span> \<span class="tok-o">s</span> (\<span class="tok-n">S</span>+) \<span class="tok-o">s</span> <span class="tok-n">line</span> \<span class="tok-o">s</span> (\<span class="tok-n">d</span>+)/ {
            <span class="tok-n">proceed</span> <span class="tok-k">unless</span> <span class="tok-k">self</span>.<span class="tok-n">found-file-path</span>(<span class="tok-vg">$/</span>[<span class="tok-mi">0</span>], <span class="tok-vg">$/</span>[<span class="tok-mi">1</span>]);
        }

        <span class="tok-c1"># matches Perl 6 error output (e.g., at SomePerl6.p6:12)</span>
        <span class="tok-k">when</span> /<span class="tok-n">at</span> \<span class="tok-o">s</span> (<span class="tok-s">&lt;-[\s:]&gt;</span>+) <span class="tok-s">&#39;:&#39;</span> (\<span class="tok-n">d</span>+)/ {
            <span class="tok-n">proceed</span> <span class="tok-k">unless</span> <span class="tok-k">self</span>.<span class="tok-n">found-file-path</span>(<span class="tok-vg">$/</span>[<span class="tok-mi">0</span>], <span class="tok-vg">$/</span>[<span class="tok-mi">1</span>]);
        }

        <span class="tok-c1"># matches Perl 6 error output (e.g., SomePerl6.p6 (Some::Perl6):12)</span>
        <span class="tok-k">when</span> /<span class="tok-n">at</span> \<span class="tok-o">s</span> (<span class="tok-s">&lt;-[\s:]&gt;</span>+) <span class="tok-s">&#39;(&#39;</span> \<span class="tok-n">S</span>+ <span class="tok-s">&#39;)&#39;</span> <span class="tok-s">&#39;:&#39;</span> (\<span class="tok-n">d</span>+)/ {
            <span class="tok-n">proceed</span> <span class="tok-k">unless</span> <span class="tok-k">self</span>.<span class="tok-n">found-file-path</span>(<span class="tok-vg">$/</span>[<span class="tok-mi">0</span>], <span class="tok-vg">$/</span>[<span class="tok-mi">1</span>]);
        }

        <span class="tok-c1"># more file finding patterns HERE - PR&#39;s welcome?</span>

        <span class="tok-c1"># go through each token</span>
        <span class="tok-k">default</span> {
            <span class="tok-k">for</span> <span class="tok-k">self</span>.<span class="tok-nb">context</span>.<span class="tok-n">words</span> -&gt; <span class="tok-nv">$token</span> {
                <span class="tok-c1"># keep trying to set the file path</span>
                <span class="tok-n">proceed</span> <span class="tok-k">if</span> <span class="tok-k">self</span>.<span class="tok-n">found-file-path</span>(<span class="tok-nv">$token</span>);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>when</strong> 块匹配不同类型的错误格式（例如，Perl 5 和 Perl 6）以提取文件名和行号。 <strong>proceed</strong> 语句对于移动到下一个 <strong>when</strong> 块非常有用。</p>
</div>
<div class="paragraph">
<p>这意味着你可以跳转(<strong>jmp</strong>)到工作流程中出现错误的任何位置：例如命令行的输出，测试输出，日志文件等。</p>
</div>
<div class="paragraph">
<p>要升级到 <strong>jmp</strong> 的第3版：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>shell&gt; zef upgrade jmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>要首次安装 <strong>jmp</strong>，请<a href="https://perl6.org/downloads/">安装 Perl 6</a>，然后使用 <a href="https://github.com/ugexe/zef">zef</a> Perl 6 模块管理器来安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>shell&gt; zef install jmp   <span class="tok-c1"># install the jmp command line tool</span>
shell&gt; jmp config        <span class="tok-c1"># set up jmp to use your tools</span>
shell&gt; jmp to sub MAIN   <span class="tok-c1"># find files containing &quot;sub MAIN&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞节前还有更多工具可以打开。在第17天再次与你联系，获取有助于您的非编码工作流的工具。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_使用_perl_6_测试你的时刻表">33. 第十一天 - 使用 Perl 6 测试你的时刻表</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这几乎是在北极附近的精灵小学冬季学期结束之时。对于精灵而言，敏锐的人物头脑非常重要，而小精灵的数学老师 Hopper 女士希望确保他们在任期的倒数第二天保持他们的算术技能。（学期的最后一天保留用于观看电影和玩耍 -  很嗨皮）。</p>
</div>
<div class="paragraph">
<p>小精灵刚刚学会了他们的时间表（乘法表），最多12个，但他们并不像他们所想的那样擅长，其中一些人在圣诞节前将在玩具工作坊帮忙，那时候他们可能需要快速告诉大精灵有多少特定类型的玩具。</p>
</div>
<div class="paragraph">
<p>幸运的是，Elf Hopper 是一个非常聪明的精灵，拥有出色的数学和编码能力 - 自己。所以她起了一个快速的控制台应用程序来运行小精灵的学校颁发的 Perlix 6.0 boxen。</p>
</div>
<div class="paragraph">
<p>该程序允许小精灵通过运行它们在2至12次表中测试自己，或者如果它们提供单个数字参数，他们可以尝试任何他们喜欢的乘法表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!/usr/bin/env perl6</span>

<span class="tok-k">use</span> <span class="tok-n">v6</span>;

<span class="tok-k">my</span> <span class="tok-nv">$fixednum</span>;
<span class="tok-k">my</span> <span class="tok-nv">%score</span>;
<span class="tok-k">my</span> <span class="tok-nv">@exits</span> = <span class="tok-s">&lt;exit quit&gt;</span>;

<span class="tok-nv">$fixednum</span> = <span class="tok-vg">@*ARGS</span>[<span class="tok-mi">0</span>] || <span class="tok-mi">0</span>;
<span class="tok-n">put</span> <span class="tok-s">&quot;Type the answer, or quit or exit to end the test.&quot;</span>;


<span class="tok-k">loop</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$coefficient</span> = (<span class="tok-mi">2</span><span class="tok-o">..</span><span class="tok-mi">12</span>).<span class="tok-nb">pick</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$number</span> = <span class="tok-nv">$fixednum</span> || (<span class="tok-mi">2</span><span class="tok-o">..</span><span class="tok-mi">12</span>).<span class="tok-nb">pick</span>;

    <span class="tok-k">my</span> <span class="tok-nv">$answer</span> = <span class="tok-n">prompt</span> ( <span class="tok-s">&quot;$coefficient × $number = &quot;</span> );
    <span class="tok-k">my</span> <span class="tok-nv">$rightanswer</span> = <span class="tok-nv">$coefficient</span> × <span class="tok-nv">$number</span>;

    <span class="tok-k">last</span> <span class="tok-k">if</span> <span class="tok-nv">$answer</span>.<span class="tok-nb">lc</span> ~~ <span class="tok-nb">any</span> <span class="tok-nv">@exits</span>;

    <span class="tok-k">if</span> <span class="tok-nv">$answer</span> == <span class="tok-nv">$rightanswer</span> {
        <span class="tok-n">put</span> <span class="tok-s">&quot;Correct!&quot;</span>;
        <span class="tok-nv">%score&lt;correct&gt;</span>++;
    } <span class="tok-k">else</span> {
        <span class="tok-n">put</span> <span class="tok-s">&quot;Sorry, that wasn&#39;t right! The answer is $rightanswer&quot;</span>;
    }
    <span class="tok-nv">%score&lt;total&gt;</span>++;
}

<span class="tok-k">if</span> <span class="tok-nv">%score&lt;total&gt;</span>:<span class="tok-n">exists</span> {
    <span class="tok-k">my</span> <span class="tok-nv">$pc</span> = <span class="tok-mi">100</span> * <span class="tok-nv">%score&lt;correct&gt;</span> / <span class="tok-nv">%score&lt;total&gt;</span>;
    <span class="tok-n">put</span> <span class="tok-s">&quot;You scored %score&lt;correct&gt; out of %score&lt;total&gt;, i.e. &quot;</span>, <span class="tok-nb">sprintf</span> <span class="tok-s">&quot;%2.2f%%.&quot;</span>, <span class="tok-nv">$pc</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elf Hopper 向其它小精灵解释代码如下。</p>
</div>
<div class="paragraph">
<p>“可爱的小精灵们！这是关于程序如何工作的一些背景知识。</p>
</div>
<div class="paragraph">
<p>我在顶部附近添加了 <code>use v6;</code>，以便代码也可以在 Perl 5下 运行，它将自动使用 Perl 6 仿真器。</p>
</div>
<div class="paragraph">
<p>您将看到程序在特殊的 <code>@*ARGS</code> 数组的命令行上运行时选择一个可选参数。这是 Perl 5 的 <code>@ARGV</code> 数组的 Perl6 等价物。</p>
</div>
<div class="paragraph">
<p>在 Perl 6 中，数组，数组元素和数组切片总是使用 <code>@</code> sigil，与 Perl 5 不同，其中各个数组元素使用 <code>$</code> sigil。同样，哈希和哈希元素现在总是带有 <code>%</code> sigil，无论是整个哈希，它的切片还是单个元素都在使用。</p>
</div>
<div class="paragraph">
<p>那里还有另一个符号，星号 'twigil'，<code>*</code>。这表明 <code>@*ARGS</code> 是一个动态特殊变量。</p>
</div>
<div class="paragraph">
<p><code>prompt</code> 和 <code>loop</code> 关键字是 Perl 6 中的新功能，两者都是令人钦佩的名字！</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>prompt</code> 只返回用户输入的值，在本例中为变量。</p>
</li>
<li>
<p><code>loop</code> 是 Perl 6 的新块控制关键字之一。像这样的简单循环块只是创建了一个无限循环，可以由程序员以显式的方式结束，例如在满足条件时使用 <code>last</code> 关键字;或者例如由用户手动终止程序。</p>
</li>
<li>
<p>或者，循环可以采用三个参数，并且表现得像传统的C风格 <code>for</code> 循环。 （在 Perl 6 中，小精灵，<code>for</code> 只用于迭代列表或其他容器。）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在循环内部，小精灵，你可以看到范围对象。一切都是 Perl 6 中的一个对象，所以我可以在范围上调用 <code>pick</code> 方法来返回一个随机数。（好吧，无论如何，这是一个非加密安全的伪随机数！）</p>
</div>
<div class="paragraph">
<p><code>any</code> 关键字将 <code>@exits</code> 数组转换为 Perl 6 中许多新的有用数据结构之一：一个 <a href="https://perl6advent.wordpress.com/2009/12/13/">Junction</a>。这使得使用 smartmatch 运算符 <code>~~</code> 直截了当地找到一个数组元素。<code>last</code> 关键字退出循环，如 Perl 5 中所示。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.perl6.org/type/Junction">Junction</a> 是一种新类型的容器或列表，允许进行许多最有用的比较，例如 <code>any</code>，<code>all</code>，<code>one</code> 或 <code>none</code>，我们在 Perl 5 中使用 <code>grep</code> 或 <code>List::Util</code> 等模块进行比较，但它使它们成为可能键入更容易，并允许它们同时执行！这样做的一个副作用是 junction 是无序的：但它们主要是为了产生单个真值或假值，所以通常都可以。如果你想快速想要根据一些特定值的简短列表检查一个值，那么 junction 就很棒。但是如果需要的话，它们还能够让你匹配更大的值集。</p>
</div>
<div class="paragraph">
<p>在最后一个代码段落的顶部，您将看到 <code>:exists</code> 应用于 <code>%score&lt;total&gt;</code> 哈希键。<code>:exists</code> 是一个 Perl 6 副词！副词通常会修改方法的工作方式。<code>:exists</code> 是下标副词。它是一个副词，因为它改变了读取哈希键时发生的事情：不是返回值，而是查明值是否存在。这通常是使用 Perl 5 类中关注的那些熟悉的已定义方法的更好的替代方法。</p>
</div>
<div class="paragraph">
<p>当然，<code>exists</code> 测试就是为了确保在用户第一次退出程序时不会出现错误。</p>
</div>
<div class="paragraph">
<p>为什么我使用锯齿形符号来引用哈希键？好吧，花括号 <code>{}</code> 是散列键的标准下标运算符，如 Perl 5. 但是，大多数情况下你可能想要使用尖括号/锯齿形符号，因为它们提供单字键的自动引用。用于在 Perl 5 中执行此操作的简单`{}` 括号，但在 Perl 6 中不再执行此操作。需要引起括号内的字符串。</p>
</div>
<div class="paragraph">
<p>在 Perl 6 中，放置了用于向终端输出文本的标准命令。这将输出以下列表项，然后是换行符。<code>say</code> 和 <code>print</code> 仍然可用; <code>say</code> 和 <code>put</code> 这两个都打印到标准输出并添加换行符; <code>print</code> 不会追加换行符。</p>
</div>
<div class="paragraph">
<p>如果你使用这个程序以及知道它是如何工作的，小精灵，你将有选择和知识，是否，何时以及如何在你自己的头脑中执行乘法，以及什么时候最好让 Perl 6 -有动力的电脑做它。您的圣诞节作业是让您自己熟悉<a href="https://docs.perl6.org/">https://docs.perl6.org</a> 上的 Perl 6 文档。“</p>
</div>
<div class="paragraph">
<p>小精灵开始使用乘法测试程序，试图超越对方以获得最高的完美分数。他们发现它如此令人上瘾，以至于比赛甚至会加时到在学校的最后一天，当时他们应该正在观看&#8217;精灵'！</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_构建灵活的_grammar">34. 第十二天 - 构建灵活的 grammar</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞老人夫人写了一个基础的 Grammar，以配合 GDPR 无知精灵从世界各地收集的有关今年 naughty 或 nice 的人的简单列表。</p>
</div>
<div class="paragraph">
<p>每个记录都是一个名称，后跟一个标签，后跟一个地址，然后是一个标签，然后是 naughty 或 nice 的评估，然后用换行符结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Batman</span> <span class="tok-mi">1</span> <span class="tok-n">Batman</span> <span class="tok-n">Street</span>, <span class="tok-n">Gotham</span> <span class="tok-n">Nice</span>
<span class="tok-n">Joker</span> <span class="tok-mi">5</span> <span class="tok-n">Joker</span> <span class="tok-n">Street</span>, <span class="tok-n">Arkham</span> <span class="tok-n">Naughty</span>
<span class="tok-n">Riddler</span> <span class="tok-mi">12</span> <span class="tok-n">Riddler</span> <span class="tok-n">Street</span>, <span class="tok-n">Arkham</span> <span class="tok-n">Naughty</span>
<span class="tok-n">Robin</span> <span class="tok-mi">2</span> <span class="tok-n">Robin</span> <span class="tok-n">Street</span>, <span class="tok-n">Gotham</span> <span class="tok-n">Nice</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>她希望将 naughty 的人排除在一个列表中，将 nice 的人过滤到另一个列表中，因为 Krampus 将在今年处理所有 naughty 的人。</p>
</div>
<div class="paragraph">
<p>S.夫人用这样的 grammar 开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">naughty-nice-list</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> {<span class="tok-sr"> &lt;details&gt;+ </span>} <span class="tok-c1"># Find one or more records made up of name, address, assessment (defined below)</span>

    <span class="tok-k">token</span><span class="tok-n"> details</span> {<span class="tok-sr"> &lt;name&gt; &lt;address&gt; &lt;assessment&gt; </span>}  <span class="tok-c1"># Find the elements from below, in this order</span>

    <span class="tok-k">token</span><span class="tok-n"> name</span> {<span class="tok-sr"> .*? \t </span>} <span class="tok-c1"># Find any characters up to the earliest tab</span>

    <span class="tok-k">token</span><span class="tok-n"> address</span> {<span class="tok-sr"> .*? \t </span>} <span class="tok-c1"># Find any characters up to the earliest tab</span>

    <span class="tok-k">token</span><span class="tok-n"> assessment</span> {<span class="tok-sr"> Naughty|Nice \n </span>} <span class="tok-c1"># Find either &#39;Naughty&#39; or &#39;Nice&#39; followed by a newline</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并在列表上调用它，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">naughty-nice-list</span>.<span class="tok-n">parsefile</span>(<span class="tok-s">&quot;./list.txt&quot;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，当然，她必须做一些事情将细节放入单独的列表中。</p>
</div>
<div class="paragraph">
<p>为此，她创建了一个 action 动作类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">santa-list-actions</span> {
    <span class="tok-k">has</span> <span class="tok-nv">%!filtered-lists</span>; <span class="tok-c1"># Create a private hash for this class</span>

    <span class="tok-k">method</span> <span class="tok-n">show</span> { <span class="tok-k">return</span> <span class="tok-nv">%!filtered-lists</span> } <span class="tok-c1"># Create a method to return our hash to the user</span>

    <span class="tok-c1"># This method is automatically called when the token with the same name makes a match</span>
    <span class="tok-k">method</span> <span class="tok-n">details</span> (<span class="tok-vg">$/</span>) {
        <span class="tok-c1"># Create an array of just the name and address matches converted to strings</span>
        <span class="tok-k">my</span> <span class="tok-nv">@details</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$&lt;name&gt;</span>.<span class="tok-nb">Str</span>, <span class="tok-nv">$&lt;address&gt;</span>.<span class="tok-nb">Str</span>);
        <span class="tok-c1"># Push the @details array into an array accessed with the &#39;Naughty&#39; or &#39;Nice&#39; key</span>
        <span class="tok-c1"># Note the curly braces to interpolate { $ } instead of .</span>
        <span class="tok-c1"># Otherwise we would get literally what we typed for the hash key.</span>
        <span class="tok-nv">%!filtered-lists</span>{ <span class="tok-nv">$&lt;assessment&gt;</span>.<span class="tok-nb">Str</span> }.<span class="tok-nb">push</span>(<span class="tok-nv">@details</span>);
    };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>她这样使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$actions</span> = <span class="tok-n">santa-list-actions</span>.<span class="tok-nb">new</span>;
<span class="tok-n">naughty-nice-list</span>.<span class="tok-n">parsefile</span>(<span class="tok-s">&quot;./list.txt&quot;</span>, <span class="tok-n">actions</span>=&gt;<span class="tok-nv">$actions</span>); <span class="tok-c1"># As Mrs S. called the object &#39;actions&#39;, the same as the keyword, she could write :$actions instead of actions=&gt;$actions</span>
<span class="tok-k">my</span> <span class="tok-nv">%hash-naughty-nice</span> = <span class="tok-nv">$actions</span>.<span class="tok-n">show</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人非常开心，她现在有一个哈希表，其中包含 'Naughty' 和 'Nice' 的键，每个键都包含一系列每个人的详细信息。</p>
</div>
<div class="paragraph">
<p>但是钓鱼洞里总是有一只北极熊爪子，尽管有圣诞老人的保证，来自世界各地的精灵们并不只是 “Naughty” 或 “Nice”。他们用自己的语言说出来！</p>
</div>
<div class="paragraph">
<p>圣诞老人特别问过，但圣诞老人坚持不懈。只有 'Naughty' 或 'Nice'。但有些列表看起来像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Batman</span> <span class="tok-mi">1</span> <span class="tok-n">Bat</span> <span class="tok-n">Street</span>, <span class="tok-n">Gotham</span> <span class="tok-n">Nice</span>
<span class="tok-n">Joker</span> <span class="tok-mi">5</span> <span class="tok-n">Joker</span> <span class="tok-n">Street</span>, <span class="tok-n">Arkham</span> <span class="tok-n">Naughty</span>
<span class="tok-n">Riddler</span> <span class="tok-mi">12</span> <span class="tok-n">Riddler</span> <span class="tok-n">Street</span>, <span class="tok-n">Arkham</span> <span class="tok-n">Naughty</span>
<span class="tok-n">Robin</span> <span class="tok-mi">2</span> <span class="tok-n">Robin</span> <span class="tok-n">Street</span>, <span class="tok-n">Gotham</span> <span class="tok-n">Nice</span>
<span class="tok-n">El</span> <span class="tok-n">Gato</span> <span class="tok-n">Negro</span> <span class="tok-mi">1</span> <span class="tok-n">Gato</span> <span class="tok-n">Street</span>, <span class="tok-n">South</span> <span class="tok-n">Texas</span> <span class="tok-n">Bueno</span>
<span class="tok-n">Victor</span> <span class="tok-n">Mancho</span> <span class="tok-mi">3</span> <span class="tok-n">Mancho</span> <span class="tok-n">Street</span>, <span class="tok-n">New</span> <span class="tok-n">York</span> <span class="tok-n">City</span> <span class="tok-n">Malo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人简单地认为只是对新词进行硬编码，但她知道这不是懒惰的时候。世界各地都有精灵，她需要能够进化的东西。</p>
</div>
<div class="paragraph">
<p>所以，为了现在调用她的脚本，她创建了两个数组并将它们传递给 grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@nice</span> = [<span class="tok-s">&#39;Nice&#39;</span>, <span class="tok-s">&#39;Bueno&#39;</span>];
<span class="tok-k">my</span> <span class="tok-nv">@naughty</span> = [<span class="tok-s">&#39;Naughty&#39;</span>, <span class="tok-s">&#39;Malo&#39;</span>];
<span class="tok-n">naughty-nice-list</span>.<span class="tok-n">parsefile</span>(<span class="tok-s">&quot;./list.txt&quot;</span>, <span class="tok-n">args</span>=&gt;(<span class="tok-nv">@nice</span>, <span class="tok-nv">@naughty</span>), <span class="tok-n">actions</span>=&gt;<span class="tok-nv">$actions</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>她改变了这样的 grammar 来使用新的数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">grammar</span> <span class="tok-n">naughty-nice-list</span> {
    <span class="tok-k">token</span><span class="tok-n"> TOP</span> (<span class="tok-vg">@*nice-words</span>, <span class="tok-vg">@*naughty-words</span>) {<span class="tok-sr"> &lt;details&gt;+ </span>} <span class="tok-c1"># Create dynamic arrays with the passed in arrays, available throughout the grammar</span>
    <span class="tok-k">token</span><span class="tok-n"> details</span> {<span class="tok-sr"> &lt;name&gt; &lt;address&gt; &lt;assessment&gt; </span>}
    <span class="tok-k">token</span><span class="tok-n"> name</span> {<span class="tok-sr"> .*? \t </span>}
    <span class="tok-k">token</span><span class="tok-n"> address</span> {<span class="tok-sr"> .*? \t </span>}
    <span class="tok-k">token</span><span class="tok-n"> assessment</span> {<span class="tok-sr"> @*naughty-words|@*nice-words \n </span>} <span class="tok-c1"># Find either a word from the naughty-words array or from the nice-words array followed by a newline</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是S.太太意识到她现在最终会在她的 action 动作类中的哈希表中创建许多不同的键。 键将是 'Nice'，'Naughty'，'Bueno' 或 'Malo'，因为这些将是 <code>$</code> 可能拥有的匹配单词（未来有更多可能出现）。</p>
</div>
<div class="paragraph">
<p>因此，她进行了另一项更改，为评估令牌命名语法中的潜在匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">token</span><span class="tok-n"> assessment</span> {<span class="tok-sr"> $&lt;Naughty&gt;=@*naughty-words|$&lt;Nice&gt;=@*nice-words \n </span>} <span class="tok-c1"># Mrs S. has now added names to the potential matches</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 action 动作类中，必须进行更改以适应这种情况。使用 <code>make</code> 和 <code>made</code>，圣诞老人将存储相应匹配的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">santa-list-actions</span> {
    <span class="tok-k">has</span> <span class="tok-nv">%!filtered-lists</span>;

    <span class="tok-k">method</span> <span class="tok-n">show</span> { <span class="tok-k">return</span> <span class="tok-nv">%!filtered-lists</span> };

    <span class="tok-k">method</span> <span class="tok-n">details</span> (<span class="tok-vg">$/</span>) {
        <span class="tok-k">my</span> <span class="tok-nv">@details</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$&lt;name&gt;</span>.<span class="tok-nb">Str</span>, <span class="tok-nv">$&lt;address&gt;</span>.<span class="tok-nb">Str</span>);
        <span class="tok-nv">%filtered-lists</span>{ <span class="tok-nv">$&lt;assessment&gt;</span>.<span class="tok-n">made</span> }.<span class="tok-nb">push</span>(<span class="tok-nv">@details</span>); <span class="tok-c1"># This will now use the value from &#39;assessment.made&#39; as the key, rather than the match in &#39;assessment.Str&#39;</span>
    };

    <span class="tok-k">method</span> <span class="tok-n">assessment</span> (<span class="tok-vg">$/</span>) {
        <span class="tok-k">if</span> <span class="tok-nv">$&lt;Naughty&gt;</span> { <span class="tok-c1"># If the named pattern &#39;Naughty&#39; matched...</span>
            <span class="tok-k">make</span> <span class="tok-s">&quot;Naughty&quot;</span> <span class="tok-c1"># ... set assessment.made to &quot;Naughty&quot;</span>
        } <span class="tok-k">elsif</span> <span class="tok-nv">$&lt;Nice&gt;</span>; { <span class="tok-c1"># Or if the named pattern &#39;Nice&#39; matched...</span>
            <span class="tok-k">make</span> <span class="tok-s">&quot;Nice&quot;</span> <span class="tok-c1"># ... set assessment.made to &quot;Nice&quot;</span>
        };
     };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦圣诞老人将数据捕获到她自己的哈希中，她就可以轻松地检查出今年已经被马洛的 Victor Mancho 将其列入正确的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-nv">%hash-naughty-nice&lt;Naughty&gt;</span>[<span class="tok-mi">2</span>][<span class="tok-mi">0</span>]; <span class="tok-c1"># Produces the output &#39;Victor Mancho&#39;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在，圣诞老人可以将 “Naughty” 或 “Nice” 的任何新翻译添加到相关数组，而不会触及 grammar。</p>
</div>
<div class="paragraph">
<p>圣诞老人发现自己对 Perl 6 grammar 的灵活性非常满意。圣诞老人对这个问题的研究起初不那么重要&#8230;&#8203;&#8230;&#8203;但是她知道她在确保每个人都能得到一个礼物或者在这个圣诞节的窗户上扔蛋的方法上做得很好。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十三天_使用_cro_和_debian_从头构建_web_服务">35. 第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我和圣诞老人​​谈过，他说他不知道如何在 <strong>Debian</strong> 上安装 <strong>Cro</strong>，所以我对自己说：我要帮助他。</p>
</div>
<div class="paragraph">
<p>如果您对 <strong>Apache</strong> 等 Web 服务器有一些经验，并且您已经听说过 <strong>Perl6</strong> 强大的并发/响应方面，那么您肯定有兴趣了解 <a href="https://cro.services/">Cro 服务</a>。这篇文章的受众是<strong>具有 Debian 基本经验的人</strong>，或者在 <strong>Perl6</strong> 新手&#8230;&#8203;就像圣诞老人一样。</p>
</div>
<div class="paragraph">
<p><strong>Cro</strong> 是一个 <strong>Perl6 模块</strong>，它提供了轻松构建反应式和并发服务所需的一切，例如：Web 服务器。</p>
</div>
<div class="paragraph">
<p>在这篇文章中，我们将看到如何在 <strong>Debian</strong> 中安装 <strong>Cro</strong>，这是最受欢迎的 Linux 发行版之一。然后，我将解释 <strong>Cro</strong> 的演示示例。</p>
</div>
<div class="paragraph">
<p>我们将使用 <strong>Debian 9,64 位</strong>（Stretch），我们将在安装后启动它。</p>
</div>
<div class="sect2">
<h3 id="_安装_rakudo_perl6_编译器">35.1. 安装 Rakudo Perl6 编译器</h3>
<div class="paragraph">
<p><a href="https://rakudo.org/">Rakudo</a> 是 <strong>Cro</strong> 模块运行的当前 <strong>Perl6</strong> 编译器。安装 <strong>Rakudo</strong> 的常规方法是安装 <a href="https://rakudo.org/files">Rakudo Star</a>，但我更喜欢快速的方式：<a href="https://github.com/nxadm/rakudo-pkg">rakudo-pkg</a> &#8230;&#8203;&#8230;&#8203;怎么样？只需从此 <a href="https://github.com/nxadm/rakudo-pkg#direct-downloads">repo</a> 下载并安装相应的 <strong>Debian 软件包</strong>。在我们的例子中，是来自 <strong>Debian 9, 64位</strong>的 <strong>.deb</strong> 文件。</p>
</div>
<div class="paragraph">
<p>使用 <strong>Debian</strong> 中的 root 用户，我们可以在 root home 中为 <strong>Rakudo</strong> 创建一个包文件夹，进入这个目录，下载 <strong>Debian 9, 64 位</strong>的当前 <strong>Rakudo</strong> 包，并安装它。就我而言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">mkdir</span> ~/<span class="tok-n">rakudo-packages</span> &amp;&amp; <span class="tok-n">cd</span> <span class="tok-nv">$_</span>
<span class="tok-n">wget</span> <span class="tok-n">https:</span>//<span class="tok-n">github</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">nxadm</span><span class="tok-o">/</span><span class="tok-n">rakudo-pkg</span><span class="tok-o">/</span><span class="tok-n">releases</span><span class="tok-o">/</span><span class="tok-n">download</span><span class="tok-o">/</span><span class="tok-n">v2018</span><span class="tok-mf">.10</span><span class="tok-o">-</span><span class="tok-mo">02</span><span class="tok-o">/</span><span class="tok-n">rakudo-pkg-Debian9_2018</span><span class="tok-mf">.10</span><span class="tok-o">-</span><span class="tok-mo">02</span><span class="tok-n">_amd64</span>.<span class="tok-n">deb</span>
<span class="tok-n">dpkg</span> -<span class="tok-n">i</span> <span class="tok-n">rakudo-pkg-Debian9_2018</span><span class="tok-mf">.10</span><span class="tok-o">-</span><span class="tok-mo">02</span><span class="tok-n">_amd64</span>.<span class="tok-n">deb</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rakudo</strong> 运行时编译器和相关工具现在安装在 <strong>/opt/rakudo-pkg</strong> 文件夹中。在 <strong>export PATH</strong> 行之前，让所有用户在 <strong>/etc/profile</strong> 文件中插入以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">PATH</span>=<span class="tok-nv">$PATH:</span>/<span class="tok-n">opt</span><span class="tok-o">/</span><span class="tok-n">rakudo-pkg</span><span class="tok-o">/</span><span class="tok-n">bin</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span><span class="tok-nb">source</span> /etc/profile</code></pre>
</div>
</div>
<div class="paragraph">
<p>为所有用户重新加载 <strong>Debian</strong> 配置文件。</p>
</div>
<div class="paragraph">
<p>输入 <strong>perl6 -v</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>perl6 -v
This is Rakudo version <span class="tok-m">2018</span>.10 built on MoarVM version <span class="tok-m">2018</span>.10
implementing Perl <span class="tok-m">6</span>.c.</code></pre>
</div>
</div>
<div class="paragraph">
<p>欢迎来到 <strong>Rakudo Perl6!</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_安装_cro_服务">35.2. 安装 Cro 服务</h3>
<div class="paragraph">
<p><strong>Cro</strong> 是 Perl6 模块，<strong>Zef</strong> 是已经安装的当前 <strong>Perl6</strong> 模块管理器。我们来安装 <strong>Cro</strong> 吧！</p>
</div>
<div class="paragraph">
<p>首先，我们将安装一些 <strong>Cro 包依赖项</strong>，例如 <strong>git</strong> 来连接和下载来自 Cro 相关存储库的文件，<strong>libssl-dev</strong> 以提供对安全套接字层的支持，<strong>build-essential</strong> 用于构建在安装期间 <strong>Cro</strong> 所使用的一些依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>apt-get install git libssl-dev build-essential</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您位于仅允许 Web 流量（端口80和443）的防火墙下，它将阻止 <strong>git</strong> 协议使用的端口，并且 <strong>Cro</strong> 安装将失败。要避免这种情况，请键入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>git config --global url.<span class="tok-s2">&quot;https://&quot;</span>.insteadOf git://</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉 <strong>git</strong> 使用 <strong>https</strong> 而不是 <strong>git</strong> 协议来连接 git 远程仓库。</p>
</div>
<div class="paragraph">
<p>现在我们准备用 <strong>Zef</strong>（及其所有依赖项）安装 <strong>Cro</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>zef install cro</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在测试阶段安装失败，请尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>zef install --/test cro</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <strong>Cro</strong> 安装正确完成，<strong>Cro</strong> 就准备好了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cro_实战">35.3. Cro 实战</h3>
<div class="paragraph">
<p>让我们继续演示脚本。创建一个工作区文件夹，输入它并将下面的代码粘贴到名为 <strong>server.p6</strong> 的新文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Router</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Server</span>;

<span class="tok-k">my</span> <span class="tok-nv">$application</span> = <span class="tok-n">route</span> {
  <span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;greet&#39;</span>, <span class="tok-nv">$name</span> {
  <span class="tok-n">content</span> <span class="tok-s">&#39;text/plain&#39;</span>, <span class="tok-s">&quot;Hello, $name!&quot;</span>;
  }
}

<span class="tok-k">my</span> <span class="tok-n">Cro::Service</span> <span class="tok-nv">$hello</span> = <span class="tok-n">Cro::HTTP::Server</span>.<span class="tok-nb">new</span>(:<span class="tok-n">host</span><span class="tok-s">&lt;0.0.0.0&gt;</span>, :<span class="tok-n">port</span><span class="tok-s">&lt;10000&gt;</span>, :<span class="tok-nv">$application</span>);

<span class="tok-nv">$hello</span>.<span class="tok-n">start</span>;

<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) { <span class="tok-nv">$hello</span>.<span class="tok-n">stop</span>; <span class="tok-k">exit</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本有 <strong>4个部分</strong>：</p>
</div>
<div class="paragraph">
<p>“use”使<strong>路由</strong>和<strong>服务</strong>类可用于下面。</p>
</div>
<div class="paragraph">
<p><strong>$application</strong> 是包含我们的 Web 应用程序的路由逻辑的对象，接收数据并将数据从客户端分发到我们的服务器。在这种情况下，<strong>get  &#8594;'greet'，$name</strong> 映射来自客户端 Web 浏览器的传入 URL <strong>/greet/Ramiro</strong>，在对象 <strong>$name</strong> 中推送 Ramiro。然后将代码转换为花括号 {}，返回响应 HTTP 请求头 <strong>content 'text/plain'</strong> 和 HTTP 请求体 <strong>Hello, Ramiro!</strong> 到客户端 Web 浏览器。在一个严肃的应用程序中，在这部分中将会调用应用程序本身，并且它将等待响应，如示例所示。</p>
</div>
<div class="paragraph">
<p><strong>$hello</strong> 是一个服务对象，它使传入的数据通过新的侦听套接字传递给我们的 <strong>$application</strong>。它有3个参数，<strong>:host&lt;0.0.0.0&gt;</strong> 是服务启动的 localhost, <strong>:port&lt;10000&gt;</strong> 是用于监听传入数据的端口，<strong>$application</strong> 是我们的Web 应用程序。 下面的行 <strong>$hello.start</strong> 开始侦听。</p>
</div>
<div class="paragraph">
<p><strong>react whenever</strong> 等待按下 CTRL-C 时停止 Web 服务。</p>
</div>
<div class="paragraph">
<p>现在是从 shell 运行 Web 服务的时刻：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>perl6 server.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您需要知道服务器主机的当前 IP 地址，尝试使用 <strong>ip addr</strong>。我的 Ip 地址是: <strong>192.168.1.48</strong>。</p>
</div>
<div class="paragraph">
<p>然后，从同一网络中的其他主机，打开 Web 浏览器并键入（在我这儿）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>http://192.168.1.48:10000/greet/Ramiro</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案应该是 <strong>Hello, Ramiro!</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">35.4. 总结</h3>
<div class="paragraph">
<p>从 <strong>Debian</strong> 的新安装开始，我们已经了解了如何安装 <strong>Cro</strong> 并运行演示脚本。现在，您已准备好继续使用 Cro 文档，并发现 <strong>Perl6</strong> 可提供的最有前途的并发/异步服务平台。</p>
</div>
<div class="paragraph">
<p>我希望在阅读这篇文章并查看 <a href="https://cro.services/docs">Cro 文档</a>后，圣诞老人可以将他的网站迁移到 Cro Services。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十四天_使用_perl_6_设计小航天器">36. 第十四天 - 使用 Perl 6 设计(小)航天器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_寻找共同点">36.1. 寻找共同点</h3>
<div class="paragraph">
<p>大家好！</p>
</div>
<div class="paragraph">
<p>那些日子我花了一些时间在基础部件上工作，揭示了可能的惊喜，Perl 6 的 <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP（轻量级目录访问协议）</a>实现。</p>
</div>
<div class="paragraph">
<p>然而，现在谈论这个还为时尚早，所以我现在将有一些神秘的封面覆盖这个话题，因为我们有另一个 - 宇宙飞船！</p>
</div>
<div class="paragraph">
<p>航天器和LDAP之间的共同点是：LDAP规范使用一种称为符号的符号 <code>ASN.1</code>，它允许使用特定的文本语法定义抽象类型，并在 `ASN.1`编译器的帮助下，为特定的编程语言创建类型定义，以及什么是更多：此类型值的编码器和解码器，可以将您的值序列化为某些数据，例如，可以通过网络发送并在另一台计算机上很好地解析。</p>
</div>
<div class="paragraph">
<p>通过这种方式，您可以轻松地在应用程序中获得跨平台类型。编码器和解码器可以自动生成，不仅针对某些指定的编码格式，而且针对整个范围的二进制（例如 <code>BER</code>，<code>PER`和其他）和文本（例如`SOAP</code>）编码格式。</p>
</div>
<div class="paragraph">
<p>因此，为了完成工作，我必须至少实现 `ASN.1`Perl 6中的一些子集- 不是完整的规范，这很大，只关注LDAP规范中使用的功能。</p>
</div>
<div class="paragraph">
<p>“这听起来很有趣，但我们的宇宙飞船在哪里！？”，你可能会问。事实证明，这种 <code>Rocket</code> 类型是您在 <a href="http://asn1-playground.oss.com/">ASN.1 Playground</a> 网站上看到的第一件事，它让您可以免费访问 `ASN.1`编译器，它可以作为参考！</p>
</div>
</div>
<div class="sect2">
<h3 id="_asn_1_和限制">36.2. <code>ASN.1</code> 和限制</h3>
<div class="paragraph">
<p>这是花哨的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">World-Schema</span> <span class="tok-n">DEFINITIONS</span> <span class="tok-n">AUTOMATIC</span> <span class="tok-n">TAGS</span> ::=
<span class="tok-k">BEGIN</span>
  <span class="tok-n">Rocket</span> ::= <span class="tok-n">SEQUENCE</span>
  {
     <span class="tok-nb">name</span>      <span class="tok-n">UTF8String</span> (<span class="tok-n">SIZE</span>(<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">16</span>)),
     <span class="tok-n">message</span>   <span class="tok-n">UTF8String</span> <span class="tok-n">DEFAULT</span> <span class="tok-s">&quot;Hello World&quot;</span> ,
     <span class="tok-n">fuel</span>      <span class="tok-n">ENUMERATED</span> {<span class="tok-n">solid</span>, <span class="tok-n">liquid</span>, <span class="tok-n">gas</span>},
     <span class="tok-n">speed</span>     <span class="tok-n">CHOICE</span>
     {
        <span class="tok-n">mph</span>    <span class="tok-n">INTEGER</span>,
        <span class="tok-n">kmph</span>   <span class="tok-n">INTEGER</span>
     }  <span class="tok-n">OPTIONAL</span>,
     <span class="tok-n">payload</span>   <span class="tok-n">SEQUENCE</span> <span class="tok-n">OF</span> <span class="tok-n">UTF8String</span>
  }
<span class="tok-k">END</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们快速浏览一下这个定义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Rocket</code> 是一个 <code>SEQUENCE</code>  - 一组某类型的有序值，可以看作是异构列表/数组或类。</p>
</li>
<li>
<p>场 <code>name</code> 和 <code>message</code> 有 <code>UTF8String</code> 型，这是肯定的，一种字符串表示的 <code>ASN.1</code>。字段name已应用长度限制，<code>(SIZE(1..16))</code> 和 <code>message</code> 具有指定的默认值 <code>DEFAULT "Hello World"</code>。</p>
</li>
<li>
<p>字段 <code>fuel`有 `ENUMERATED</code> 类型：它只是一个可供选择的标签枚举。</p>
</li>
<li>
<p>字段 <code>speed</code> 是一个 <code>CHOICE</code>，它是一种特殊类型，它描述了一个字段，该值可以是指定类型之一。不同的是 <code>ENUMERATED</code>，价值不仅仅是标签。<code>OPTIONAL</code> 如你所知，关键字意味着如果不存在，该字段可能会被省略。</p>
</li>
<li>
<p>字段 <code>payload</code> 是一个 <code>SEQUENCE</code>，但指定了类型。这意味着我们可以根据需要在这里拥有尽可能多的 <code>UTF8String</code> 值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这里我们将应用两个重要的限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们将使用 <code>Basic Encoding Rules（BER）</code> - 将 `ASN.1`类型编码指定为特定字节序列的规则。如上所述，有不同的格式，但我们将使用这一种。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Basic Encoding Rules</code> 标准是基于一个所谓的“TLV编码”的事情-的类型的值被编码为字节序列表示：“ Ť AG”，“ 大号 ength”和“ V传递类型的某些值的ALUE”。让我们更仔细地看一下&#8230;&#8203;&#8230;&#8203;以相反的顺序！</p>
</div>
<div class="paragraph">
<p>“值”是包含值的字节表示的部分。每种类型都有自己的编码模式（例如，<code>INTEGER</code> 编码方式不同 <code>UTF8String</code>）。</p>
</div>
<div class="paragraph">
<p>“长度”是表示“值”部分中的字节数的数字。这允许我们很好地处理增量解析（通常也是！）。它也可以具有“未知”值，这允许我们以未知的长度流式传输数据，但我们将把它放在一边。</p>
</div>
<div class="paragraph">
<p>“标签”简单地说是一个字节或一些字节，我们可以用它来确定我们手头有什么类型。其确切值由标记规则的数量（“标记模式”）确定，并且存在好的或更差的不同模式。</p>
</div>
<div class="paragraph">
<p>并且，如果您已经等待某些段落的第二个限制，那么它是：</p>
</div>
<div class="paragraph">
<p>我们将 <code>IMPLICIT</code> 在这里使用 BER 的类型标记模式。正如您所猜测的那样，<code>EXPLICIT</code> 标记模式也同时存在 <code>AUTOMATIC</code>（在上面的 Rocket 示例中使用）。</p>
</div>
<div class="paragraph">
<p>考虑到这一点，我们需要将 <code>ASN.1</code> 上面的类型更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">World-Schema</span> <span class="tok-n">DEFINITIONS</span> <span class="tok-n">IMPLICIT</span> <span class="tok-n">TAGS</span> ::=
<span class="tok-k">BEGIN</span>
  <span class="tok-n">Rocket</span> ::= <span class="tok-n">SEQUENCE</span>
  {
     <span class="tok-nb">name</span>      <span class="tok-n">UTF8String</span> (<span class="tok-n">SIZE</span>(<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">16</span>)),
     <span class="tok-n">message</span>   <span class="tok-n">UTF8String</span> <span class="tok-n">DEFAULT</span> <span class="tok-s">&quot;Hello World&quot;</span> ,
     <span class="tok-n">fuel</span>      <span class="tok-n">ENUMERATED</span> {<span class="tok-n">solid</span>, <span class="tok-n">liquid</span>, <span class="tok-n">gas</span>},
     <span class="tok-n">speed</span>     <span class="tok-n">CHOICE</span>
     {
        <span class="tok-n">mph</span>   [<span class="tok-mi">0</span>] <span class="tok-n">INTEGER</span>,
        <span class="tok-n">kmph</span>  [<span class="tok-mi">1</span>] <span class="tok-n">INTEGER</span>
     }  <span class="tok-n">OPTIONAL</span>,
     <span class="tok-n">payload</span>   <span class="tok-n">SEQUENCE</span> <span class="tok-n">OF</span> <span class="tok-n">UTF8String</span>
  }
<span class="tok-k">END</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>IMPLICIT TAGS</code> 用于代替字段中的 <code>AUTOMATIC TAGS</code> 和 <code>[$n]</code> 字符串 <code>speed</code>。</p>
</div>
<div class="paragraph">
<p>如果你看一下这个模式，事实证明，这是，其实，暧昧，因为 <code>mph</code> 和 <code>kmph</code> 都有 <code>INTEGER</code> 型。因此，如果我们 <code>INTEGER</code> 从字节流中读取了一个，它是 <code>mph</code> 值还是 <code>kmph</code> 值？如果我们谈论宇宙飞船，它会产生巨大的变化！</p>
</div>
<div class="paragraph">
<p>为了避免这种混淆，使用了特殊的标签，这里我们指定了我们想要的标签，因为与 <code>AUTOMATIC</code> 模式不同，<code>IMPLICIT</code> 它不适用于我们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_逐步建设问题答案">36.3. 逐步建设。问题答案。</h3>
<div class="paragraph">
<p>那么，我们可以用 Perl 6 中的所有功能做什么呢？虽然编译器可能很有趣，但是可以通过可扩展的方式编译成 Perl 6，并且包含了奇特的功能？必须有一些更简单的东西。</p>
</div>
<div class="paragraph">
<p>比方说，我们有一个适用于航天器的脚本。当然，我们需要一个类型来表示一个，特别是一个类，让我们称之为 <code>Rocket</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span>  <span class="tok-n">Rocket</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，我们想知道一些有关它的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">Rocket</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$.name</span>;
    <span class="tok-k">has</span> <span class="tok-nv">$.message</span> <span class="tok-k">is</span> <span class="tok-k">default</span>(<span class="tok-s">&quot;Hello World&quot;</span>);
    <span class="tok-k">has</span> <span class="tok-nv">$.fuel</span>;
    <span class="tok-k">has</span> <span class="tok-nv">$.speed</span>;
    <span class="tok-k">has</span> <span class="tok-nv">@.payload</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们必须使我们的 <code>Rocket</code> 定义更明确，那么我们指定一些类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">enum</span> <span class="tok-n">Fuel</span> <span class="tok-s">&lt;Solid Liquid Gas&gt;</span>;

<span class="tok-k">class</span> <span class="tok-n">Rocket</span> {
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.name</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.message</span> <span class="tok-k">is</span> <span class="tok-k">default</span>(<span class="tok-s">&quot;Hello World&quot;</span>);
    <span class="tok-k">has</span> <span class="tok-n">Fuel</span> <span class="tok-nv">$.fuel</span>;
    <span class="tok-k">has</span> <span class="tok-nv">$.speed</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">@.payload</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在它开始提醒我们一些事情&#8230;&#8203;&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Str</code> 类似 <code>UTF8String</code>，只是我们不能离开它这样，因为 <code>ASN.1`我们不仅有 `UTF8String</code>，而且 <code>BIT STRING</code>，<code>OCTET STRING</code> 和其他字符串类型。</p>
</li>
<li>
<p><code>Fuel</code> 枚举类似于 <code>ENUMERATED</code> 类型。</p>
</li>
<li>
<p><code>@.payload</code> 中的 <code>@</code> 符号告诉我们，这将是一个序列，而且 <code>Str</code> 指定其元素的类型。</p>
</li>
<li>
<p>但是虽然有一些类似的观点，但从我们 `ASN.1`的观点来看，我们没有足够的数据。让我们一步一步解决这些问题！</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道这完全Rocket是 `ASN.1`序列类型？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过应用角色：<code>class Rocket does ASNSequence</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道确切的字段顺序？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过实现此角色的存根方法：<code>method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }</code></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道这 <code>$.speed</code> 是可选的？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们只是应用它的特征！<a href="https://docs.perl6.org/language/traits">Traits</a> 允许我们在代码部分上执行自定义代码，特别是 <code>Attributes</code>。例如，虚构的API可以是这样的：<code>has $.speed is optional</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道 $.speed 是多少？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>由于 <code>CHOICE</code> 类型是“特殊的”，但仍然是一流的（例如，你可以使它递归），我们需要在这里发挥作用：<code>ASNChoice</code> 来救援。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="literalblock">
<div class="content">
<pre>我们怎么知道 `ASN.1`我们的 Str 类型是什么类型的字符串？</pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们来写吧 <code>has Str $.name is UTF8String;</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们如何指定字段的默认值？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>虽然 Perl 6 已经具有内置 <code>is default</code> 特性，但对我们来说不好的是我们无法“很好地”检测到它。因此，我们必须引入另一个自定义特征，以满足我们的目的并应用内置特征：<code>has Str $.message is default-value("Hello World");</code></p>
</div>
<div class="paragraph">
<p>让我们在一个包中回答所有这些问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">role</span> <span class="tok-n">ASNSequence</span> { <span class="tok-cm">#`[ Elves Special Magic Truly Happens Here ]</span> }

<span class="tok-k">role</span> <span class="tok-n">ASNChoice</span> { <span class="tok-cm">#`[ And even here ]</span>  }

<span class="tok-k">class</span> <span class="tok-n">SpeedChoice</span> <span class="tok-nb">does</span> <span class="tok-n">ASNChoice</span> {
    <span class="tok-k">method</span> <span class="tok-n">ASN-choice</span>() {
        <span class="tok-c1"># Description of: names, tags, types specificed by this CHOICE</span>
        { <span class="tok-n">mph</span> =&gt; (<span class="tok-mi">0</span> =&gt; <span class="tok-nb">Int</span>), <span class="tok-n">kmph</span> =&gt; (<span class="tok-mi">1</span> =&gt; <span class="tok-nb">Int</span>) }
    }
}

<span class="tok-k">class</span> <span class="tok-n">Rocket</span> <span class="tok-nb">does</span> <span class="tok-n">ASNSequence</span> {
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.name</span> <span class="tok-k">is</span> <span class="tok-n">UTF8String</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.message</span> <span class="tok-k">is</span> <span class="tok-n">default-value</span>(<span class="tok-s">&quot;Hello World&quot;</span>) <span class="tok-k">is</span> <span class="tok-n">UTF8String</span>;
    <span class="tok-k">has</span> <span class="tok-n">Fuel</span> <span class="tok-nv">$.fuel</span>;
    <span class="tok-k">has</span> <span class="tok-n">SpeedChoice</span> <span class="tok-nv">$.speed</span> <span class="tok-k">is</span> <span class="tok-n">optional</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">@.payload</span> <span class="tok-k">is</span> <span class="tok-n">UTF8String</span>;

    <span class="tok-k">method</span> <span class="tok-n">ASN-order</span> { <span class="tok-s">&lt;$!name $!message $!fuel $!speed @!payload&gt;</span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值可能类似于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$rocket</span> = <span class="tok-n">Rocket</span>.<span class="tok-nb">new</span>(
    <span class="tok-nb">name</span> =&gt; <span class="tok-s">&#39;Falcon&#39;</span>,
    <span class="tok-n">fuel</span> =&gt; <span class="tok-n">Solid</span>,
    <span class="tok-n">speed</span> =&gt; <span class="tok-n">SpeedChoice</span>.<span class="tok-nb">new</span>((<span class="tok-n">mph</span> =&gt; <span class="tok-mi">18000</span>)),
    <span class="tok-n">payload</span> =&gt; [ <span class="tok-s">&quot;Car&quot;</span>, <span class="tok-s">&quot;GPS&quot;</span> ]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案越多，问题就越多</p>
</div>
<div class="paragraph">
<p>对于这个微小的例子（另一方面，它已经 `ASN.1`展示了许多特性），实际上，我们需要在我们的应用程序中使用这个类的实例，并可能根据需要对其进行编码和解码。</p>
</div>
<div class="paragraph">
<p>那么精灵们对我们的数据秘密做了什么？让我们在下一篇文章中找到答案！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_使用_perl_6_构建小型航天器">37. 第十五天 - 使用 Perl 6 构建(小型)航天器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_炫耀长耳朵">37.1. 炫耀长耳朵</h3>
<div class="paragraph">
<p>在<a href="https://perl6advent.wordpress.com/2018/12/14/designing-a-space-ship-with-perl-6/">上一篇文章</a>中，我们遇到了某种特殊精灵的魔力：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">enum</span> <span class="tok-n">Fuel</span> <span class="tok-s">&lt;Solid Liquid Gas&gt;</span>;

<span class="tok-k">class</span> <span class="tok-n">SpeedChoice</span> <span class="tok-nb">does</span> <span class="tok-n">ASNChoice</span> {
    <span class="tok-k">method</span> <span class="tok-n">ASN-choice</span> { { <span class="tok-n">mph</span> =&gt; (<span class="tok-mi">1</span> =&gt; <span class="tok-nb">Int</span>), <span class="tok-n">kmph</span> =&gt; (<span class="tok-mi">0</span> =&gt; <span class="tok-nb">Int</span>) } }
}

<span class="tok-k">class</span> <span class="tok-n">Rocket</span> <span class="tok-nb">does</span> <span class="tok-n">ASNSequence</span> {
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.name</span> <span class="tok-k">is</span> <span class="tok-n">UTF8String</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.message</span> <span class="tok-k">is</span> <span class="tok-n">default-value</span>(<span class="tok-s">&quot;Hello World&quot;</span>) <span class="tok-k">is</span> <span class="tok-n">UTF8String</span>;
    <span class="tok-k">has</span> <span class="tok-n">Fuel</span> <span class="tok-nv">$.fuel</span>;
    <span class="tok-k">has</span> <span class="tok-n">SpeedChoice</span> <span class="tok-nv">$.speed</span> <span class="tok-k">is</span> <span class="tok-n">optional</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">@.payload</span> <span class="tok-k">is</span> <span class="tok-n">UTF8String</span>;

    <span class="tok-k">method</span> <span class="tok-n">ASN-order</span> { <span class="tok-s">&lt;$!name $!message $!fuel $!speed @!payload&gt;</span> }
}

<span class="tok-k">my</span> <span class="tok-nv">$rocket</span> = <span class="tok-n">Rocket</span>.<span class="tok-nb">new</span>(
    <span class="tok-nb">name</span> =&gt; <span class="tok-s">&#39;Falcon&#39;</span>,
    <span class="tok-n">fuel</span> =&gt; <span class="tok-n">Solid</span>,
    <span class="tok-n">speed</span> =&gt; <span class="tok-n">SpeedChoice</span>.<span class="tok-nb">new</span>((<span class="tok-n">mph</span> =&gt; <span class="tok-mi">18000</span>)),
    <span class="tok-n">payload</span> =&gt; [ <span class="tok-s">&quot;Car&quot;</span>, <span class="tok-s">&quot;GPS&quot;</span> ]);

<span class="tok-k">my</span> <span class="tok-nv">$rocket-bytes</span> = <span class="tok-n">ASN::Serializer</span>.<span class="tok-n">serialize</span>(<span class="tok-nv">$rocket</span>, :<span class="tok-n">mode</span>(<span class="tok-n">Implicit</span>));

<span class="tok-cm">#`[ Result:</span>
<span class="tok-cm">      Blob.new(</span>
<span class="tok-cm">          0x30, 0x1B, # Outermost SEQUENCE</span>
<span class="tok-cm">          0x0C, 0x06, 0x46, 0x61, 0x6C, 0x63, 0x6F, 0x6E, # NAME, MESSAGE is missing</span>
<span class="tok-cm">          0x0A, 0x01, 0x00, # ENUMERATED</span>
<span class="tok-cm">          0x81, 0x02, 0x46, 0x50, # CHOICE</span>
<span class="tok-cm">          0x30, 0x0A, # SEQUENCE OF UTF8String</span>
<span class="tok-cm">              0x0C, 0x03, 0x43, 0x61, 0x72,  # UTF8String</span>
<span class="tok-cm">              0x0C, 0x03, 0x47, 0x50, 0x53); # UTF8String</span>
<span class="tok-cm">]</span>

<span class="tok-nb">say</span> <span class="tok-n">ASN::Parser</span>.<span class="tok-nb">new</span>(:<span class="tok-n">type</span>(<span class="tok-n">Rocket</span>)).<span class="tok-n">parse</span>(<span class="tok-nv">$rocket-bytes</span>) <span class="tok-o">eqv</span> <span class="tok-nv">$rocket</span>; <span class="tok-c1"># Certainly true!</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型类型类型">37.2. 类型，类型，类型</h3>
<div class="paragraph">
<p>有些事情是不言而喻的（或者对于我来说，用了无数个小时来看精灵如何玩魔法）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># 1</span>
<span class="tok-k">role</span> <span class="tok-n">ASNSequence</span> {
    <span class="tok-c1"># every descendant has to fulfill this important vow!</span>
    <span class="tok-k">method</span> <span class="tok-n">ASN-order</span> {...}
}

<span class="tok-c1"># 2</span>
<span class="tok-k">role</span> <span class="tok-n">ASNChoice</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$.choice-value</span>;

    <span class="tok-c1"># if you have to choose, choose wisely!</span>
    <span class="tok-k">method</span> <span class="tok-n">ASN-choice</span>() {...}
    <span class="tok-k">method</span> <span class="tok-n">ASN-value</span>() { <span class="tok-nv">$!choice-value</span> }

    <span class="tok-k">method</span> <span class="tok-nb">new</span>(<span class="tok-nv">$choice-value</span>) { <span class="tok-nv">$?CLASS</span>.<span class="tok-nb">bless</span>(:<span class="tok-nv">$choice-value</span>) }
}

<span class="tok-c1"># 3</span>
<span class="tok-k">role</span> <span class="tok-n">ASN::StringWrapper</span> {
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.value</span>;

    <span class="tok-c1"># Don&#39;t do this at home. :]</span>
    <span class="tok-k">method</span> <span class="tok-nb">new</span>(<span class="tok-nb">Str</span> <span class="tok-nv">$value</span>) { <span class="tok-k">self</span>.<span class="tok-nb">bless</span>(:<span class="tok-nv">$value</span>) }
}

<span class="tok-c1"># UTF8String wrapper</span>
<span class="tok-k">role</span> <span class="tok-n">ASN::Types::UTF8String</span> <span class="tok-nb">does</span> <span class="tok-n">ASN::StringWrapper</span> {}

<span class="tok-c1"># Yes, it is _this_ short</span>
<span class="tok-k">multi</span> <span class="tok-n">trait_mod:</span>(<span class="tok-n">Attribute</span> <span class="tok-nv">$attr</span>, :<span class="tok-nv">$UTF8String</span>) <span class="tok-k">is</span> <span class="tok-k">export</span> { <span class="tok-nv">$attr</span> <span class="tok-nb">does</span> <span class="tok-n">ASN::Types::UTF8String</span> }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个是一个简单的角色，它允许我们强制执行 <code>ASN-order</code> 方法</p>
</li>
<li>
<p>第二个是持有 CHOICE 实际值的角色，并强制执行用户必须描述可能选项的方法</p>
</li>
<li>
<p>第三个描述了一个特性，如 <code>is UTF8String</code>，它为属性添加一个角色，这将在以后帮助我们，并提供角色本身以及一些包装代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与第三部分表达的方式相同，可以表达 <code>OPTIONAL</code>，<code>DEFAULT</code> “traits”和其他字符串类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进步进化序列化">37.3. 进步，进化，序列化！</h3>
<div class="paragraph">
<p>通过一系列规则可以做什么来序列化事物？鉴于 <code>Basic Encoding Rules</code> 对不同类型的值有不同的处理方式（如果你思考一下就不会觉得太奇怪！）以及一个类型可以嵌套在另一个类型中的事实，更不用说是递归的了？我觉得它可能不太难实现。 Perl 6 的 multi-dispatch 正派上用场！</p>
</div>
<div class="paragraph">
<p>一般来说，事情如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">ASN::Serializer</span> {
    ...

    <span class="tok-c1"># like this:</span>
    <span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">serialize</span>(<span class="tok-n">ASNSequence</span> <span class="tok-nv">$sequence</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$index</span> = <span class="tok-mi">48</span>, :<span class="tok-nv">$debug</span>, :<span class="tok-nv">$mode</span> = <span class="tok-n">Implicit</span>) { ... }

    <span class="tok-c1"># or this:</span>
    <span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">serialize</span>(<span class="tok-nb">Int</span> <span class="tok-nv">$int</span> <span class="tok-k">is</span> <span class="tok-k">copy</span> <span class="tok-k">where</span> <span class="tok-nv">$int</span>.<span class="tok-nb">HOW</span> ~~ <span class="tok-n">Metamodel::ClassHOW</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$index</span> = <span class="tok-mi">2</span>, :<span class="tok-nv">$debug</span>, :<span class="tok-nv">$mode</span>) { ... }
    <span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">serialize</span>(<span class="tok-nv">$enum-value</span> <span class="tok-k">where</span> <span class="tok-nv">$enum-value</span>.<span class="tok-nb">HOW</span> ~~ <span class="tok-n">Metamodel::EnumHOW</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$index</span> = <span class="tok-mi">10</span>, :<span class="tok-nv">$debug</span>, :<span class="tok-nv">$mode</span>) { ... }

    <span class="tok-c1"># or even this:</span>
    <span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">serialize</span>(<span class="tok-nb">Positional</span> <span class="tok-nv">$sequence</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$index</span> <span class="tok-k">is</span> <span class="tok-k">copy</span> = <span class="tok-mi">16</span>, :<span class="tok-nv">$debug</span>, :<span class="tok-nv">$mode</span>) { ... }

    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>描述该领域所有内容的规则是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于复杂类型，必须引入一个 <strong>has</strong>，如 <code>ASNStructure</code>，迭代其内容，逐个序列化内部，并正确加入它。在一天结束时，对于每个这样的 <code>Serializer</code> 程序都具有已知的属性类型或者可以基于特征应用的角色（方便！）推断它，可以具有属性的值（或者如果属性是可选的并且可以省略则可以跳过该属性） ，可以包装/解包基于 <code>Str</code> 的类型 - 所有这些都允许一个序列化类型</p>
</li>
<li>
<p>对于简单类型，可以根据给定的规则对其进行序列化</p>
</li>
<li>
<p>对于一些方便的“特殊情况”，例如像 <code>@.foo</code> 那样的属性，需要推断发生了什么（在这种情况下，它将是 <code>SEQUENCEOF</code> 类型）并正确地序列化它</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了带有值的第一个参数外，还有三个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$index</code> 整数派上用场，特别是对于 BER 特定的索引</p>
</li>
<li>
<p><code>$debug</code> flag 启用调试输出（当调试一些二进制协议时，这非常有用！）</p>
</li>
<li>
<p>将来可能会使用 <code>$mode</code> 值来支持 <code>IMPLICIT</code> 以外的标记模式。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_如果有时间进行编码总会有时间进行解码">37.4. 如果有时间进行编码，总会有时间进行解码</h3>
<div class="paragraph">
<p>什么是解析器？如果序列化程序是“向后解析器”，那么解析器就是&#8230;&#8203;&#8230;&#8203;是的，它是一个向后的序列化器！但是这是什么意思？通常，序列化器接收一些 A 并产生一些给定形式的 B。并且解析器获取给定形式的一些 B 并产生一些 A。</p>
</div>
<div class="paragraph">
<p>假设有人知道正在解析的确切类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$parser</span> = <span class="tok-n">ASN::Parser</span>.<span class="tok-nb">new</span>(<span class="tok-n">type</span> =&gt; <span class="tok-n">Rocket</span>);
<span class="tok-nb">say</span> <span class="tok-nv">$parser</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$rocket-ber</span>); <span class="tok-c1"># Yes, here goes our rocket!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要解析此 <code>Buf</code> 内容，则必须指定其类型，就像下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">parse</span>(<span class="tok-nb">Blob</span> <span class="tok-nv">$input</span>, ...) {
    ...
    <span class="tok-k">self</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$input</span>, <span class="tok-nv">$!type</span>, ...);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法不知道它所解析的类型，但它调用了它的朋友：<code>parse($input, SomeCoolType, &#8230;&#8203;)</code> 超出了传递的内容和它可以得到的类型。如果知道了类型，多重分派将很乐意为我们提供必要的解析实现。对于简单的类型。对于复杂的类型。对于“特殊”类型。有了 Perl 6，任何一天都会发生便利的奇迹！</p>
</div>
<div class="paragraph">
<p>让我们再看一眼：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># Details and basic indentation are omitted for clarity</span>

...

<span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">parse</span>(<span class="tok-nb">Buf</span> <span class="tok-nv">$input</span> <span class="tok-k">is</span> <span class="tok-k">rw</span>, <span class="tok-n">ASNSequence</span> <span class="tok-nv">$type</span>, :<span class="tok-nv">$debug</span>, :<span class="tok-nv">$mode</span>) {
    <span class="tok-c1"># `$type` here is, really, not a value, but a Type Object. As `ASN-order` is defined on</span>
    <span class="tok-c1"># type, there are no problems with gathering necessary info:</span>
    <span class="tok-k">my</span> <span class="tok-nv">@params</span> = <span class="tok-k">do</span> <span class="tok-k">gather</span> {
        <span class="tok-k">for</span> <span class="tok-nv">$type</span>.<span class="tok-n">ASN-order</span>.<span class="tok-nb">kv</span> -&gt; <span class="tok-nv">$i</span>, <span class="tok-nv">$field</span> {
            <span class="tok-c1"># Here be dragons! Or, rather, MOP is used here!</span>
        }
    }
    <span class="tok-c1"># A-a-and a ready object of a type our parser has no clue about is returned.</span>
    <span class="tok-c1"># Yes, it is kind of neat. :)</span>
    <span class="tok-nv">$type</span>.<span class="tok-nb">bless</span>(|<span class="tok-n">Map</span>.<span class="tok-nb">new</span>(<span class="tok-nv">@params</span>));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，更简单的类型更简单，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-k">method</span> <span class="tok-n">parse</span>(<span class="tok-nb">Buf</span> <span class="tok-nv">$input</span> <span class="tok-k">is</span> <span class="tok-k">rw</span>, <span class="tok-nv">$enum-type</span> <span class="tok-k">where</span> <span class="tok-nv">$enum-type</span>.<span class="tok-nb">HOW</span> ~~ <span class="tok-n">Metamodel::EnumHOW</span>, :<span class="tok-nv">$debug</span>, :<span class="tok-nv">$mode</span>) {
    <span class="tok-nb">say</span> <span class="tok-s">&quot;Parsing `$input[0]` out of $input.perl()&quot;</span> <span class="tok-k">if</span> <span class="tok-nv">$debug</span>;
    <span class="tok-nv">$enum-type</span>(<span class="tok-nv">$input</span>[<span class="tok-mi">0</span>]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，必须保持规则，以表明错误，并做各种“无聊”的事情，而不是“必要”的事情。虽然 Perl 6 允许我们在这个区域使用一些不错的技巧，但在圣诞节前看它并不是太感兴趣。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_oclock_supply_oclock">37.5. What o’clock? Supply o’clock!</h3>
<div class="paragraph">
<p>如果你已经厌倦了所有这些与 <code>ASN.1</code> 相关的东西，我有一个好消息：它已经快结束了。 \O/</p>
</div>
<div class="paragraph">
<p>虽然所有这些“类型是我的一等公民而我很酷”技巧很有趣，但还有一个技巧可以展示，虽然是相关的，但却有点完全不同。</p>
</div>
<div class="paragraph">
<p><code>ASN.1</code> 解析器应该是增量的。更重要的是，它必须是非常明确的，因为人们可以使用未知长度的值。可以做些什么来快速使我们的解析器增量？我们快点做吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">ASN::Parser::Async</span> {
    <span class="tok-k">has</span> <span class="tok-n">Supplier::Preserving</span> <span class="tok-nv">$!out</span> = <span class="tok-n">Supplier::Preserving</span>.<span class="tok-nb">new</span>;
    <span class="tok-k">has</span> <span class="tok-n">Supply</span> <span class="tok-nv">$!values</span> = <span class="tok-nv">$!out</span>.<span class="tok-n">Supply</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Buf</span> <span class="tok-nv">$!buffer</span> = <span class="tok-nb">Buf</span>.<span class="tok-nb">new</span>;
    <span class="tok-k">has</span> <span class="tok-n">ASN::Parser</span> <span class="tok-nv">$!parser</span> = <span class="tok-n">ASN::Parser</span>.<span class="tok-nb">new</span>(<span class="tok-n">type</span> =&gt; <span class="tok-nv">$!type</span>);
    <span class="tok-k">has</span> <span class="tok-nv">$.type</span>;

    <span class="tok-k">method</span> <span class="tok-nb">values</span>(--&gt; <span class="tok-n">Supply</span>) {
        <span class="tok-nv">$!values</span>;
    }

    <span class="tok-k">method</span> <span class="tok-n">process</span>(<span class="tok-nb">Buf</span> <span class="tok-nv">$chunk</span>) {
        <span class="tok-nv">$!buffer</span>.<span class="tok-n">append:</span> <span class="tok-nv">$chunk</span>;
        <span class="tok-k">loop</span> {
            <span class="tok-c1"># Minimal message length</span>
            <span class="tok-k">last</span> <span class="tok-k">if</span> <span class="tok-nv">$!buffer</span>.<span class="tok-nb">elems</span> &lt; <span class="tok-mi">2</span>;
            <span class="tok-c1"># Message is incomplete, good luck another time</span>
            <span class="tok-k">last</span> <span class="tok-k">unless</span> <span class="tok-nv">$!parser</span>.<span class="tok-n">is-complete</span>(<span class="tok-nv">$!buffer</span>);
            <span class="tok-c1"># Cut off tag, we know what it is already in this specific case</span>
            <span class="tok-nv">$!parser</span>.<span class="tok-n">get-tag</span>(<span class="tok-nv">$!buffer</span>);
            <span class="tok-k">my</span> <span class="tok-nv">$length</span> = <span class="tok-nv">$!parser</span>.<span class="tok-n">get-length</span>(<span class="tok-nv">$!buffer</span>);
            <span class="tok-c1"># Tag and length are already cut down here, take only value</span>
            <span class="tok-k">my</span> <span class="tok-nv">$item-octets</span> = <span class="tok-nv">$!buffer</span>.<span class="tok-n">subbuf</span>(<span class="tok-mi">0</span>, <span class="tok-nv">$length</span>);
            <span class="tok-nv">$!out</span>.<span class="tok-n">emit:</span> <span class="tok-nv">$!parser</span>.<span class="tok-n">parse</span>(<span class="tok-nv">$item-octets</span>, :!<span class="tok-n">to-chop</span>); <span class="tok-c1"># `!to-chop`, because &quot;prefix&quot; is already cut</span>
            <span class="tok-nv">$!buffer</span> .= <span class="tok-n">subbuf</span>(<span class="tok-nv">$length</span>);
        }
    }

    <span class="tok-k">method</span> <span class="tok-nb">close</span>() {
        <span class="tok-nv">$!out</span>.<span class="tok-n">done</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以像这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$parser</span> = <span class="tok-n">ASN::Parser::Async</span>.<span class="tok-nb">new</span>(<span class="tok-n">type</span> =&gt; <span class="tok-n">Rocket</span>);

<span class="tok-nv">$parser</span>.<span class="tok-nb">values</span>.<span class="tok-n">tap</span>({ <span class="tok-nb">say</span> <span class="tok-s">&quot;I get a nice thing!&quot;</span>; });

<span class="tok-n">react</span> {
    <span class="tok-n">whenever</span> <span class="tok-nv">$socket</span>.<span class="tok-n">data-arrived</span> -&gt; <span class="tok-nv">$chunk</span> {
        <span class="tok-nv">$parser</span>.<span class="tok-n">process</span>(<span class="tok-nv">$chunk</span>);
        <span class="tok-k">LAST</span> { <span class="tok-nv">$parser</span>.<span class="tok-nb">close</span>; }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是所有必须添加的，以使这种 <code>Parser</code> 增量为这个最小的情况。</p>
</div>
<div class="paragraph">
<p>当然，正如你可以猜到的那样，我正在写的东西有点过于具体，不仅仅是我的想象力，不仅是精灵，而是一群完整的冒险者（他们也可以处理一些二进制的东西！）。该实现已在 <a href="https://github.com/Altai-man/ASN-BER">ASN::BER 仓库</a>中提供。虽然它可能是一个非常早期的 alpha 版本，有许多东西甚至还没有计划好，并且有很长的篇幅可以用来改善这个模块的整体状态，它已经对我有用了解我的工作前面提到的半秘密。仓库肯定会打开建议，错误报告（甚至可能是 hug 报告），因为还有大量工作要做，但这是另一个故事了。</p>
</div>
<div class="paragraph">
<p>祝您度过愉快的一天，并确保在圣诞假期休息好！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_检查你的列表俩次">38. 第十六天 - 检查你的列表俩次</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_从命令行了解_perl_6">38.1. 从命令行了解 Perl 6</h3>
<div class="paragraph">
<p>这是 Sniffles the Elf 的大好机会！在丝带矿山经过多年的苦差事后，他们终于被提升到了清单管理部门。作为一名闪亮的新助理尼斯名单审核员，Sniffles 正在走向重要时刻。</p>
</div>
<div class="paragraph">
<p>在 Sniffles 到达的第一天，他们的新老板格伦布尔先生正等着他。“好人清单管理很麻烦，当有人在服务器上洒了牛奶和饼干时，我们的数据被意外删除了。我们一直在忙着检查列表，我们忘了检查备份！现在我们必须从头开始重建一切！裁员后，我们有点人手不足，所以由你来挽救这一天。“</p>
</div>
<div class="paragraph">
<p>Sniffles，特别勤劳，津津乐道于这个问题。经过一些研究，他们意识到他们需要的所有数据都可用，他们只需要收集它。</p>
</div>
<div class="paragraph">
<p>他们的朋友在丝带矿山中，一位名叫 Hermie 的自称口述历史学家一直在谈论 Perl 6 有多么伟大。Sniffles 决定尝试一下。</p>
</div>
</div>
<div class="sect2">
<h3 id="_就像拔牙">38.2. 就像拔牙?</h3>
<div class="paragraph">
<p>Sniffles 首先用一种新语言抛出标准的第一个脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">v6</span>.<span class="tok-n">d</span>;

<span class="tok-nb">say</span> <span class="tok-s">&quot;Nice List restored!!!&quot;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该脚本运行并尽职尽责地打印出消息。距离圣诞节还有几天了，是时候认真对待 <a href="https://docs.perl6.org/">Perl 6文档</a>了。</p>
</div>
<div class="paragraph">
<p>稍微浏览一下 Sniffles 的 <a href="https://docs.perl6.org/language/create-cli">Perl 6 命令行界面实用程序</a> 页面。他们喜欢它描述的 <code>MAIN</code> 这个特殊子程序的外观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-s">&#39;Started initializing nice lister.&#39;</span>;
<span class="tok-k">sub</span> <span class="tok-n">MAIN</span>() { <span class="tok-nb">say</span> <span class="tok-s">&quot;Nice List restored!!!&quot;</span> }
<span class="tok-nb">say</span> <span class="tok-s">&#39;Finished initializing nice lister.&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Started initializing nice lister.
Finished initializing nice lister.
Nice List restored!!!</pre>
</div>
</div>
<div class="paragraph">
<p>好吧，至少那是他们的启动代码。Sniffles 抛弃了初始化消息，它们只是噪音。但他们确信这个 <code>MAIN</code> 函数必须有更多的技巧才能让 Hermie 如此兴奋。</p>
</div>
<div class="paragraph">
<p>回到文档&#8230;&#8203;检查了<a href="https://learnxinyminutes.com/docs/perl6/">Y分钟学会X语言的 Perl 6 页面</a>。<code>MAIN</code> 接近尾声的额外部分是金矿！Sniffles 对这个念头打了个寒颤。</p>
</div>
<div class="paragraph">
<p>“好的，所以如果我们提供 <code>MAIN子</code> 程序签名，Perl 6 会为我们处理命令行解析。更好的是，它会自动生成帮助内容，“他们对自己嘟囔道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    :<span class="tok-nv">$list-of-all-kids</span>,
    :<span class="tok-nv">$naughty-list</span>
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">nice-list</span>
<span class="tok-n">Usage:</span>
  <span class="tok-n">nicelist</span> [--<span class="tok-n">list-of-all-kids</span>=<span class="tok-s">&lt;Any&gt;</span>] [--<span class="tok-n">naughty-list</span>=<span class="tok-s">&lt;Any&gt;</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行脚本得到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Stub</span> <span class="tok-n">code</span> <span class="tok-n">executed</span>
  <span class="tok-n">in</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> <span class="tok-n">at</span> <span class="tok-n">foo</span> <span class="tok-n">line</span> <span class="tok-mi">1</span>
  <span class="tok-n">in</span> <span class="tok-n">block</span> <span class="tok-s">&lt;unit&gt;</span> <span class="tok-n">at</span> <span class="tok-n">foo</span> <span class="tok-n">line</span> <span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>真棒。</p>
</div>
<div class="paragraph">
<p>但是开关名称有点长。由于 TheNorthPole.io 是一个专门的商店，Sniffles 认为他们可能不得不输入一堆。呸。如果您可以添加一些解释性文字，更短的名称将没有问题。Perl 6 支持使用 POD6 标记进行文字编程，因此可以轻松添加注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#| Rebuild the Nice List</span>
<span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    :<span class="tok-nv">$all</span>,    <span class="tok-c1">#= path to file containing the list of all children</span>
    :<span class="tok-nv">$naughty</span> <span class="tok-c1">#= path to file containing the Naughty List</span>
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Usage:</span>
  <span class="tok-n">nicelist</span> [--<span class="tok-n">all</span>=<span class="tok-s">&lt;Any&gt;</span>] [--<span class="tok-n">naughty</span>=<span class="tok-s">&lt;Any&gt;</span>] -- <span class="tok-n">Rebuild</span> <span class="tok-n">the</span> <span class="tok-n">Nice</span> <span class="tok-nb">List</span>

    --<span class="tok-n">all</span>=<span class="tok-s">&lt;Any&gt;</span>        <span class="tok-n">path</span> <span class="tok-nb">to</span> <span class="tok-n">file</span> <span class="tok-n">containing</span> <span class="tok-n">the</span> <span class="tok-n">list</span> <span class="tok-k">of</span> <span class="tok-nb">all</span> <span class="tok-n">children</span>
    --<span class="tok-n">naughty</span>=<span class="tok-s">&lt;Any&gt;</span>    <span class="tok-n">path</span> <span class="tok-nb">to</span> <span class="tok-n">file</span> <span class="tok-n">containing</span> <span class="tok-n">the</span> <span class="tok-n">Naughty</span> <span class="tok-nb">List</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sniffles 印象深刻，但他们知道参数验证是编写 CLI 的另一部分，可能会变得乏味。“Perl 6 最近为我做了什么？”他们想知道。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一种强大的沉默的类型">38.3. 一种强大的，沉默的类型</h3>
<div class="paragraph">
<p>Perl6 有一个渐进式<a href="https://docs.perl6.org/language/typesystem">类型系统</a>，包括编译和运行时类型检查。渐进类型允许 Sniffles 到目前为止忽略类型检查。他们添加了一些类型，看看发生了什么。</p>
</div>
<div class="paragraph">
<p>Sniffles 使用<a href="https://docs.perl6.org/type/Signature#Constraining_argument_definiteness">类型 smiley</a>定义了 Str 的子集，该类型使用 <a href="https://docs.perl6.org/type/Whatever">whatevercode</a> 来验证给定路径上是否存在文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">subset</span> <span class="tok-n">FilePath</span> <span class="tok-k">of</span> <span class="tok-nb">Str:D</span> <span class="tok-k">where</span> *.<span class="tok-nb">IO</span>.<span class="tok-n">f</span>;

<span class="tok-c1">#| Rebuild the Nice List</span>
<span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$all</span>,    <span class="tok-c1">#= path to file containing the list of all children</span>
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$naughty</span> <span class="tok-c1">#= path to file containing the Naughty List</span>
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们运行这个脚本:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$nice-list  --naughty=naughty.kids --all=notAFile.bleh
Usage:
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List</pre>
</div>
</div>
<div class="paragraph">
<p>Sniffles 在没有争论和其他一些无效方式的情况下再次运行脚本。每次捕获无效输入并自动显示使用消息。 “非常好，”Sniffles 想道，“事实上，错误报告仍然很糟糕。如果你抛出一个参数就好像传入一个丢失的文件一样，你会得到相同的结果。”</p>
</div>
</div>
<div class="sect2">
<h3 id="_精灵类型不匹配_弥补改进的错误处理">38.4. 精灵类型不匹配 - 弥补改进的错误处理</h3>
<div class="paragraph">
<p>"Ugh! How do I get around <strong>this</strong> problem?" Sniffles shuffled around the docs some more.  <a href="https://docs.perl6.org/syntax/multi">Multiple Dispatch</a> and <a href="https://docs.perl6.org/type/Signature#index-entry-slurpy_argument">slurpy parameters</a>.  They added another subset and a couple of new definitions of MAIN:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">subset</span> <span class="tok-n">FileNotFound</span> <span class="tok-k">of</span> <span class="tok-nb">Str:D</span> <span class="tok-k">where</span> !*.<span class="tok-nb">IO</span>.<span class="tok-n">f</span>();

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$all</span>,    <span class="tok-c1">#= path to file containing the list of all children</span>
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$naughty</span> <span class="tok-c1">#= path to file containing the Naughty List</span>
) { ... }

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-n">FileNotFound</span> :<span class="tok-nv">$all</span>,
    *<span class="tok-nv">%otherStuff</span>
) {
    <span class="tok-k">die</span> <span class="tok-s">&quot;List of all children file does not exist&quot;</span>;
}

<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-n">FileNotFound</span> :<span class="tok-nv">$naughty</span>,
    *<span class="tok-nv">%otherStuff</span>
) {
    <span class="tok-k">die</span> <span class="tok-s">&quot;Naughty List file does not exist&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们得到了:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Usage:
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List
  nice-list [--all=&lt;FileNotFound&gt;] [--naughty=&lt;FilePath&gt;]
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FileNotFound&gt;]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List</pre>
</div>
</div>
<div class="paragraph">
<p>哪个工作完美&#8230;&#8203;除了现在他们在使用中有错误生成条目！双翘。Sniffles返回到CLI界面上的文章。将正确的特征添加到MAIN潜艇将使它们从自动生成的使用中消失：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-n">FileNotFound</span> :<span class="tok-nv">$all</span>,
    *<span class="tok-nv">%otherStuff</span>
) <span class="tok-k">is</span> <span class="tok-n">hidden-from-USAGE</span> {
    <span class="tok-k">die</span> <span class="tok-s">&quot;List of all children file does not exist&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一团糟不见了！</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们不会去直到我们得到一些">38.5. 我们不会去，直到我们得到一些！</h3>
<div class="paragraph">
<p>Grumble 先生走了过来，他停下来看着 Sniffles 的屏幕。“那里有趣的工作，Sniffles。我们需要那个脚本，我们昨天需要它。哦，我们需要它能够审核现有的 Nice List 并重建一个。我们也需要这个。看到你。“在Sniffles眨眼之前他消失了。</p>
</div>
<div class="paragraph">
<p>Sniffles 认为，做一个爬行的功能比被迫吃无花果布丁更好。他们添加了这些命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#| Rebuild the Nice List</span>
<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-s">&#39;build&#39;</span>,
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$all</span>,    <span class="tok-c1">#= path to file containing the list of all children</span>
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$naughty</span> <span class="tok-c1">#= path to file containing the Naughty List</span>
) { ... }

<span class="tok-c1">#| Compare all the lists for correctness</span>
<span class="tok-k">multi</span> <span class="tok-k">sub</span> <span class="tok-n">MAIN</span> (
    <span class="tok-s">&#39;audit&#39;</span>,
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$all</span>,     <span class="tok-c1">#= path to file containing the list of all children</span>
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$naughty</span>, <span class="tok-c1">#= path to file containing the Naughty List</span>
    <span class="tok-n">FilePath</span> :<span class="tok-nv">$nice</span>,    <span class="tok-c1">#= path to file containing the Nice List</span>
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>“好极了，”他们想，“但你必须像这样运行脚本 <code>nicelist --all=foo --naughty=bar build</code>。可怕。”</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-vg">%*SUB-MAIN-OPTS</span> =
    :<span class="tok-n">named-anywhere</span>,    <span class="tok-c1"># allow named variables at any location</span>
;</code></pre>
</div>
</div>
<div class="paragraph">
<p>“它被修复了！” Sniffles 在座位上跳起来了。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Usage:
  nicelist build [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List
  nicelist audit [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] [--nice=&lt;FilePath&gt;] -- Compare all the lists for correctness</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List
--nice=&lt;FilePath&gt;       path to file containing the Nice List</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_跑步者走上了这条路">38.6. 跑步者走上了这条路。</h3>
<div class="paragraph">
<p>好的，现在 Sniffles 拥有一个完美的框架来构建一个优秀的实用程序脚本。是时候实际写出实际的东西了。Sniffles 知道他们真的打算雪橇这个项目。</p>
</div>
<div class="paragraph">
<p>很快，Snuffles发现Perl6的功能集帮助他们制作了一个功能强大，正确的脚本。他们创建了一个 Child <a href="https://docs.perl6.org/language/classtut">类</a>，在其上<a href="https://docs.perl6.org/language/mop#index-entry-syntax_WHICH-WHICH">定义了身份操作</a>，编写了一个用于加载列表数据的简洁 CSV 解析器和一个报告函数。内置的 <a href="https://docs.perl6.org/type/Set">Set 数据类型</a>提供了操作符，可以轻松查找不合适的条目，甚至更容易重建 Nice List。</p>
</div>
<div class="paragraph">
<p>一旦<a href="https://gist.github.com/daotoad/47bcbc6f1dc066fff982a72481c6bcd2">完成</a>，他们就恢复了 Nice List，并向 Grumbles 先生及其他团队发送了一封部门电子邮件，宣布他们取得了成功。当格罗布尔斯先生看到脚本有多好，它的用法和错误检查，仅此一次，他辜负了他们的期望。</p>
</div>
<div class="paragraph">
<p>为了表彰他们的辛勤工作和机智，Sniffles 被要求在圣诞老人最新工作室的开幕处剪彩。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第17天_通往幸福的编译之路">39. <a href="https://perl6advent.wordpress.com/2018/12/17/day-17-compiling-our-way-to-happiness/">第17天 - 通往幸福的编译之路</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果我们选择接受它，我们的任务就是解决`SEND + MORE = MONEY`代码中的问题。不，请等一下，让我这样说吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-n">S</span> <span class="tok-n">E</span> <span class="tok-n">N</span> <span class="tok-n">D</span>
+   <span class="tok-n">M</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">E</span>
-----------
  <span class="tok-n">M</span> <span class="tok-n">O</span> <span class="tok-n">N</span> <span class="tok-n">E</span> <span class="tok-n">Y</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它意味着相同，但是这样放置它更具<a href="https://en.wikipedia.org/wiki/Carry_(arithmetic">视觉冲击力</a>)，特别是因为我们很多人在学校这样做了。</p>
</div>
<div class="paragraph">
<p>基本规则很简单。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个字母代表0到9之间的数字。</p>
</li>
<li>
<p>字母代表*不同的*数字; 两个字母可能不共享相同的数字。</p>
</li>
<li>
<p>前导数字（在我们的拼图中，<code>S</code> 和 <code>M</code>）不能为零。如果为零他们就不会是前导数字！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>鉴于这些限制因素，上述难题有一个独特的解决方案。</p>
</div>
<div class="paragraph">
<p>我鼓励你找到解决方案。写一点代码，坚持一下！在这篇文章中，我们会这样做，但后来（关键）*不满足*于此，并最终陷入嵌套玩偶的情况，其中代码编写代码直到出现真正整洁的东西。结论将拼出最终目标-坚持不住了，我被实时地通过多个委员会获悉，正确的说法是“ *一个*终极愿景” -为了 Perl 6。</p>
</div>
<div class="paragraph">
<p>我们开工吧。</p>
</div>
<div class="sect2">
<h3 id="_marcus_junius_brute_forcethe_younger">39.1. Marcus Junius Brute Force（The Younger）</h3>
<div class="paragraph">
<p>我们当天的第一语言及其相应的解决方案是 Perl 6 本身。这里没有技巧; 我们只是像愤怒的公牛一样向问题域冲去，尝试一切。事实上，我们确保不要在这个问题上耍小聪明，只是尝试尽可能直接地表达解决方案。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">for</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$d</span> {
    <span class="tok-k">for</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$e</span> {
        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$e</span> == <span class="tok-nv">$d</span>;

        <span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$y</span> = (<span class="tok-nv">$d</span> + <span class="tok-nv">$e</span>) % <span class="tok-mi">10</span>;
        <span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$_c1</span> = (<span class="tok-nv">$d</span> + <span class="tok-nv">$e</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

        <span class="tok-k">for</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$n</span> {
            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$n</span> == <span class="tok-nv">$d</span>;
            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$n</span> == <span class="tok-nv">$e</span>;
            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$n</span> == <span class="tok-nv">$y</span>;

            <span class="tok-k">for</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$r</span> {
                <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$r</span> == <span class="tok-nv">$d</span>;
                <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$r</span> == <span class="tok-nv">$e</span>;
                <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$r</span> == <span class="tok-nv">$y</span>;
                <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$r</span> == <span class="tok-nv">$n</span>;

                <span class="tok-k">next</span> <span class="tok-k">unless</span> (<span class="tok-nv">$_c1</span> + <span class="tok-nv">$n</span> + <span class="tok-nv">$r</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$e</span>;
                <span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$_c2</span> = (<span class="tok-nv">$_c1</span> + <span class="tok-nv">$n</span> + <span class="tok-nv">$r</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

                <span class="tok-k">for</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$o</span> {
                    <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$o</span> == <span class="tok-nv">$d</span>;
                    <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$o</span> == <span class="tok-nv">$e</span>;
                    <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$o</span> == <span class="tok-nv">$y</span>;
                    <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$o</span> == <span class="tok-nv">$n</span>;
                    <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$o</span> == <span class="tok-nv">$r</span>;

                    <span class="tok-k">next</span> <span class="tok-k">unless</span> (<span class="tok-nv">$_c2</span> + <span class="tok-nv">$e</span> + <span class="tok-nv">$o</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$n</span>;
                    <span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$_c3</span> = (<span class="tok-nv">$_c2</span> + <span class="tok-nv">$e</span> + <span class="tok-nv">$o</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

                    <span class="tok-k">for</span> <span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$s</span> {
                        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$s</span> == <span class="tok-nv">$d</span>;
                        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$s</span> == <span class="tok-nv">$e</span>;
                        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$s</span> == <span class="tok-nv">$y</span>;
                        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$s</span> == <span class="tok-nv">$n</span>;
                        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$s</span> == <span class="tok-nv">$r</span>;
                        <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$s</span> == <span class="tok-nv">$o</span>;

                        <span class="tok-k">for</span> <span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span> -&gt; <span class="tok-nb">int</span> <span class="tok-nv">$m</span> {
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$d</span>;
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$e</span>;
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$y</span>;
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$n</span>;
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$r</span>;
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$o</span>;
                            <span class="tok-k">next</span> <span class="tok-k">if</span> <span class="tok-nv">$m</span> == <span class="tok-nv">$s</span>;

                            <span class="tok-k">next</span> <span class="tok-k">unless</span> (<span class="tok-nv">$_c3</span> + <span class="tok-nv">$s</span> + <span class="tok-nv">$m</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$o</span>;
                            <span class="tok-k">my</span> <span class="tok-nb">int</span> <span class="tok-nv">$_c4</span> = (<span class="tok-nv">$_c3</span> + <span class="tok-nv">$s</span> + <span class="tok-nv">$m</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

                            <span class="tok-k">next</span> <span class="tok-k">unless</span> <span class="tok-nv">$_c4</span> % <span class="tok-mi">10</span> == <span class="tok-nv">$m</span>;

                            <span class="tok-nb">say</span> <span class="tok-s">&quot;$s$e$n$d + $m$o$r$e == $m$o$n$e$y&quot;</span>;
                        }
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你又看到了，它不*漂亮*，但它起作用了。这是你母亲警告你的那种缩进程度。不过，如果你问我，我更讨厌缩进。对于我们需要扫描其搜索空间的每个变量，我们都有一个。（只有有`Y`我们才能走捷径。）</p>
</div>
<div class="paragraph">
<p>虽然这是今天猛烈冲击的迂回而已，但MJD曾<a href="https://blog.plover.com/prog/haskell/monad-search.html">在博客上发表过关于此事的博客</a>，然后我<a href="http://strangelyconsistent.org/blog/send-more-money-in-perl6">也在</a><a href="https://blog.plover.com/prog/haskell/monad-search.html">博客上写了这篇文章</a>。从某种意义上说，这些博客文章非常关注“删除缩进”。今天的帖子是我三年后的想法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我让路径遍历少了以及所有其他路径">39.2. 我让路径遍历少了（以及所有其他路径）</h3>
<div class="paragraph">
<p>我们的第二语言仍然主要是 Perl 6，但有一个简洁的假象扩展名`amb`，但是拼写为（令人回味）<code>&#8592;</code>。它摆脱了所有显式`for`循环和缩进层级。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$d</span> &lt;- <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-k">my</span> <span class="tok-nv">$e</span> &lt;- <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-n">guard</span> <span class="tok-nv">$e</span> != <span class="tok-nb">any</span>(<span class="tok-nv">$d</span>);
<span class="tok-k">my</span> <span class="tok-nv">$y</span> = (<span class="tok-nv">$d</span> + <span class="tok-nv">$e</span>) % <span class="tok-mi">10</span>;
<span class="tok-k">my</span> <span class="tok-nv">$_c1</span> = (<span class="tok-nv">$d</span> + <span class="tok-nv">$e</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

<span class="tok-k">my</span> <span class="tok-nv">$n</span> &lt;- <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-n">guard</span> <span class="tok-nv">$n</span> != <span class="tok-nb">any</span>(<span class="tok-nv">$d</span>, <span class="tok-nv">$e</span>, <span class="tok-nv">$y</span>);
<span class="tok-k">my</span> <span class="tok-nv">$r</span> &lt;- <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-n">guard</span> <span class="tok-nv">$r</span> != <span class="tok-nb">any</span>(<span class="tok-nv">$d</span>, <span class="tok-nv">$e</span>, <span class="tok-nv">$y</span>, <span class="tok-nv">$n</span>);
<span class="tok-n">guard</span> (<span class="tok-nv">$_c1</span> + <span class="tok-nv">$n</span> + <span class="tok-nv">$r</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$e</span>;
<span class="tok-k">my</span> <span class="tok-nv">$_c2</span> = (<span class="tok-nv">$_c1</span> + <span class="tok-nv">$n</span> + <span class="tok-nv">$r</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

<span class="tok-k">my</span> <span class="tok-nv">$o</span> &lt;- <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-n">guard</span> <span class="tok-nv">$o</span> != <span class="tok-nb">any</span>(<span class="tok-nv">$d</span>, <span class="tok-nv">$e</span>, <span class="tok-nv">$y</span>, <span class="tok-nv">$n</span>, <span class="tok-nv">$r</span>);
<span class="tok-n">guard</span> (<span class="tok-nv">$_c2</span> + <span class="tok-nv">$e</span> + <span class="tok-nv">$o</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$n</span>;
<span class="tok-k">my</span> <span class="tok-nv">$_c3</span> = (<span class="tok-nv">$_c2</span> + <span class="tok-nv">$e</span> + <span class="tok-nv">$o</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

<span class="tok-k">my</span> <span class="tok-nv">$s</span> &lt;- <span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-n">guard</span> <span class="tok-nv">$s</span> != <span class="tok-nb">any</span>(<span class="tok-nv">$d</span>, <span class="tok-nv">$e</span>, <span class="tok-nv">$y</span>, <span class="tok-nv">$n</span>, <span class="tok-nv">$r</span>, <span class="tok-nv">$o</span>);
<span class="tok-k">my</span> <span class="tok-nv">$m</span> &lt;- <span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>;
<span class="tok-n">guard</span> <span class="tok-nv">$m</span> != <span class="tok-nb">any</span>(<span class="tok-nv">$d</span>, <span class="tok-nv">$e</span>, <span class="tok-nv">$y</span>, <span class="tok-nv">$n</span>, <span class="tok-nv">$r</span>, <span class="tok-nv">$o</span>, <span class="tok-nv">$s</span>);
<span class="tok-n">guard</span> (<span class="tok-nv">$_c3</span> + <span class="tok-nv">$s</span> + <span class="tok-nv">$m</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$o</span>;
<span class="tok-k">my</span> <span class="tok-nv">$_c4</span> = (<span class="tok-nv">$_c3</span> + <span class="tok-nv">$s</span> + <span class="tok-nv">$m</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>;

<span class="tok-n">guard</span> <span class="tok-nv">$_c4</span> % <span class="tok-mi">10</span> == <span class="tok-nv">$m</span>;

<span class="tok-nb">say</span> <span class="tok-s">&quot;$s$e$n$d + $m$o$r$e == $m$o$n$e$y&quot;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种解决方案更短，更紧凑，并且感觉不那么“聒噪”，并且只是通过摆脱`for`循环来加重。（我怀疑这与人们有时提到的那些命令性的声明谱有关。我们对循环不是那么感兴趣，只看到它完成了。）</p>
</div>
<div class="paragraph">
<p>我知道它不会完全弥补Perl 6没有`amb`运算符并且 `guard`在核心中（甚至在模块空间中）实现的事实，但是这里有一个简短的脚本将上述程序转换为今天的第一个版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$indent</span> = <span class="tok-mi">0</span>;
<span class="tok-k">constant</span> <span class="tok-n">SPACE</span> = <span class="tok-nb">chr</span>(<span class="tok-mh">0x20</span>);
<span class="tok-k">sub</span> <span class="tok-n">indent</span> { <span class="tok-n">SPACE</span> <span class="tok-o">x</span> <span class="tok-mi">4</span> * <span class="tok-nv">$indent</span> }

<span class="tok-k">for</span> <span class="tok-nb">lines</span>() {
    <span class="tok-k">when</span> /^ <span class="tok-k">my</span> \<span class="tok-n">h</span>+ (<span class="tok-s">&#39;$&#39;</span> \<span class="tok-n">w</span>) \<span class="tok-n">h</span>* <span class="tok-s">&#39;&lt;-&#39;</span> \<span class="tok-n">h</span>* (\<span class="tok-n">d</span>+ \<span class="tok-n">h</span>* <span class="tok-s">&#39;..&#39;</span> \<span class="tok-n">h</span>* \<span class="tok-n">d</span>+) <span class="tok-s">&#39;;&#39;</span> <span class="tok-vg">$/</span> {
        <span class="tok-nb">say</span> <span class="tok-n">indent</span>, <span class="tok-s">&quot;for $1 -&gt; int $0 \{&quot;</span>;
        <span class="tok-nv">$indent</span>++;
    }

    <span class="tok-k">when</span> /^ <span class="tok-n">guard</span> \<span class="tok-n">h</span>+ (<span class="tok-s">&#39;$&#39;</span> \<span class="tok-n">w</span>) \<span class="tok-n">h</span>* <span class="tok-s">&#39;!=&#39;</span> \<span class="tok-n">h</span>* <span class="tok-s">&#39;any(&#39;</span> (<span class="tok-s">&#39;$&#39;</span> \<span class="tok-n">w</span>)+ % [\<span class="tok-n">h</span>* <span class="tok-s">&#39;,&#39;</span> \<span class="tok-n">h</span>*] <span class="tok-s">&#39;)&#39;</span> \<span class="tok-n">h</span>* <span class="tok-s">&#39;;&#39;</span> <span class="tok-vg">$/</span> {
        <span class="tok-nb">say</span> <span class="tok-n">indent</span>, <span class="tok-s">&quot;next if $0 == $_;&quot;</span>
            <span class="tok-k">for</span> <span class="tok-nv">$1</span>;
        <span class="tok-nb">say</span> <span class="tok-s">&quot;&quot;</span>;
    }

    <span class="tok-k">when</span> /^ <span class="tok-n">guard</span> \<span class="tok-n">h</span>+ ([<span class="tok-s">&lt;!before &#39;==&#39;&gt;</span> .]+ <span class="tok-s">&#39;==&#39;</span> <span class="tok-s">&lt;-[;]&gt;</span>+) <span class="tok-s">&#39;;&#39;</span> <span class="tok-vg">$/</span> {
        <span class="tok-nb">say</span> <span class="tok-n">indent</span>, <span class="tok-s">&quot;next unless $0;&quot;</span>;
    }

    <span class="tok-k">when</span> /^ <span class="tok-k">my</span> \<span class="tok-n">h</span>+ (<span class="tok-s">&#39;$&#39;</span> \<span class="tok-n">w</span>+) \<span class="tok-n">h</span>* <span class="tok-s">&#39;=&#39;</span> \<span class="tok-n">h</span>* (<span class="tok-s">&lt;-[;]&gt;</span>+) <span class="tok-s">&#39;;&#39;</span> <span class="tok-vg">$/</span> {
        <span class="tok-nb">say</span> <span class="tok-n">indent</span>, <span class="tok-s">&quot;my int $0 = $1;&quot;</span>;
    }

    <span class="tok-k">when</span> /^ \<span class="tok-n">h</span>* <span class="tok-vg">$/</span> {
        <span class="tok-nb">say</span> <span class="tok-s">&quot;&quot;</span>;
    }

    <span class="tok-k">when</span> /^ <span class="tok-nb">say</span> \<span class="tok-n">h</span>+ (<span class="tok-s">&lt;-[;]&gt;</span>+) <span class="tok-s">&#39;;&#39;</span> <span class="tok-vg">$/</span> {
        <span class="tok-nb">say</span> <span class="tok-n">indent</span>, <span class="tok-nv">$_</span>;
    }

    <span class="tok-k">default</span> {
        <span class="tok-k">die</span> <span class="tok-s">&quot;Couldn&#39;t match $_&quot;</span>;
    }
}

<span class="tok-k">while</span> <span class="tok-nv">$indent--</span> {
    <span class="tok-nb">say</span> <span class="tok-n">indent</span>, <span class="tok-s">&quot;\}&quot;</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但我们也不会就此满意。哦，不。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在方程式中思考">39.3. 在方程式中思考</h3>
<div class="paragraph">
<p>第三种语言将我们进一步引入声明，摆脱了所有仅仅表明变量应该是不同项的 `guard ` 从句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">ALL_DISTINCT</span>

<span class="tok-nv">$d</span> <span class="tok-n">in</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>
<span class="tok-nv">$e</span> <span class="tok-n">in</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>
<span class="tok-nv">$n</span> <span class="tok-n">in</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>
<span class="tok-nv">$r</span> <span class="tok-n">in</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>
<span class="tok-nv">$o</span> <span class="tok-n">in</span> <span class="tok-mi">0</span><span class="tok-o">..</span><span class="tok-mi">9</span>
<span class="tok-nv">$s</span> <span class="tok-n">in</span> <span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>
<span class="tok-nv">$m</span> <span class="tok-n">in</span> <span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">9</span>

<span class="tok-nv">$y</span> = (<span class="tok-nv">$d</span> + <span class="tok-nv">$e</span>) % <span class="tok-mi">10</span>
<span class="tok-nv">$_c1</span> = (<span class="tok-nv">$d</span> + <span class="tok-nv">$e</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>

(<span class="tok-nv">$_c1</span> + <span class="tok-nv">$n</span> + <span class="tok-nv">$r</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$e</span>
<span class="tok-nv">$_c2</span> = (<span class="tok-nv">$_c1</span> + <span class="tok-nv">$n</span> + <span class="tok-nv">$r</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>

(<span class="tok-nv">$_c2</span> + <span class="tok-nv">$e</span> + <span class="tok-nv">$o</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$n</span>
<span class="tok-nv">$_c3</span> = (<span class="tok-nv">$_c2</span> + <span class="tok-nv">$e</span> + <span class="tok-nv">$o</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>

(<span class="tok-nv">$_c3</span> + <span class="tok-nv">$s</span> + <span class="tok-nv">$m</span>) % <span class="tok-mi">10</span> == <span class="tok-nv">$o</span>
<span class="tok-nv">$_c4</span> = (<span class="tok-nv">$_c3</span> + <span class="tok-nv">$s</span> + <span class="tok-nv">$m</span>) <span class="tok-o">div</span> <span class="tok-mi">10</span>

<span class="tok-nv">$_c4</span> % <span class="tok-mi">10</span> == <span class="tok-nv">$m</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们现在完全处于<a href="https://en.wikipedia.org/wiki/Constraint_programming">约束编程</a>领域，如果不提这一点，是不诚实的。我们已经抛弃了Perl 6的必要方面，我们只关注描述我们正在解决的问题的约束。</p>
</div>
<div class="paragraph">
<p>上述程序最重要的方面是我们赋值时。即使这主要是一种优化，在我们知道我们可以直接计算变量的值而不是搜索变量的情况下。</p>
</div>
<div class="paragraph">
<p>即使在这种情况下，我们也可以转换回以前的解决方案。不过，我现在会省略这样一个翻译。</p>
</div>
<div class="paragraph">
<p>我将在结论中回到这种语言，因为它在很多方面证明了，这是最有趣的一种。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第四语言">39.4. 第四语言</h3>
<div class="paragraph">
<p>到目前为止，我们还有哪些必要的复杂性可以剥离？具体而言，这些方程式来自前一解决方案中指定的位置？我们怎样才能更简洁地表达它们？</p>
</div>
<div class="paragraph">
<p>我想你会喜欢这个。第四种语言只是表达了这样的搜索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-n">S</span> <span class="tok-n">E</span> <span class="tok-n">N</span> <span class="tok-n">D</span>
+   <span class="tok-n">M</span> <span class="tok-n">O</span> <span class="tok-n">R</span> <span class="tok-n">E</span>
-----------
  <span class="tok-n">M</span> <span class="tok-n">O</span> <span class="tok-n">N</span> <span class="tok-n">E</span> <span class="tok-n">Y</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>等一下，为什么又来？是的，你没有看错。这个问题最具声明性的解决方案只是问题规范本身的ASCII布局！当问题域和答案域如此相遇时，难道你不喜欢它吗？</p>
</div>
<div class="paragraph">
<p>从这个布局上，我们可以再次转换回约束编程解决方案，从手动算法中编写方程式，以便我们在学校学习。</p>
</div>
<div class="paragraph">
<p>因此，我们不仅不需要编写那些加重`for`循环的东西; 如果我们足够顽强，我们可以从问题到解决方案一直生成代码。我们只需找到合适的语言就可以了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_5">39.5. 结论</h3>
<div class="paragraph">
<p>我对007的探索使我思考了上述事情：翻译程序。Perl 6 已经很好地公开了编译过程的一部分：解析。我们可以在用户空间和Perl 6工具链中使用 grammars。</p>
</div>
<div class="paragraph">
<p>我开始相信我们需要对编译管道的所有方面都这样做。在这里，让我把它作为口号或声明：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>当我们带来操作文本/数据的所有功能也可以向内转到编译过程本身时，Perl 6将充分发挥其潜力。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我在不同语言之间编写（或想象）的那些翻译器，他们在压力下工作，但他们也很脆弱，有点浪费。问题在很大程度上是我们一直下降到文本。我们应该在AST级别执行此操作，其中所有结构都可用。</p>
</div>
<div class="paragraph">
<p>这种思想转变所带来的收益不容小觑。这是我们在Perl 6中找到Lispy启蒙的地方。</p>
</div>
<div class="paragraph">
<p>例如，带方程的第三种语言不必盲目地翻译成代码。它可以被*优化*，方程式篡改成更窄和更精确的方程式。从<a href="https://en.wikipedia.org/wiki/Verbal_arithmetic#Solving_cryptarithms">维基百科</a>可以看出，有可能做到如此优秀，以至于一旦程序运行就没有剩下的搜索。</p>
</div>
<div class="paragraph">
<p>我的梦想：能够进行上述转换，而不是在文本文件之间，而是在Perl 6中的*俚语*之间。并且能够进行优化步骤。一切都没有离开语言的舒适。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_一棵_avg_格式的圣诞树">40. 第十八天 - 一棵 AVG 格式的圣诞树</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞树是一种传统的象征，可以追溯到欧洲四百多年前，所以对于一篇关于创造圣诞树图像的出现文章来说，这可能更好。</p>
</div>
<div class="paragraph">
<p>树的典型，简化的表示是几个尺寸逐渐减小的三角形，彼此叠加并且具有小的重叠，因此使用计算机程序很容易创建。</p>
</div>
<div class="paragraph">
<p>在这里，我将使用可缩放矢量图形（SVG）绘制图像，如上所述，它似乎非常适合任务。</p>
</div>
<div class="sect2">
<h3 id="_关于svg并创建它">40.1. 关于SVG并创建它</h3>
<div class="paragraph">
<p>SVG是一种XML文档格式，它将图像描述为点之间的一组矢量，它具有线条和形状的基元，并提供所描述对象的样式。</p>
</div>
<div class="paragraph">
<p>也许最简单的SVG文档是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;svg</span> <span class="tok-na">xmlns=</span><span class="tok-s">&quot;http://www.w3.org/2000/svg&quot;</span>
     <span class="tok-na">xmlns:svg=</span><span class="tok-s">&quot;http://www.w3.org/2000/svg&quot;</span>
     <span class="tok-na">xmlns:xlink=</span><span class="tok-s">&quot;http://www.w3.org/1999/xlink&quot;</span>
     <span class="tok-na">width=</span><span class="tok-s">&quot;100&quot;</span>
     <span class="tok-na">height=</span><span class="tok-s">&quot;100&quot;</span><span class="tok-nt">&gt;</span>
	<span class="tok-nt">&lt;g&gt;</span>
		<span class="tok-nt">&lt;rect</span> <span class="tok-na">x=</span><span class="tok-s">&quot;5&quot;</span> <span class="tok-na">y=</span><span class="tok-s">&quot;5&quot;</span> <span class="tok-na">width=</span><span class="tok-s">&quot;90&quot;</span> <span class="tok-na">height=</span><span class="tok-s">&quot;90&quot;</span> <span class="tok-na">stroke=</span><span class="tok-s">&quot;black&quot;</span> <span class="tok-na">fill=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-nt">/&gt;</span>
	<span class="tok-nt">&lt;/g&gt;</span>
<span class="tok-nt">&lt;/svg&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这描述了侧面90的绿色填充正方形（单元基本上是抽象的并且相对于显示器的尺寸，因为图像的可缩放特性意味着它们可能不等同于例如像素。）</p>
</div>
<div class="paragraph">
<p>现在我们可以在程序中使用一些变量插值打印出XML，但是对于比上面的例子更复杂的事情，这可能会非常繁琐且容易出错。幸运的是Perl 6有一个方便的<a href="https://github.com/moritz/svg">SVG</a>模块，它负责从描述它的数据结构中实际创建格式良好的XML文档。因此，我们的示例矩形可以使用以下内容创建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG</span>;

<span class="tok-nb">say</span> <span class="tok-n">SVG</span>.<span class="tok-n">serialize</span>(
    <span class="tok-n">svg</span> =&gt; [
        <span class="tok-n">width</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">height</span> =&gt; <span class="tok-mi">100</span>,
        :<span class="tok-n">g</span>[:<span class="tok-n">rect</span>[:<span class="tok-o">x</span><span class="tok-s">&lt;5&gt;, :y&lt;5&gt;</span>, :<span class="tok-n">width</span><span class="tok-s">&lt;90&gt;</span>, :<span class="tok-n">height</span><span class="tok-s">&lt;90&gt;</span>, :<span class="tok-n">stroke</span><span class="tok-s">&lt;black&gt;</span>, :<span class="tok-n">file</span><span class="tok-s">&lt;green&gt;</span>]],
    ],
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>本质上，参数`serialize`是一组嵌套的<a href="https://docs.perl6.org/type/Pair">Pairs</a>：其中value是标量类型，键和值用于形成XML属性，其中值是List of Pairs，这将创建一个以键命名的XML元素，列表中的每个对都被解释为如上所述，从而允许以简单的声明方式构建复杂文档。</p>
</div>
<div class="paragraph">
<p>所以我们可以通过构造适当的数据结构来生成我们的示例圣诞树，但是因为我们的图像中可能至少有四个对象（三个三角形和一个用于树干的矩形）及其相关属性，这可能会非常不合适如果我们想改变某些东西，很难改变。</p>
</div>
<div class="paragraph">
<p>所以…</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们抽象吧">40.2. 我们抽象吧！</h3>
<div class="paragraph">
<p>为了使我们的SVG生成更加灵活并为未来的代码重用开辟了机会，创建一组代表我们可能想要使用的SVG原语的类并抽象出将要生成的数据结构可能是有意义的。序列化为XML。</p>
</div>
<div class="paragraph">
<p>所以让我们从可以生成原始矩形示例的东西开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">use</span> <span class="tok-nn">SVG</span><span class="tok-p">;</span>

<span class="tok-n">class</span> <span class="tok-nn">SVG::</span><span class="tok-n">Drawing</span> <span class="tok-p">{</span>
    <span class="tok-n">role</span> <span class="tok-n">Element</span> <span class="tok-p">{</span>
        <span class="tok-n">method</span> <span class="tok-n">serialize</span><span class="tok-p">()</span> <span class="tok-p">{</span>
            <span class="tok-o">...</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>

    <span class="tok-n">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@</span><span class="tok-err">.</span><span class="tok-nv">elements</span><span class="tok-p">;</span>

    <span class="tok-n">has</span> <span class="tok-n">Int</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">width</span><span class="tok-p">;</span>
    <span class="tok-n">has</span> <span class="tok-n">Int</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">height</span><span class="tok-p">;</span>

    <span class="tok-n">class</span> <span class="tok-n">Group</span> <span class="tok-n">does</span> <span class="tok-n">Element</span> <span class="tok-p">{</span>
        <span class="tok-n">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@</span><span class="tok-err">.</span><span class="tok-nv">elements</span><span class="tok-p">;</span>
        <span class="tok-n">method</span> <span class="tok-n">serialize</span><span class="tok-p">(</span> <span class="tok-o">--&gt;</span> <span class="tok-n">Pair</span> <span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-n">g</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">@</span><span class="tok-err">!</span><span class="tok-nv">elements</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">(</span> <span class="tok-o">-&gt;</span> <span class="tok-nv">$e</span> <span class="tok-p">{</span> <span class="tok-nv">$e</span><span class="tok-o">.</span><span class="tok-n">serialize</span> <span class="tok-p">})</span><span class="tok-o">.</span><span class="tok-n">list</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>

    <span class="tok-n">class</span> <span class="tok-n">Rectangle</span> <span class="tok-n">does</span> <span class="tok-n">Element</span> <span class="tok-p">{</span>
        <span class="tok-n">has</span> <span class="tok-n">Int</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">x</span><span class="tok-p">;</span>
        <span class="tok-n">has</span> <span class="tok-n">Int</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">y</span><span class="tok-p">;</span>
        <span class="tok-n">has</span> <span class="tok-n">Int</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">width</span><span class="tok-p">;</span>
        <span class="tok-n">has</span> <span class="tok-n">Int</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">height</span><span class="tok-p">;</span>
        <span class="tok-n">has</span> <span class="tok-n">Str</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">stroke</span><span class="tok-p">;</span>
        <span class="tok-n">has</span> <span class="tok-n">Str</span> <span class="tok-nv">$</span><span class="tok-err">.</span><span class="tok-nv">fill</span><span class="tok-p">;</span>

        <span class="tok-n">method</span> <span class="tok-n">serialize</span><span class="tok-p">(</span> <span class="tok-o">--&gt;</span> <span class="tok-n">Pair</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-n">rect</span> <span class="tok-o">=&gt;</span> <span class="tok-p">[</span><span class="tok-n">x</span> <span class="tok-o">=&gt;</span>  <span class="tok-nv">$</span><span class="tok-err">!</span><span class="tok-nv">x</span><span class="tok-p">,</span> <span class="tok-n">y</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">$</span><span class="tok-err">!</span><span class="tok-nv">y</span><span class="tok-p">,</span> <span class="tok-n">width</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">$</span><span class="tok-err">!</span><span class="tok-nv">width</span><span class="tok-p">,</span> <span class="tok-n">height</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">$</span><span class="tok-err">!</span><span class="tok-nv">height</span><span class="tok-p">,</span> <span class="tok-n">stroke</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">$</span><span class="tok-err">!</span><span class="tok-nv">stroke</span><span class="tok-p">,</span> <span class="tok-n">fill</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">$</span><span class="tok-err">!</span><span class="tok-nv">fill</span> <span class="tok-p">];</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>

    <span class="tok-n">method</span> <span class="tok-n">serialize</span><span class="tok-p">(</span> <span class="tok-o">--&gt;</span> <span class="tok-n">Str</span> <span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">SVG</span><span class="tok-o">.</span><span class="tok-n">serialize</span><span class="tok-p">(</span><span class="tok-n">svg</span> <span class="tok-o">=&gt;</span> <span class="tok-nv">@</span><span class="tok-err">!</span><span class="tok-nv">elements</span><span class="tok-o">.</span><span class="tok-nb">map</span><span class="tok-p">(</span><span class="tok-o">-&gt;</span> <span class="tok-nv">$e</span> <span class="tok-p">{</span> <span class="tok-nv">$e</span><span class="tok-o">.</span><span class="tok-n">serialize</span> <span class="tok-p">})</span><span class="tok-o">.</span><span class="tok-n">list</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要运行此示例，则应将其保存为`SVG/Drawing.pm`当前目录。</p>
</div>
<div class="paragraph">
<p>这给出了一个类来描述我们的图像作为一个整体，并协调数据结构的创建，这些数据结构将被序列化为我们的SVG文档，并且每个类都用于我们在原始示例中使用的`g`（Group）和`rect`（Rectangle）基元所以我们可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG::Drawing</span>;

<span class="tok-k">my</span> <span class="tok-n">SVG::Drawing</span> <span class="tok-nv">$drawing</span> = <span class="tok-n">SVG::Drawing</span>.<span class="tok-nb">new</span>(<span class="tok-n">elements</span> =&gt; [
    <span class="tok-n">SVG::Drawing::Group</span>.<span class="tok-nb">new</span>(<span class="tok-n">elements</span> =&gt; [
        <span class="tok-n">SVG::Drawing::Rectangle</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">5</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">5</span>, <span class="tok-n">width</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">height</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">stroke</span> =&gt; <span class="tok-s">&quot;black&quot;</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-s">&quot;green&quot;</span> )
    ]);
]);

<span class="tok-nb">say</span> <span class="tok-nv">$drawing</span>.<span class="tok-n">serialize</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成与第一个类似的文档。</p>
</div>
<div class="paragraph">
<p>您可能已经注意到了`Element`stubbed方法的作用`serialize`：这是为了描述基本类所需的接口，以便收集基本类对象的类可以取决于`serialize`它们何时到来时序列化这些收集的对象。生成XML文档。从一开始就添加它可以更容易，更可靠地添加类来描述绘图的新基元。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让我们延伸">40.3. 让我们延伸！</h3>
<div class="paragraph">
<p>因此，除非我们有兴趣用相互叠加的不同大小的正方形制作圣诞树的相当现代主义的表示，否则我们需要一种创建我们需要的三角形的方法。幸运的是，SVG提供了许多从一组坐标点创建任意闭合形状的方法，但我们将使用最简单的方法，<code>polygon`它有一个属性`points</code>，它是以逗号分隔的顶点坐标的空格分隔列表。形状，最后一个连接到第一个以关闭形状。</p>
</div>
<div class="paragraph">
<p>我们将使用一个新的Polygon类来描述`polygon`原语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG</span>;

<span class="tok-k">class</span> <span class="tok-n">SVG::Drawing</span> {
    <span class="tok-k">role</span> <span class="tok-n">Element</span> {
        <span class="tok-k">method</span> <span class="tok-n">serialize</span>() {
            ...
        }
    }

    <span class="tok-k">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@.elements</span>;

    <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.width</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.height</span>;

    <span class="tok-k">class</span> <span class="tok-n">Group</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> {
        <span class="tok-k">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@.elements</span>;
        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span> ) {
            <span class="tok-n">g</span> =&gt; <span class="tok-nv">@!elements</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$e</span> { <span class="tok-nv">$e</span>.<span class="tok-n">serialize</span> }).<span class="tok-n">list</span>;
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Rectangle</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.x</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.y</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.width</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.height</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.stroke</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.fill</span>;

        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span>) {
            <span class="tok-n">rect</span> =&gt; [<span class="tok-o">x</span> =&gt;  <span class="tok-nv">$!x</span>, <span class="tok-n">y</span> =&gt; <span class="tok-nv">$!y</span>, <span class="tok-n">width</span> =&gt; <span class="tok-nv">$!width</span>, <span class="tok-n">height</span> =&gt; <span class="tok-nv">$!height</span>, <span class="tok-n">stroke</span> =&gt; <span class="tok-nv">$!stroke</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-nv">$!fill</span> ];
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Point</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.x</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.y</span>;

        <span class="tok-k">method</span> <span class="tok-nb">Str</span>( --&gt; <span class="tok-nb">Str</span> ) {
            (<span class="tok-nv">$!x</span>, <span class="tok-nv">$!y</span>).<span class="tok-n">join:</span> <span class="tok-s">&#39;,&#39;</span>;
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Polygon</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.stroke</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.fill</span>;

        <span class="tok-k">has</span> <span class="tok-n">Point</span> <span class="tok-nv">@.points</span>;

        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span> ) {
            <span class="tok-n">polygon</span> =&gt; [ <span class="tok-n">points</span> =&gt; <span class="tok-nv">@!points</span>.<span class="tok-nb">join</span>(<span class="tok-s">&#39; &#39;</span>), <span class="tok-n">fill</span> =&gt; <span class="tok-nv">$!fill</span>, <span class="tok-n">stroke</span> =&gt; <span class="tok-nv">$!stroke</span> ];
        }

    }

    <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Str</span> ) {
        <span class="tok-n">SVG</span>.<span class="tok-n">serialize</span>(<span class="tok-n">svg</span> =&gt; <span class="tok-nv">@!elements</span>.<span class="tok-nb">map</span>(-&gt; <span class="tok-nv">$e</span> { <span class="tok-nv">$e</span>.<span class="tok-n">serialize</span> }).<span class="tok-n">list</span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了我们新的Polygon类之外，还有一个Point类描述了多边形顶点的坐标：<code>Str`提供的方法是为了简化`serialize`Polygon类方法的实现，因为</code>@.points`属性的元素将被字符串化为他们加入了`serialize`。</p>
</div>
<div class="paragraph">
<p>所以现在我们可以生成类似外观的图像，但是以不同的方式构造，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG::Drawing</span>;

<span class="tok-k">my</span> <span class="tok-n">SVG::Drawing</span> <span class="tok-nv">$drawing</span> = <span class="tok-n">SVG::Drawing</span>.<span class="tok-nb">new</span>(<span class="tok-n">elements</span> =&gt; [
    <span class="tok-n">SVG::Drawing::Group</span>.<span class="tok-nb">new</span>(<span class="tok-n">elements</span> =&gt; [
        <span class="tok-n">SVG::Drawing::Polygon</span>.<span class="tok-nb">new</span>(<span class="tok-n">stroke</span> =&gt; <span class="tok-s">&quot;black&quot;</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-s">&quot;green&quot;</span>, <span class="tok-n">points</span> =&gt; [
            <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">5</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">5</span>),
            <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">105</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">5</span>),
            <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">105</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">105</span>),
            <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">5</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">105</span>)
        ])
    ]);
]);

<span class="tok-nb">say</span> <span class="tok-nv">$drawing</span>.<span class="tok-n">serialize</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将生成一个XML文档，如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-s">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;</span>
<span class="tok-s">     xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;</span>
<span class="tok-s">     xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;</span>
	<span class="tok-s">&lt;g&gt;</span>
<span class="tok-s">		&lt;polygon points=&quot;5,5 105,5 105,105 5,105&quot; fill=&quot;green&quot; stroke=&quot;black&quot; /&gt;</span>
	<span class="tok-s">&lt;/g&gt;</span>
<span class="tok-s">&lt;/svg&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在我们几乎拥有了绘制Chritmas树所需的一切，但在这一点上，值得退一步，展示对未来自我（或者其他可能需要处理代码的人）的爱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个重构点">40.4. 一个重构点</h3>
<div class="paragraph">
<p>当我们创建新的Polygon类时，我们复制了`S.stroke`和`$.fill`属性，并安排它们以类似于Rectangle类的方式进行序列化。如果我们赶时间这可能是有意义的，这些是他们可能被使用的唯一地方，但是当我们阅读SVG文档时，很明显它们可以应用于许多SVG原语，因此重构是有意义的。现在，在我们添加任何可能需要它们的类之前。</p>
</div>
<div class="paragraph">
<p>最明显的方法是创建一个包含属性的新角色，并提供一个方法，该方法返回表示序列化中属性的对列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG</span>;

<span class="tok-k">class</span> <span class="tok-n">SVG::Drawing</span> {
    <span class="tok-k">role</span> <span class="tok-n">Element</span> {
        <span class="tok-k">method</span> <span class="tok-n">serialize</span>() {
            ...
        }
    }

    <span class="tok-k">role</span> <span class="tok-n">Styled</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.stroke</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.fill</span>;

        <span class="tok-k">method</span> <span class="tok-n">styles</span>() {
            ( <span class="tok-n">stroke</span> =&gt; <span class="tok-nv">$!stroke</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-nv">$!fill</span> ).<span class="tok-nb">grep</span>( { .<span class="tok-nb">value</span>.<span class="tok-nb">defined</span> } );
        }

    }

    <span class="tok-k">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@.elements</span>;

    <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.width</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.height</span>;

    <span class="tok-k">class</span> <span class="tok-n">Group</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> {
        <span class="tok-k">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@.elements</span>;
        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span> ) {
            <span class="tok-n">g</span> =&gt; <span class="tok-nv">@!elements</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$e</span> { <span class="tok-nv">$e</span>.<span class="tok-n">serialize</span> }).<span class="tok-n">list</span>;
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Rectangle</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> <span class="tok-nb">does</span> <span class="tok-n">Styled</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.x</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.y</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.width</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.height</span>;

        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span>) {
            <span class="tok-n">rect</span> =&gt; [<span class="tok-o">x</span> =&gt;  <span class="tok-nv">$!x</span>, <span class="tok-n">y</span> =&gt; <span class="tok-nv">$!y</span>, <span class="tok-n">width</span> =&gt; <span class="tok-nv">$!width</span>, <span class="tok-n">height</span> =&gt; <span class="tok-nv">$!height</span>, |<span class="tok-k">self</span>.<span class="tok-n">styles</span> ];
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Point</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.x</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.y</span>;

        <span class="tok-k">method</span> <span class="tok-nb">Str</span>( --&gt; <span class="tok-nb">Str</span> ) {
            (<span class="tok-nv">$!x</span>, <span class="tok-nv">$!y</span>).<span class="tok-n">join:</span> <span class="tok-s">&#39;,&#39;</span>;
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Polygon</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> <span class="tok-nb">does</span> <span class="tok-n">Styled</span> {

        <span class="tok-k">has</span> <span class="tok-n">Point</span> <span class="tok-nv">@.points</span>;

        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span> ) {
            <span class="tok-n">polygon</span> =&gt; [ <span class="tok-n">points</span> =&gt; <span class="tok-nv">@!points</span>.<span class="tok-nb">join</span>(<span class="tok-s">&#39; &#39;</span>), |<span class="tok-k">self</span>.<span class="tok-n">styles</span> ];
        }

    }

    <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Str</span> ) {
        <span class="tok-n">SVG</span>.<span class="tok-n">serialize</span>(<span class="tok-n">svg</span> =&gt; <span class="tok-nv">@!elements</span>.<span class="tok-nb">map</span>(-&gt; <span class="tok-nv">$e</span> { <span class="tok-nv">$e</span>.<span class="tok-n">serialize</span> }).<span class="tok-n">list</span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在我们有一个双重好处，我们可以添加一个新的样式类而不必复制属性，而且我们可以添加我们可能想要的新样式属性，而无需更改消耗类。</p>
</div>
<div class="paragraph">
<p>通过一些额外的工作，我们可能失去了从the中的角色调用方法的需要`serialize`，比如说，使用属性上的特征，这将允许我们选择要序列化的属性，但我将把它当作一个随着圣诞节的到来，我们仍然没有树。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个进一步的抽象">40.5. 一个进一步的抽象</h3>
<div class="paragraph">
<p>现在我们处于一个很好的位置来创建我们的圣诞树，因为我们需要的三角形只是一个多边形的三面形状，但我们想要不止一个并且顶点的计算将是相当重复，加上，因为我为了简单而任意选择使用等边三角形，其他两个角的坐标可以从顶点和边长度的坐标计算，所以如果我们有一个三角类它可以自我计算，我们只需关注自己的大小和位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG</span>;

<span class="tok-k">class</span> <span class="tok-n">SVG::Drawing</span> {
    <span class="tok-k">role</span> <span class="tok-n">Element</span> {
        <span class="tok-k">method</span> <span class="tok-n">serialize</span>() {
            ...
        }
    }

    <span class="tok-k">role</span> <span class="tok-n">Styled</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.stroke</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.fill</span>;

        <span class="tok-k">method</span> <span class="tok-n">styles</span>() {
            ( <span class="tok-n">stroke</span> =&gt; <span class="tok-nv">$!stroke</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-nv">$!fill</span> ).<span class="tok-nb">grep</span>( { .<span class="tok-nb">value</span>.<span class="tok-nb">defined</span> } );
        }

    }

    <span class="tok-k">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@.elements</span>;

    <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.width</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.height</span>;

    <span class="tok-k">class</span> <span class="tok-n">Group</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> {
        <span class="tok-k">has</span> <span class="tok-n">Element</span> <span class="tok-nv">@.elements</span>;
        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span> ) {
            <span class="tok-n">g</span> =&gt; <span class="tok-nv">@!elements</span>.<span class="tok-nb">map</span>( -&gt; <span class="tok-nv">$e</span> { <span class="tok-nv">$e</span>.<span class="tok-n">serialize</span> }).<span class="tok-n">list</span>;
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Rectangle</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> <span class="tok-nb">does</span> <span class="tok-n">Styled</span> {
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.x</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.y</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.width</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span> <span class="tok-nv">$.height</span>;

        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span>) {
            <span class="tok-n">rect</span> =&gt; [<span class="tok-o">x</span> =&gt;  <span class="tok-nv">$!x</span>, <span class="tok-n">y</span> =&gt; <span class="tok-nv">$!y</span>, <span class="tok-n">width</span> =&gt; <span class="tok-nv">$!width</span>, <span class="tok-n">height</span> =&gt; <span class="tok-nv">$!height</span>, |<span class="tok-k">self</span>.<span class="tok-n">styles</span> ];
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Point</span> {
        <span class="tok-k">has</span> <span class="tok-n">Numeric</span> <span class="tok-nv">$.x</span>;
        <span class="tok-k">has</span> <span class="tok-n">Numeric</span> <span class="tok-nv">$.y</span>;

        <span class="tok-k">method</span> <span class="tok-nb">Str</span>( --&gt; <span class="tok-nb">Str</span> ) {
            (<span class="tok-nv">$!x</span>, <span class="tok-nv">$!y</span>).<span class="tok-n">join:</span> <span class="tok-s">&#39;,&#39;</span>;
        }
    }

    <span class="tok-k">class</span> <span class="tok-n">Polygon</span> <span class="tok-nb">does</span> <span class="tok-n">Element</span> <span class="tok-nb">does</span> <span class="tok-n">Styled</span> {

        <span class="tok-k">has</span> <span class="tok-n">Point</span> <span class="tok-nv">@.points</span>;

        <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Pair</span> ) {
            <span class="tok-n">polygon</span> =&gt; [ <span class="tok-n">points</span> =&gt; <span class="tok-nv">@.points</span>.<span class="tok-nb">join</span>(<span class="tok-s">&#39; &#39;</span>), |<span class="tok-k">self</span>.<span class="tok-n">styles</span> ];
        }

    }

    <span class="tok-k">class</span> <span class="tok-n">Triangle</span> <span class="tok-k">is</span> <span class="tok-n">Polygon</span> {
        <span class="tok-k">has</span> <span class="tok-n">Point</span> <span class="tok-nv">$.apex</span> <span class="tok-k">is</span> <span class="tok-k">required</span>;
        <span class="tok-k">has</span> <span class="tok-nb">Int</span>   <span class="tok-nv">$.side</span> <span class="tok-k">is</span> <span class="tok-k">required</span>;

        <span class="tok-k">method</span> <span class="tok-n">points</span>() {
            (<span class="tok-nv">$!apex</span>, |<span class="tok-k">self</span>.<span class="tok-n">base-points</span>);
        }

        <span class="tok-k">method</span> <span class="tok-n">base-points</span>() {
            <span class="tok-k">my</span> <span class="tok-nv">$y</span> = <span class="tok-nv">$!apex</span>.<span class="tok-n">y</span> + <span class="tok-k">self</span>.<span class="tok-n">get-height</span>;

            (<span class="tok-n">Point</span>.<span class="tok-nb">new</span>(:<span class="tok-nv">$y</span>, <span class="tok-o">x</span> =&gt; <span class="tok-nv">$!apex</span>.<span class="tok-o">x</span> - ( <span class="tok-nv">$!side</span> / <span class="tok-mi">2</span> )), <span class="tok-n">Point</span>.<span class="tok-nb">new</span>(:<span class="tok-nv">$y</span>, <span class="tok-o">x</span> =&gt; <span class="tok-nv">$!apex</span>.<span class="tok-o">x</span> + ( <span class="tok-nv">$!side</span> / <span class="tok-mi">2</span> )));
        }

        <span class="tok-k">method</span> <span class="tok-n">get-height</span>(--&gt; <span class="tok-nb">Num</span> ) {
            <span class="tok-nb">sqrt</span>(<span class="tok-nv">$!side</span><span class="tok-o">**</span><span class="tok-mi">2</span> - (<span class="tok-nv">$!side</span><span class="tok-o">/</span><span class="tok-mi">2</span>)**<span class="tok-mi">2</span>)
        }

    }

    <span class="tok-k">method</span> <span class="tok-n">dimensions</span>() {
        ( <span class="tok-n">height</span> =&gt; <span class="tok-nv">$!height</span>, <span class="tok-n">width</span> =&gt; <span class="tok-nv">$!width</span> ).<span class="tok-nb">grep</span>( { .<span class="tok-nb">value</span>.<span class="tok-nb">defined</span> } );

    }

    <span class="tok-k">method</span> <span class="tok-n">serialize</span>( --&gt; <span class="tok-nb">Str</span> ) {
        <span class="tok-n">SVG</span>.<span class="tok-n">serialize</span>(<span class="tok-n">svg</span> =&gt;  [ |<span class="tok-k">self</span>.<span class="tok-n">dimensions</span>, |<span class="tok-nv">@!elements</span>.<span class="tok-nb">map</span>(-&gt; <span class="tok-nv">$e</span> { <span class="tok-nv">$e</span>.<span class="tok-n">serialize</span> })]);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要在其他地方进行一些小的改动。在`Int`作为三角形的顶点的计算结果可能不是整数（或我们会风了一个靠不住的三角形，如果我们roumded他们）还点的属性是放宽到数字`serialize`多边形的方法是改变使用访问器方法`points`而不是直接使用属性，因此可以在我们的Triangle类中过度使用以计算三角形基线的附加点。</p>
</div>
<div class="paragraph">
<p>计算本身只使用一些初级几何来确定基线到顶点的高度，使用毕达哥拉斯定理得到两个基线点的y坐标，x坐标是两侧边长的一半。顶点x坐标。</p>
</div>
<div class="paragraph">
<p>此外，当我测试这个时，我注意到我之前没有实现高度和宽度属性的序列化，我们已经离开它，因为矩形没有超出默认绘图区域，但是三角形做了，因此没有显示。</p>
</div>
<div class="paragraph">
<p>无论如何，现在我们可以用最少的代码绘制一个三角形：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG::Drawing</span>;

<span class="tok-k">my</span> <span class="tok-n">SVG::Drawing</span> <span class="tok-nv">$drawing</span> = <span class="tok-n">SVG::Drawing</span>.<span class="tok-nb">new</span>(
    <span class="tok-n">elements</span> =&gt; [
        <span class="tok-n">SVG::Drawing::Group</span>.<span class="tok-nb">new</span>(<span class="tok-n">elements</span> =&gt; [
            <span class="tok-n">SVG::Drawing::Triangle</span>.<span class="tok-nb">new</span>(<span class="tok-n">stroke</span> =&gt; <span class="tok-s">&quot;black&quot;</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-s">&quot;green&quot;</span>,
                <span class="tok-n">apex</span> =&gt; <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">50</span>),
                <span class="tok-n">side</span> =&gt; <span class="tok-mi">50</span>,
            )
        ])
    ],
    <span class="tok-n">height</span>  =&gt; <span class="tok-mi">300</span>,
    <span class="tok-n">width</span>   =&gt; <span class="tok-mi">200</span>
);

<span class="tok-nb">say</span> <span class="tok-nv">$drawing</span>.<span class="tok-n">serialize</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将在足够大的空间中提供一个漂亮的绿色等边三角形来绘制我们的树。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最后是我们的树">40.6. 最后是我们的树</h3>
<div class="paragraph">
<p>现在我们有了创建简单树的组成部分的方法，因此我们可以将它们与一个相对简单的脚本放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">SVG::Drawing</span>;

<span class="tok-k">my</span> <span class="tok-n">SVG::Drawing</span> <span class="tok-nv">$drawing</span> = <span class="tok-n">SVG::Drawing</span>.<span class="tok-nb">new</span>(
    <span class="tok-n">elements</span> =&gt; [
        <span class="tok-n">SVG::Drawing::Group</span>.<span class="tok-nb">new</span>(<span class="tok-n">elements</span> =&gt; [
            <span class="tok-n">SVG::Drawing::Triangle</span>.<span class="tok-nb">new</span>(<span class="tok-n">stroke</span> =&gt; <span class="tok-s">&quot;green&quot;</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-s">&quot;green&quot;</span>,
                <span class="tok-n">apex</span> =&gt; <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">50</span>),
                <span class="tok-n">side</span> =&gt; <span class="tok-mi">50</span>,
            ),
            <span class="tok-n">SVG::Drawing::Triangle</span>.<span class="tok-nb">new</span>(<span class="tok-n">stroke</span> =&gt; <span class="tok-s">&quot;green&quot;</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-s">&quot;green&quot;</span>,
                <span class="tok-n">apex</span> =&gt; <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">75</span>),
                <span class="tok-n">side</span> =&gt; <span class="tok-mi">75</span>,
            ),
            <span class="tok-n">SVG::Drawing::Triangle</span>.<span class="tok-nb">new</span>(<span class="tok-n">stroke</span> =&gt; <span class="tok-s">&quot;green&quot;</span>, <span class="tok-n">fill</span> =&gt; <span class="tok-s">&quot;green&quot;</span>,
                <span class="tok-n">apex</span> =&gt; <span class="tok-n">SVG::Drawing::Point</span>.<span class="tok-nb">new</span>(<span class="tok-o">x</span> =&gt; <span class="tok-mi">100</span>, <span class="tok-n">y</span> =&gt; <span class="tok-mi">100</span>),
                <span class="tok-n">side</span> =&gt; <span class="tok-mi">100</span>,
            ),
            <span class="tok-n">SVG::Drawing::Rectangle</span>.<span class="tok-nb">new</span>(<span class="tok-n">stroke</span>  =&gt; <span class="tok-s">&quot;brown&quot;</span>,
                                        <span class="tok-n">fill</span>    =&gt; <span class="tok-s">&quot;brown&quot;</span>,
                                        <span class="tok-o">x</span>       =&gt;  <span class="tok-mi">90</span>,
                                        <span class="tok-n">y</span>       =&gt; <span class="tok-mi">185</span>,
                                        <span class="tok-n">width</span>   =&gt; <span class="tok-mi">20</span>,
                                        <span class="tok-n">height</span>  =&gt; <span class="tok-mi">40</span>),
        ])
    ],
    <span class="tok-n">height</span>  =&gt; <span class="tok-mi">300</span>,
    <span class="tok-n">width</span>   =&gt; <span class="tok-mi">200</span>
);

<span class="tok-nb">say</span> <span class="tok-nv">$drawing</span>.<span class="tok-n">serialize</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我通过反复试验选择了形状的大小和位置，它可能更科学地完成。</p>
</div>
<div class="paragraph">
<p>无论如何，这会产生这样的XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;svg</span> <span class="tok-na">xmlns=</span><span class="tok-s">&quot;http://www.w3.org/2000/svg&quot;</span>
     <span class="tok-na">xmlns:svg=</span><span class="tok-s">&quot;http://www.w3.org/2000/svg&quot;</span>
     <span class="tok-na">xmlns:xlink=</span><span class="tok-s">&quot;http://www.w3.org/1999/xlink&quot;</span>
     <span class="tok-na">height=</span><span class="tok-s">&quot;300&quot;</span>
     <span class="tok-na">width=</span><span class="tok-s">&quot;200&quot;</span><span class="tok-nt">&gt;</span>
	<span class="tok-nt">&lt;g&gt;</span>
		<span class="tok-nt">&lt;polygon</span> <span class="tok-na">points=</span><span class="tok-s">&quot;100,50 75,93.30127018922192 125,93.30127018922192&quot;</span> <span class="tok-na">stroke=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-na">fill=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-nt">/&gt;</span>
		<span class="tok-nt">&lt;polygon</span> <span class="tok-na">points=</span><span class="tok-s">&quot;100,75 62.5,139.9519052838329 137.5,139.9519052838329&quot;</span> <span class="tok-na">stroke=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-na">fill=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-nt">/&gt;</span>
		<span class="tok-nt">&lt;polygon</span> <span class="tok-na">points=</span><span class="tok-s">&quot;100,100 50,186.60254037844385 150,186.60254037844385&quot;</span> <span class="tok-na">stroke=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-na">fill=</span><span class="tok-s">&quot;green&quot;</span> <span class="tok-nt">/&gt;</span>
		<span class="tok-nt">&lt;rect</span> <span class="tok-na">x=</span><span class="tok-s">&quot;90&quot;</span> <span class="tok-na">y=</span><span class="tok-s">&quot;185&quot;</span> <span class="tok-na">width=</span><span class="tok-s">&quot;20&quot;</span> <span class="tok-na">height=</span><span class="tok-s">&quot;40&quot;</span> <span class="tok-na">stroke=</span><span class="tok-s">&quot;brown&quot;</span> <span class="tok-na">fill=</span><span class="tok-s">&quot;brown&quot;</span> <span class="tok-nt">/&gt;</span>
	<span class="tok-nt">&lt;/g&gt;</span>
<span class="tok-nt">&lt;/svg&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个合理的程式化圣诞树，用户代码最少。</p>
</div>
<div class="paragraph">
<p>由于我们设计模块的方式，我们已经把自己放在一个好的地方进一步扩展它，比如说，一个Circle类可以用来轻松地为我们的树添加彩色小玩意。</p>
</div>
<div class="paragraph">
<p>SVG是一个非常丰富的规范，具有大量基元，可满足大多数绘图需求，我们只实现了绘制树所需的最小值，但这可以扩展为支持您想要的任何类型的绘图。</p>
</div>
<div class="paragraph">
<p><a href="https://perl6advent.files.wordpress.com/2018/12/tree.png?w=788">树</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_交互式桌面应用">41. 第十九天 - 交互式桌面应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我是地下城与龙等角色扮演游戏的忠实粉丝。这些游戏中的大多数都有屏幕来帮助你隐藏你在运行游戏时所做的事情，并为你提供游戏中使用的一些图表，以减少书中的内容。</p>
</div>
<div class="paragraph">
<p>我的游戏收藏很广泛而且我宁愿使用我的笔记本电脑不仅隐藏在后面并跟踪信息，而且我还可以自动化骰子和图表使用。虽然我可以用文本编辑器和命令行魔法拼凑一些东西，但我宁愿拥有一些时髦的桌面应用程序，我可以向人们展示。</p>
</div>
<div class="paragraph">
<p>输入<a href="https://github.com/perl6/gtk-simple">GTK::Simple</a>是Linux Gnome桌面使用的gtk3 UI库的包装器，但也可以在Windows和Mac上使用。该库通过Native Call 的强大功能为你提供了一个简单易用的界面，让你可以创建简单的桌面应用程序。</p>
</div>
<div class="sect2">
<h3 id="_骰子滚动">41.1. 骰子滚动</h3>
<div class="paragraph">
<p>由于历史原因，角色扮演游戏大多数倾向于选择使用基于柏拉图固体的骰子。骰子的标准组合是4,6,8,10,12,20，并且通过组合2个10面骰子100的骰子。骰子可以多次滚动，用于写入的标准符号是“ x<strong>d</strong>y ”，其中 “<strong>x</strong>“ 是掷骰子的数量，”<strong>y</strong>“ 是掷骰子的大小。单个骰子在开始时跳过1，例如“roll a d6”意味着掷出六面骰子。</p>
</div>
<div class="paragraph">
<p>有趣的是，在 Perl 6 中制作 “<strong>d</strong>” 运算符非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">infix:</span> ( <span class="tok-nb">UInt</span> <span class="tok-nv">$count</span>, <span class="tok-nb">UInt</span> <span class="tok-nv">$size</span> ) { (<span class="tok-mi">1</span>..<span class="tok-nv">$size</span>).<span class="tok-n">roll</span>(<span class="tok-nv">$count</span>) }
<span class="tok-k">sub</span> <span class="tok-n">prefix:</span> ( <span class="tok-nb">UInt</span> <span class="tok-nv">$size</span> ) { <span class="tok-mi">1</span> <span class="tok-n">d</span> <span class="tok-nv">$size</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，你需要将数字与空格分开，并且 “<strong>d</strong>” 运算符或编译器会混淆。</p>
</div>
<div class="paragraph">
<p>我想要的是一个骰子滚轮应用程序，它提供了选择滚动标准骰子组的选项。现在我不会看到一些游戏使用的不同骰子，或者修改滚动，很多游戏都使用这些骰子。我想看看每个掷骰子，因为这可能很重要，具体取决于系统。如果可能的话，我也想要总数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_简单的_gtksimple">41.2. 简单的 GTK::Simple</h3>
<div class="paragraph">
<p>GTK::Simple 的基本用法很简单。创建一个应用程序，添加内容，放入一些事件处理程序，然后离开。</p>
</div>
<div class="paragraph">
<p>首先，我们创建我们的应用程序，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-ch">#!/usr/bin/env perl6</span>

<span class="tok-c1"># Get the GTK::Simple libraries</span>
<span class="tok-k">use</span> <span class="tok-nn">GTK::Simple</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">GTK::Simple::App</span><span class="tok-p">;</span>

<span class="tok-c1"># Create the main app</span>
<span class="tok-k">my</span> <span class="tok-nv">$app</span> <span class="tok-o">=</span> <span class="tok-nn">GTK::Simple::</span><span class="tok-n">App</span><span class="tok-o">.</span><span class="tok-k">new</span><span class="tok-p">(</span> <span class="tok-n">title</span> <span class="tok-o">=&gt;</span> <span class="tok-s">&quot;Dice Roller&quot;</span> <span class="tok-p">);</span>

<span class="tok-c1"># Start the app running</span>
<span class="tok-nv">$app</span><span class="tok-o">.</span><span class="tok-n">run</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>但…。这不是很有趣：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/empty.png?w=788">空</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_网格布局">41.3. 网格布局</h3>
<div class="paragraph">
<p>要在应用程序中布局小部件，我们有各种选项，但建议使用的是网格。网格布局从左上角的0,0开始并根据需要延伸的小部件。</p>
</div>
<div class="paragraph">
<p>正是在这一点上，我尝试构建一个应用程序，我打了一个墙。网格选项很好，我在下面的最后一个例子中使用它但是当我尝试的时候它没有按照我的预期工作。我仍然可以得到一个简单的网格，所以显示它的工作，但似乎需要更多的学习。无论如何这里是一个基本网格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!/usr/bin/env perl6</span>
<span class="tok-c1"># Get the GTK::Simple libraries</span>
<span class="tok-k">use</span> <span class="tok-n">GTK::Simple</span>;
<span class="tok-k">use</span> <span class="tok-n">GTK::Simple::App</span>;

<span class="tok-c1"># Create the main app</span>
<span class="tok-k">my</span> <span class="tok-nv">$app</span> = <span class="tok-n">GTK::Simple::App</span>.<span class="tok-nb">new</span>( <span class="tok-n">title</span> =&gt; <span class="tok-s">&quot;Grid&quot;</span> );

<span class="tok-nv">$app</span>.<span class="tok-n">set-content</span>(
    <span class="tok-n">GTK::Simple::Grid</span>.<span class="tok-nb">new</span>(
        <span class="tok-c1"># Grid key is [x,y,height,width]</span>
        [<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;a&quot;</span> ),
        <span class="tok-c1"># A Button is a simple push button with a label</span>
        [<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;b&quot;</span> ),
        [<span class="tok-mi">0</span>,<span class="tok-mi">2</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;c&quot;</span> ),
        [<span class="tok-mi">1</span>,<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">3</span>] =&gt; <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;d&quot;</span> ),
    )
);

<span class="tok-nv">$app</span>.<span class="tok-n">border-width</span> = <span class="tok-mi">10</span>;
<span class="tok-c1"># Start the app</span>
<span class="tok-nv">$app</span>.<span class="tok-nb">run</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个产生：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/grid-1.png?w=788">格</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_交互">41.4. 交互</h3>
<div class="paragraph">
<p>这很整洁，但按钮还没有做任何事情。为此，我们需要事件处理程序。GUI应用程序需要事件驱动才能对用户操作做出反应，幸运的是 Perl 6 具有处理 Supplies 形式的事件的功能。每个按钮都有一个名为 clicked 的 supply，它可以附加一个 tap 处理程序。</p>
</div>
<div class="paragraph">
<p>事件处理程序可以执行各种操作，包括操作其他UI对象。例如 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!/usr/bin/env perl6</span>

<span class="tok-c1"># Get the GTK::Simple libraries</span>
<span class="tok-k">use</span> <span class="tok-n">GTK::Simple</span>;
<span class="tok-k">use</span> <span class="tok-n">GTK::Simple::App</span>;

<span class="tok-c1"># Create the main app</span>
<span class="tok-k">my</span> <span class="tok-nv">$app</span> = <span class="tok-n">GTK::Simple::App</span>.<span class="tok-nb">new</span>( <span class="tok-n">title</span> =&gt; <span class="tok-s">&quot;Grid&quot;</span> );

<span class="tok-nv">$app</span>.<span class="tok-n">set-content</span>(
    <span class="tok-n">GTK::Simple::Grid</span>.<span class="tok-nb">new</span>(
        <span class="tok-c1"># As we want to refer to our buttons later we assign them</span>
        <span class="tok-c1"># to variables</span>
        [<span class="tok-mi">0</span>,<span class="tok-mi">0</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-k">my</span> <span class="tok-nv">$b1</span> = <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;Push Me&quot;</span> ),
        [<span class="tok-mi">1</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-k">my</span> <span class="tok-nv">$b2</span> = <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;---&quot;</span> ),
        [<span class="tok-mi">2</span>,<span class="tok-mi">2</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-k">my</span> <span class="tok-nv">$b3</span> = <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;---&quot;</span> ),
        [<span class="tok-mi">3</span>,<span class="tok-mi">3</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-k">my</span> <span class="tok-nv">$b4</span> = <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>( <span class="tok-n">label</span> =&gt; <span class="tok-s">&quot;---&quot;</span> ),
    )
);

<span class="tok-c1"># The sensitive flag controls whether you can click on the button</span>
<span class="tok-nv">$b2</span>.<span class="tok-n">sensitive</span> = <span class="tok-nb">False</span>;
<span class="tok-nv">$b3</span>.<span class="tok-n">sensitive</span> = <span class="tok-nb">False</span>;
<span class="tok-nv">$b4</span>.<span class="tok-n">sensitive</span> = <span class="tok-nb">False</span>;

<span class="tok-c1"># In the</span>
<span class="tok-nv">$b1</span>.<span class="tok-n">clicked</span>.<span class="tok-n">tap</span>( {
    <span class="tok-c1"># $_ is the clicked button. Turn it off</span>
    .<span class="tok-n">sensitive</span> = <span class="tok-nb">False</span>;
    <span class="tok-c1"># Change the label on the next button</span>
    <span class="tok-nv">$b2</span>.<span class="tok-n">label</span> = <span class="tok-s">&quot;Now Me!&quot;</span>;
    <span class="tok-c1"># Make it clickable</span>
    <span class="tok-nv">$b2</span>.<span class="tok-n">sensitive</span> = <span class="tok-nb">True</span>
} );

<span class="tok-c1"># Leaving on one line to cut down on space</span>
<span class="tok-nv">$b2</span>.<span class="tok-n">clicked</span>.<span class="tok-n">tap</span>( { .<span class="tok-n">sensitive</span> = <span class="tok-nb">False</span>; <span class="tok-nv">$b3</span>.<span class="tok-n">label</span> = <span class="tok-s">&quot;Me Next&quot;</span>; <span class="tok-nv">$b3</span>.<span class="tok-n">sensitive</span> = <span class="tok-nb">True</span> } );
<span class="tok-nv">$b3</span>.<span class="tok-n">clicked</span>.<span class="tok-n">tap</span>( { .<span class="tok-n">sensitive</span> = <span class="tok-nb">False</span>; <span class="tok-nv">$b4</span>.<span class="tok-n">label</span> = <span class="tok-s">&quot;Me! Me!&quot;</span>; <span class="tok-nv">$b4</span>.<span class="tok-n">sensitive</span> = <span class="tok-nb">True</span> } );
<span class="tok-c1"># App.exit closes the app.</span>
<span class="tok-nv">$b4</span>.<span class="tok-n">clicked</span>.<span class="tok-n">tap</span>( { <span class="tok-nv">$app</span>.<span class="tok-k">exit</span> } );

<span class="tok-nv">$app</span>.<span class="tok-n">border-width</span> = <span class="tok-mi">10</span>;
<span class="tok-c1"># Start the app</span>
<span class="tok-nv">$app</span>.<span class="tok-nb">run</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使得：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/buttons.png?w=788">纽扣</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_把它们放在一起">41.5. 把它们放在一起</h3>
<div class="paragraph">
<p>有了这个和另一个小部件，Label 给了我们一些文本，我们可以把骰子滚动应用程序放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1">#!/usr/bin/env perl6</span>

<span class="tok-c1"># Get the GTK::Simple libraries</span>
<span class="tok-k">use</span> <span class="tok-n">GTK::Simple</span>;
<span class="tok-k">use</span> <span class="tok-n">GTK::Simple::App</span>;

<span class="tok-c1"># Define our `d` operator</span>
<span class="tok-k">sub</span> <span class="tok-n">infix:</span> ( <span class="tok-nb">UInt</span> <span class="tok-nv">$count</span>, <span class="tok-nb">UInt</span> <span class="tok-nv">$size</span> ) { (<span class="tok-mi">1</span>..<span class="tok-nv">$size</span>).<span class="tok-n">roll</span>(<span class="tok-nv">$count</span>) }

<span class="tok-c1"># Create the main app</span>
<span class="tok-k">my</span> <span class="tok-nv">$app</span> = <span class="tok-n">GTK::Simple::App</span>.<span class="tok-nb">new</span>( <span class="tok-n">title</span> =&gt; <span class="tok-s">&quot;Dice Roller&quot;</span> );

<span class="tok-c1"># Output Box : Define here so the buttons can access it.</span>
<span class="tok-k">my</span> <span class="tok-nv">$output</span> = <span class="tok-n">GTK::Simple::Label</span>.<span class="tok-nb">new</span>( <span class="tok-n">text</span> =&gt; <span class="tok-s">&#39;Roll : &#39;</span>);

<span class="tok-c1"># Ouput box updater.</span>
<span class="tok-k">sub</span> <span class="tok-n">roll</span>( <span class="tok-nv">$label</span>, <span class="tok-nv">$count</span>, <span class="tok-nv">$size</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">@roll</span> = <span class="tok-nv">$count</span> <span class="tok-n">d</span> <span class="tok-nv">$size</span>;
    <span class="tok-nv">$label</span>.<span class="tok-n">text</span> = <span class="tok-s">&quot;Roll : {@roll.join(&quot;</span> + <span class="tok-s">&quot;)} = {@roll.sum}&quot;</span>;
}

<span class="tok-c1"># Create a grid and put the output box at the bottom filling the width</span>
<span class="tok-k">my</span> <span class="tok-nv">@grid</span> = ( [<span class="tok-mi">0</span>,<span class="tok-mi">6</span>,<span class="tok-mi">7</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-nv">$output</span> );

<span class="tok-c1"># Track our depth in tthe grid</span>
<span class="tok-k">my</span> <span class="tok-nv">$y</span> = <span class="tok-mi">0</span>;

<span class="tok-c1"># Loop through counts</span>
<span class="tok-k">for</span> (<span class="tok-mi">1</span><span class="tok-o">..</span><span class="tok-mi">6</span>) -&gt; <span class="tok-nv">$count</span> {

    <span class="tok-c1"># Track our postion along the grid</span>
    <span class="tok-k">my</span> <span class="tok-nv">$x</span> = <span class="tok-mi">0</span>;

    <span class="tok-c1"># Loop through standard dice sizes</span>
    <span class="tok-k">for</span> (<span class="tok-mi">4</span>,<span class="tok-mi">6</span>,<span class="tok-mi">8</span>,<span class="tok-mi">10</span>,<span class="tok-mi">12</span>,<span class="tok-mi">20</span>,<span class="tok-mi">100</span>) -&gt; <span class="tok-nv">$size</span> {

	<span class="tok-c1"># Standard labelling</span>
	<span class="tok-k">my</span> <span class="tok-nv">$label</span> = <span class="tok-nv">$count</span> &gt; <span class="tok-mi">1</span> ?? <span class="tok-s">&quot;{$count}d{$size}&quot;</span> !! <span class="tok-s">&quot;d{$size}&quot;</span>;

	<span class="tok-c1"># Create our button</span>
	<span class="tok-k">my</span> <span class="tok-nv">$button</span> = <span class="tok-n">GTK::Simple::Button</span>.<span class="tok-nb">new</span>(<span class="tok-n">label</span> =&gt; <span class="tok-nv">$label</span>);

	<span class="tok-c1"># Buttons get a supply which emit when they are clicked</span>
	<span class="tok-c1"># Assign our roll function with the current count and size to it</span>
	<span class="tok-c1"># Note we do it in a block so it&#39;s not called right now but when</span>
	<span class="tok-c1"># the button is clicked</span>
	<span class="tok-nv">$button</span>.<span class="tok-n">clicked</span>.<span class="tok-n">tap</span>(
	    { <span class="tok-n">roll</span>( <span class="tok-nv">$output</span>, <span class="tok-nv">$count</span>, <span class="tok-nv">$size</span> ) }
	);

	<span class="tok-c1"># Put the button in the valid place in the grid taking up one space</span>
	<span class="tok-nv">@grid</span>.<span class="tok-nb">push</span>( [<span class="tok-nv">$x</span>,<span class="tok-nv">$y</span>,<span class="tok-mi">1</span>,<span class="tok-mi">1</span>] =&gt; <span class="tok-nv">$button</span> );

	<span class="tok-nv">$x</span>++;
    }
    <span class="tok-nv">$y</span>++
}

<span class="tok-c1"># Create a grid object and assign it to the app.</span>
<span class="tok-nv">$app</span>.<span class="tok-n">set-content</span>(
    <span class="tok-n">GTK::Simple::Grid</span>.<span class="tok-nb">new</span>( |<span class="tok-nv">@grid</span> )
);

<span class="tok-nv">$app</span>.<span class="tok-n">border-width</span> = <span class="tok-mi">10</span>;

<span class="tok-c1"># Start the app running</span>
<span class="tok-nv">$app</span>.<span class="tok-nb">run</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来像（这里滚动3d6）：</p>
</div>
<div class="paragraph">
<p>!<a href="https://perl6advent.files.wordpress.com/2018/12/dice-roller.png?w=788">骰子辊</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_最后的想法">41.6. 最后的想法</h3>
<div class="paragraph">
<p>考虑到我今天早上没有触及 GTK::Simple，我对我的最终结果非常满意。我认为我可以构建许多其他游戏工具。此外，我可能会参与模块本身的工作，尝试将更多的GTK功能添加到其中，并添加一些文档。</p>
</div>
<div class="paragraph">
<p>尽管如此，使用 GTK::Simple 还是很容易使桌面应用程序在Perl6中遇到特殊的问题，而且代码并不多。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_perl_6_中的命题组合">42. 第二十天 - Perl 6 中的命题组合</h2>
<div class="sectionbody">
<div class="paragraph">
<p>来临是一个激动人心的时刻，是一个期待的时刻。不仅对我们人类而言 - 正是精灵变得最具创造力的时候。今天，我想在圣诞节压力下休闲一些时间来报道礼品包装领域正在开展的一些开创性工作。即使你没有预料到任何消息，这份报告仍然可以帮助你改进你的技术，因为 - 我不必提醒你 - 圣诞节快到了。</p>
</div>
<div class="paragraph">
<p>你知道哪个小孩子最喜欢吗？大礼物。因此，Northpole的现有扩大研究实验室的任务是寻找实用的方法来扩大礼物。现在，“大”可能意味着多种事物。我承认，第6单元弯曲的意思了一点，但他们的工作是迄今为止最有趣的：他们增加了<strong>音量</strong>的礼物，通过增加的礼品盒的尺寸。</p>
</div>
<div class="paragraph">
<p>“你如何包装6维礼物？”是管理层提出的有效问题。就好像天才击中了UX精灵的回应：«只需将它包裹起来，从每个三维视角看起来都像是一个正常的礼物»（他们实际上从<a href="https://gaussoids.de/">高斯</a>中学到了一个技巧，但谁也不想被视为天才偶尔？）。管理层感到满意，资金安全，数学精灵喜欢UX精灵提出的复杂性降低 - 只是制造技术还没有到那里生产那些高维盒子。因此他们决定在Perl 6中进行编程，因为在等待技术赶上100年语言时，最好使用什么？</p>
</div>
<div class="paragraph">
<p>“让我们开始工作，”他们说，并且他们得到了工作。</p>
</div>
</div>
</div>
<h1 id="_你如何以数学方式包装礼物" class="sect0">你如何以数学方式包装礼物？</h1>
<div class="openblock partintro">
<div class="content">
我在实验室逗留期间真正带回家的是，只有很多社会可接受或物理上可能的方式来包装礼物。首先，你需要一个礼物，然后一个盒子。你必须把礼品包装在盒子周围。这些步骤非常自然，精灵认为这是理所当然的。对于他们来说，“礼物”是礼品包装盒内的礼物。“包装”的挑战，以及将包装工与艺术大师分开的关键点，就是<strong>丝带</strong>和<strong>蝴蝶结</strong>发挥作用。你认为这应该够容易吗？好吧，再想一想！
</div>
</div>
<div class="sect2">
<h3 id="_一个立方体卡罗尔">.1. 一个立方体卡罗尔</h3>
<div class="paragraph">
<p>此设置中的礼物由<a href="https://en.wikipedia.org/wiki/Hypercube">n维立方体</a>建模，或简称为“n立方体”。n-cube是一个非常好的东西，因为它的所有面都是较小尺寸的立方体。计算机科学家喜欢它，因为它的顶点实际上只是长度为n 的`0`s和`1`s的串。在这里，我们关心n立方体的二维面或“正方形”。通常的三维立方体有六个正方形，正如你从骰子中所知道的那样。</p>
</div>
<div class="paragraph">
<p>精灵采取的方法将这些方块视为变量并分配给它们</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>没有</strong>如果的礼品盒，这部分上有唯一的礼品包装，因为我们同意需要，</p>
</li>
<li>
<p><strong>色带</strong>，如果有两端礼品丝带运行，或</p>
</li>
<li>
<p><strong>弓</strong>如果在立方体的这一侧弓或循环。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>是时候看一些代码了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-cm">#|« A square on the n-cube with wrapping.</span>
<span class="tok-cm">In the n-cube there are 3*(n choose 2)*2**(n-2) WrapSquare variables,</span>
<span class="tok-cm">one for every square and every kind of value that can be assigned to it.</span>
<span class="tok-cm">»</span>
<span class="tok-k">class</span> <span class="tok-n">WrapSquare</span> <span class="tok-k">is</span> <span class="tok-n">Cube::Face</span> <span class="tok-nb">does</span> <span class="tok-n">Propositional::Variable</span> {
    <span class="tok-k">has</span> <span class="tok-nv">$.kind</span> <span class="tok-k">is</span> <span class="tok-k">required</span>;

    <span class="tok-k">method</span> <span class="tok-nb">WHICH</span> {
        <span class="tok-n">ValueObjAt</span>.<span class="tok-n">new:</span> <span class="tok-s">&quot;WrapSquare|$!kind|{callsame}&quot;</span>
    }

    <span class="tok-c1"># ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此片段告诉您这`WrapSquare`是多维数据集的一个面，其中`Cube::Face`该类实现了我们期望从多维数据集表面执行的大部分功能。它也是一种变量，并且具有一个`$.kind`属性，该属性将保存字符串`□<code>，</code>■<code>或者</code>!<a href="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/1f380.svg">🎀</a>`，取决于为该正方形分配了哪个值（<strong>没有</strong>，<strong>功能区</strong>或<strong>弓形</strong>）。</p>
</div>
<div class="paragraph">
<p>有一些整洁的运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-n">prefix:</span> (<span class="tok-nb">Str</span> <span class="tok-nv">$s</span>) {
    <span class="tok-n">WrapSquare</span>.<span class="tok-n">new:</span> :<span class="tok-n">kind</span><span class="tok-s">&lt;□&gt;,</span>
<span class="tok-s">        Cube::Face.from-word($s)</span>
<span class="tok-s">}</span>

<span class="tok-s">multi prefix: (Str $s) {</span>
<span class="tok-s">    WrapSquare.new: :kind&lt;■&gt;</span>,
        <span class="tok-n">Cube::Face</span>.<span class="tok-n">from-word</span>(<span class="tok-nv">$s</span>)
}

<span class="tok-k">multi</span> <span class="tok-n">prefix:</span> (<span class="tok-nb">Str</span> <span class="tok-nv">$s</span>) {
    <span class="tok-n">WrapSquare</span>.<span class="tok-n">new:</span> :<span class="tok-n">kind</span><span class="tok-s">&lt;🎀&gt;</span>,
        <span class="tok-n">Cube::Face</span>.<span class="tok-n">from-word</span>(<span class="tok-nv">$s</span>)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这让你`WrapSquare`通过写作来制作`■&lt;0<strong>010&gt;`。该字符串`0</strong>010`指定6维立方体中的正方形：让其中的`*<code>符号为通配符，它们在`0`和之间变化`1</code>。然后你得到四个二进制字符串`000010`，<code>001010</code>，<code>010010`和`011010</code>。回想一下，长度为n（这里n = 6）的二进制字符串是n-cube的顶点，这四个碰巧绑定了它的二维面。这些`WrapSquare`文字将在以后全部出现。</p>
</div>
<div class="paragraph">
<p>经过所有这些解释后`WrapSquare`，我几乎可以听到你心中想要满足的痒：“为什么会这样`WrapSquare` <code>Variable</code> <code>Propositional</code>？”</p>
</div>
</div>
<div class="sect2">
<h3 id="_sat_a_clause的令人满意的故事">.2. SAT-a-Clause的令人满意的故事</h3>
<div class="paragraph">
<p>回想一下UX精灵的建议是：«只需将其包裹起来，从每个三维视角看起来都像一个正常的礼物»。虽然这听起来非常简单，但它会产生一个非常复杂的问题。</p>
</div>
<div class="paragraph">
<p>“有多少种方式来包装n维礼物？”可能是精灵们问自己的第一个问题。UX精灵要我们做的是选择一个合适的三维包装，其中精灵已经是专家，对于n立方体表面上的每个三维立方体，<strong>但是</strong>所有这些三维包装都适合在高维立方体。n立方体有½n⋅（n-1）⋅2ⁿ-2平方但是通过选择3d包裹，你可以选择½n⋅（n-1）⋅（n-2）⋅2ⁿ-2平方，这是（n -2）你有变量的选择次数。原因是3立方体在n立方体中彼此共享正方形，就像在3维中一样，骰子的侧面具有共同的立方体边缘。</p>
</div>
<div class="paragraph">
<p>UX精灵创建的问题是为n-cube上的3-cube选择3d包装，只要它们具有公共方形，它们就彼此兼容。但这真的有多糟糕？在尺寸4中，您有24个正方形，因此3²= 282,429,536,481种选择包装的方式。如果您是随机进行的，那么您找到UX认可包装的机会甚至不是0.0000007％。正如我们将要看到的那样，正好有1848个正确的包装。</p>
</div>
<div class="paragraph">
<p>“我们怎么可能探索这样一个巨大的空间？” - 精灵们感到震惊。直到他们发现SAT求解器。`SAT`指的是<a href="https://en.wikipedia.org/wiki/Propositional_calculus">命题</a> <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">满足性问题</a>，决定使用布尔变量和运算的公式是否具有使公式成立的赋值，“满足”它的任务。</p>
</div>
<div class="paragraph">
<p>事实证明，礼品包装可以变成这种可满足性问题的一个例子。为简单起见，精灵决定为n-cube的每个方块分配三个布尔变量。他们主张这个广场是否装饰有□，■或🎀。这些变量中的一个必须是真的。然后，他们编码要求，每个3立方体必须包含一个适当的3d包装，并且所选择的包装在n立方体中兼容为命题公式。他们把这个公式的成分称为*giftoid公理* - 包装高维礼品的规则。</p>
</div>
<div class="paragraph">
<p>有些求解器比找到一个令人满意的任务更进一步（或确定找不到一个任务的不可能性）：他们可以返回这些任务的确切数量，甚至可以列出所有这些任务。正是精灵需要的东西，幸运的是，Perl 6可以使用命题演算和SAT求解器。</p>
</div>
<div class="paragraph">
<p>SAT求解器的输入是<a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">Conjunctive Normal Form中</a>的布尔公式。该`Propositional`模块有一个特别好的实现，虽然我可能有偏见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">method</span> <span class="tok-n">NNF</span> {
    <span class="tok-k">self</span>.<span class="tok-n">rewrite</span>(
        (  ^:<span class="tok-n">p</span> ⇔ ^:<span class="tok-s">q ) =&gt; { ($:p ⇒  $:q)</span> ∧ (<span class="tok-nv">$:q</span> ⇒ <span class="tok-nv">$:p</span>) },
        (  ^:<span class="tok-n">p</span> ⇒ ^:<span class="tok-s">q ) =&gt; { ¬$:p ∨  $:q },</span>
<span class="tok-s">        (¬(^:p ∨ ^:q)</span>) =&gt; { ¬<span class="tok-nv">$:p</span> ∧ ¬<span class="tok-nv">$:q</span> },
        (¬(^:<span class="tok-n">p</span> ∧ ^:<span class="tok-s">q)) =&gt; { ¬$:p ∨ ¬$:q },</span>
<span class="tok-s">        (¬¬^:p)        =&gt; {  $:p        },</span>
<span class="tok-s">    )</span>
<span class="tok-s">    andthen .squish</span>
<span class="tok-s">}</span>

<span class="tok-s">method CNF {</span>
<span class="tok-s">    self.NNF.rewrite(</span>
<span class="tok-s">        (^:p ∨ (^:q ∧ ^:r))</span> =&gt; { (<span class="tok-nv">$:p</span> ∨ <span class="tok-nv">$:q</span>) ∧ (<span class="tok-nv">$:p</span> ∨ <span class="tok-nv">$:r</span>) },
        ((^:<span class="tok-s">q ∧ ^:r) ∨ ^:p) =&gt; { ($:p ∨ $:q) ∧</span> (<span class="tok-nv">$:p</span> ∨ <span class="tok-nv">$:r</span>) },
    )
    <span class="tok-o">andthen</span> .<span class="tok-n">squish</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该`CNF`方法首先将公式转换为中间形式，称为<a href="https://en.wikipedia.org/wiki/Negation_normal_form">否定范式</a>，然后将其转换为CNF。这两种方法都使用模块的中心齿轮之一，该`rewrite`方法。顾名思义，它重写了一个基于规则的公式，这些规则作为成对给出，例如`(^:p ⇔ ^:q ) &#8658; { ($:p ⇒ $:q) ∧ ($:q ⇒ $:p) }`。关键是一个公式对象，这里只是`⇔<code>两个变量的等价，</code><sup>:p`并且`</sup>:q`在整个公式内是模式匹配的。“限量印记”，在变量前面表明上的两侧发现子式`⇔<code>操作应当<strong>帽</strong>捕获的原始内部<a href="https://docs.perl6.org/language/variables#index-entry-%24%3A">命名参数</a> `p`和`q`它们被传递到对fatarrow右侧的代码块，以确定</code>⇔<code>表达式的替换是什么。在这种情况下，等价被两个含义所取代 - 这个重写规则实现了定义</code>⇔<code>。上面的下一条规则实现了</code>⇒`。的定义。实际上，如果你想要一个NNF，必须消除这两个符号。</p>
</div>
<div class="paragraph">
<p>重写引擎执行所有列出的重写，直到找不到更多匹配项。现在，逻辑学家会告诉你，如果你这样做，你会将任何命题公式变成CNF。这应该足够内部。让我们公理化礼物吧！</p>
</div>
</div>
<div class="sect2">
<h3 id="_比你想知道的3d礼品包装更多">.3. 比你想知道的3D礼品包装更多</h3>
<div class="paragraph">
<p>看到所有的高级成分落到实处，每个人都兴奋不已，我不得不停下来问：«基本情况怎么样？你如何包装3D礼物？»。问这个精灵和他们的眼睛开始发光。这是他们的第二天性，甚至是研究精灵。这些是每个精灵在学校学到的规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>只是包装：</strong>没有丝带或蝴蝶结的礼物是好的，但永远不要忘记礼品包装，</p>
</li>
<li>
<p><strong>胶合弓：</strong>它可以有一个单面粘在一边，没有色带，</p>
</li>
<li>
<p><strong>色带：</strong>如果你使用色带，你必须把它包在盒子周围的“腰带”上，</p>
</li>
<li>
<p><strong>蝴蝶结腰带：</strong>你可以将蝴蝶结融入蝴蝶结腰带，</p>
</li>
<li>
<p><strong>一个弓：</strong>你可能只使用一个弓或没有，</p>
</li>
<li>
<p><strong>消歧：</strong>如果所有方面都有缎带，就必须有弓。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后一个公理与其他公理不同。它不是小学包装表的一部分，后来被致力于高维包装的精灵们发现。（也许有一天会进入课程？）在谈论色带时，“立方体的方块”公式是一种简化，因为有两种方法可以将色带垂直或水平地包裹在立方体的给定方格中。在只有一条皮带的情况下，带状皮带公制用于定义色带的方向。类似地，实际上有三种方法可以围绕立方体包裹色带，这样所有方法都会导致每个边都被色带触摸，即每种方式都可以从三个方向中挑选出两个带。因此，立方体的这种“包裹”是模糊的，必须禁止。</p>
</div>
<div class="paragraph">
<p>该`Propositional`包可以采取不将任何对象`Propositional::Variable`作为式中的变量的作用。如上所示，通常的逻辑连接符被重载，因此您可以在Perl 6程序中编写公式，就像在纸上一样。仅要求变量角色是一个重要的设计决策，并具有一些巧妙的含义。例如，重写捕获`^:p`我们之前看到的，也是`Propositional::Variable`在智能匹配时特别表现的对象。</p>
</div>
<div class="paragraph">
<p>在精灵的情况下，`Variable`是`WrapSquare`类和允许任意对象作为变量的另一个优点显示自己：任意变量可以有任意方法或操作符作用于它们。精灵用它来完成另一个*复杂性的减少*。他们只需要对3立方体的<strong>一个角</strong>进行公理化，然后使用3立方体的<a href="https://en.wikipedia.org/wiki/Hyperoctahedral_group">对称组进行处理</a>。这个群体动作将公理化的角落移动到立方体的<strong>每个</strong>角落，因此连接该动作的轨道给出了3d礼品包装的完全公理化。现在我们同意这听起来很棒，让我们看看它是如何在Perl 6中完成的。（*注意：*公理化涉及<a href="https://en.wikipedia.org/wiki/Logical_connective">逻辑连接词</a>你可能想要熟悉并遵循上面人类可读的公理。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-n">axioms</span> (<span class="tok-nv">$n</span> = <span class="tok-mi">3</span>) {
    <span class="tok-k">my</span> \<span class="tok-n">φ</span> = .<span class="tok-n">CNF</span> <span class="tok-n">with</span> [∧] <span class="tok-k">gather</span> {
        <span class="tok-k">take</span> □<span class="tok-s">&lt;**0&gt;</span> ∨ ■<span class="tok-s">&lt;**0&gt;</span> ∨ 🎀<span class="tok-s">&lt;**0&gt;</span>;
        <span class="tok-k">take</span> □<span class="tok-s">&lt;**0&gt;</span> ⇒ ¬(■<span class="tok-s">&lt;**0&gt;</span> ∨ 🎀<span class="tok-s">&lt;**0&gt;</span>);
        <span class="tok-k">take</span> ■<span class="tok-s">&lt;**0&gt;</span> ⇒ ¬(□<span class="tok-s">&lt;**0&gt;</span> ∨ 🎀<span class="tok-s">&lt;**0&gt;</span>);
        <span class="tok-k">take</span> 🎀<span class="tok-s">&lt;**0&gt;</span> ⇒ ¬(□<span class="tok-s">&lt;**0&gt;</span> ∨ ■<span class="tok-s">&lt;**0&gt;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们选择二维面`<strong>0`作为公理化的特定角落。有三个关联布尔变量，即`□&lt;</strong>0&gt;`，<code>■&lt;<strong>0&gt;`和</code>!<a href="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/1f380.svg">🎀</a>&lt;</strong>0&gt;`（方便，他们也可以被称为是在Perl 6的代码，这要归功于我们的`WrapSquare`构造函数运算符）。要具有明确定义的包装，必须至少设置这三个变量中的一个。</p>
</div>
<div class="paragraph">
<p>公理说必须设置三个变量*中的至少*一个。下一个公理规则如果碰巧是活跃的（意味着广场上只有礼品包装），那么（）它也不能（）是真的，或者（）也被设置。任何令人满意的任务，即SAT求解器将为我们找到的最终公式将实现这个公理，因为我们采取了一个大的AND超过块。</p>
</div>
<div class="paragraph">
<p>您被邀请将其他公式追溯到包装表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>        <span class="tok-k">take</span> ■<span class="tok-s">&lt;**0&gt;</span> ⇒ (■<span class="tok-s">&lt;**1&gt;</span> ∨ 🎀<span class="tok-s">&lt;**1&gt;</span>);
        <span class="tok-k">take</span> (■<span class="tok-s">&lt;**0&gt;</span> ∧ ■<span class="tok-s">&lt;**1&gt;</span>) ⇒ (■<span class="tok-s">&lt;*0*&gt;</span> ∨ 🎀<span class="tok-s">&lt;*0*&gt;</span> ∨ ■<span class="tok-s">&lt;0**&gt;</span> ∨ 🎀<span class="tok-s">&lt;0**&gt;</span>);
        <span class="tok-k">take</span> (🎀<span class="tok-s">&lt;**0&gt;</span> ∧ ■<span class="tok-s">&lt;**1&gt;</span>) ⇒ (■<span class="tok-s">&lt;*0*&gt;</span> ∨ ■<span class="tok-s">&lt;0**&gt;</span>);
        <span class="tok-k">take</span> (🎀<span class="tok-s">&lt;**0&gt;</span> ∧ (■<span class="tok-s">&lt;*0*&gt;</span> ∨ ■<span class="tok-s">&lt;0**&gt;</span>)) ⇒ ■<span class="tok-s">&lt;**1&gt;</span>;
        <span class="tok-k">take</span> 🎀<span class="tok-s">&lt;**0&gt;</span> ⇒ ¬(🎀<span class="tok-s">&lt;**1&gt;</span> ∨ 🎀<span class="tok-s">&lt;*0*&gt;</span> ∨ 🎀<span class="tok-s">&lt;*1*&gt;</span> ∨ 🎀<span class="tok-s">&lt;0**&gt;</span> ∨ 🎀<span class="tok-s">&lt;1**&gt;</span>);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们对3立方体的一个角进行了公理化，我们采用了超八面体组。这可以通过所谓的二元性的组合来实现，该二元性是`&amp;postfix:&lt;°&gt;`操作者实现的`Cube::Face`，并且`&amp;infix:&lt;⤩&gt;`操作者存在的立方体的轴的排列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">my</span> \<span class="tok-n">ψ</span> = <span class="tok-n">φ</span>.<span class="tok-n">rewrite</span>(:<span class="tok-mi">1</span><span class="tok-n">ce</span>,
        (^:<span class="tok-o">s</span>(<span class="tok-n">WrapSquare</span>)) =&gt; { <span class="tok-nv">$:s</span>° }
    );
    <span class="tok-k">return</span> [∧] <span class="tok-k">gather</span> <span class="tok-k">for</span> (<span class="tok-mi">1</span>,<span class="tok-mi">2</span>,<span class="tok-mi">3</span>).<span class="tok-n">permutations</span> -&gt; \<span class="tok-n">π</span> {
        <span class="tok-k">take</span> (<span class="tok-n">φ</span> ∧ <span class="tok-n">ψ</span>).<span class="tok-n">rewrite</span>(:<span class="tok-mi">1</span><span class="tok-n">ce</span>,
            (^:<span class="tok-o">s</span>(<span class="tok-n">WrapSquare</span>)) =&gt; { <span class="tok-nv">$:s</span> ⤩ <span class="tok-n">π</span> }
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个`rewrite`方法再次闪耀在这里。捕获变量可以使用smartmatcher进行约束，例如类型`WrapSquare`。它们只匹配并捕获匹配约束的内容。因此，上述重写规则仅对公式中的变量起作用，并且它们只执行它`:1ce`- 因为否则重写引擎会一遍又一遍地重写相同的变量，因为它们在每次迭代中都会重新匹配。</p>
</div>
<div class="paragraph">
<p>你注意到了什么吗？看起来精灵们忘记了消歧公理。但是 - 它没有被遗忘。它已经是对称的，不必参与上面的对称化过程。如果确实如此，就会不必要地重复。它来了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>        <span class="tok-k">LAST</span> <span class="tok-k">take</span> ¬(■<span class="tok-s">&lt;**0&gt;</span> ∧ ■<span class="tok-s">&lt;**1&gt;</span> ∧ ■<span class="tok-s">&lt;*0*&gt;</span> ∧ ■<span class="tok-s">&lt;*1*&gt;</span> ∧ ■<span class="tok-s">&lt;0**&gt;</span> ∧ ■<span class="tok-s">&lt;1**&gt;</span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，三维礼品包装公理是完整的。精灵们兴高采烈地跳舞。</p>
</div>
</div>
<h1 id="_把它包起来_2" class="sect0">把它包起来</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>让我们总结一下。为了包装更高维度的礼物，我们将三维礼物包裹起来并将包装拼凑在一起。为了使三维包裹物公理化，在其一个角落周围进行公理化并转动立方体并重复该过程就足够了，因此立方体的每个角落都是一个公理化的角落。这给出了描述所有正确包装的布尔公式。</p>
</div>
<div class="paragraph">
<p>但是，嘿，我们还没完成！giftoids和SAT求解器在哪里？为了使n-giftoids公理化，上面构造的3立方公理化必须在n立方体的每个3面复制。另一个`Cube::Face`操作员出现在这里，再次出现在`rewrite`。它将一个正方形嵌入到n立方体的三个面中，正如我们所需要的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">multi</span> <span class="tok-n">axioms</span> (<span class="tok-nv">$n</span> <span class="tok-k">where</span> * &gt; <span class="tok-mi">3</span>) {
    <span class="tok-k">my</span> \<span class="tok-n">Φ</span> = <span class="tok-n">axioms</span>;
    [∧] <span class="tok-k">gather</span> <span class="tok-k">for</span> <span class="tok-n">Faces</span>(<span class="tok-nv">$n</span>, <span class="tok-mi">3</span>) -&gt; \<span class="tok-n">Δ</span> {
        <span class="tok-k">take</span> <span class="tok-n">Φ</span>.<span class="tok-n">rewrite</span>(:<span class="tok-mi">1</span><span class="tok-n">ce</span>,
            (^:<span class="tok-o">s</span>(<span class="tok-n">WrapSquare</span>)) =&gt; { <span class="tok-nv">$:s</span> ↗ <span class="tok-n">Δ</span> }
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用SAT工具`Propositional`，我们现在可以获得3-4G和5-Giftoids的实数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-n">count-sat</span> <span class="tok-n">Giftoid::axioms</span>(<span class="tok-mi">3</span>), :<span class="tok-n">now</span>
<span class="tok-c1">#= OUTPUT: 28</span>
<span class="tok-nb">say</span> <span class="tok-n">count-sat</span>(<span class="tok-n">Giftoid::axioms</span>(<span class="tok-mi">3</span>), :<span class="tok-n">now</span>)
<span class="tok-c1">#= OUTPUT: 1848</span>
<span class="tok-nb">say</span>  <span class="tok-n">count-sat</span>(<span class="tok-n">Giftoid::axioms</span>(<span class="tok-mi">3</span>), :<span class="tok-n">now</span>)
<span class="tok-c1">#= OUTPUT: 58213276</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了感受SAT求解者所做的惊人工作，考虑到它`28`在729种可能性中找到了3-giftoids 的数量，`1848`在282429536481种可能性中找到了4-giftoids的数量，以及可能`58213276`总共为147808829414345923316083210206383297601可能性的5-giftoids。</p>
</div>
<div class="paragraph">
<p>当你自己尝试上面的代码示例时，你应该知道的是SAT求解器，特别是计数器，是非常需要内存的。5-giftoid计数需要5:14处理器分钟，笔记本电脑上有4 GiB RAM，不是没有交换，但它可以在笔记本电脑上完成！大多数求解器允许限制时间和内存使用，但Perl 6模块中尚未实现求解器配置。</p>
</div>
<div class="paragraph">
<p>绝对可行的是获得一个3-giftoids列表，其中3-cube的所有六个方块的赋值按特定顺序列出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>.<span class="tok-n">put</span> <span class="tok-k">for</span> <span class="tok-n">all-sat</span>(<span class="tok-n">Giftoid::axioms</span>).<span class="tok-nb">map</span>({ <span class="tok-n">Giftoid</span>.<span class="tok-n">new:</span> <span class="tok-n">n</span> =&gt; <span class="tok-mi">3</span>, <span class="tok-n">deco</span> =&gt; <span class="tok-nv">$_</span> })
<span class="tok-cm">#=« OUTPUT:</span>
<span class="tok-cm">■■■🎀■■</span>
<span class="tok-cm">□□■🎀■■</span>
<span class="tok-cm">■■■■🎀■</span>
<span class="tok-cm">■■■■■🎀</span>
<span class="tok-cm">■■🎀■■■</span>
<span class="tok-cm">■🎀■■■■</span>
<span class="tok-cm">□□■■🎀■</span>
<span class="tok-cm">□□🎀■■■</span>
<span class="tok-cm">□□■■■🎀</span>
<span class="tok-cm">□□■■■■</span>
<span class="tok-cm">■■□□■🎀</span>
<span class="tok-cm">■■□□🎀■</span>
<span class="tok-cm">...</span>
<span class="tok-cm">»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者确定固定维度的giftoids中的平均弓箭数，尽管你不会对这些弓箭走得太远：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">mean-bows</span> (<span class="tok-nv">$n</span>) {
    <span class="tok-k">my</span> (<span class="tok-nv">$sum</span>, <span class="tok-nv">$count</span>);
    <span class="tok-n">all-sat</span>(<span class="tok-n">Giftoid::axioms</span>(<span class="tok-nv">$n</span>)).<span class="tok-nb">map</span>({
        <span class="tok-nv">$sum</span> += +.<span class="tok-nb">keys</span>.<span class="tok-nb">grep</span>(*.<span class="tok-n">kind</span> <span class="tok-o">eq</span> <span class="tok-s">&lt;🎀&gt;</span>);
        <span class="tok-nv">$count</span>++;
    });
    <span class="tok-nv">$sum</span> / <span class="tok-nv">$count</span>;
}

<span class="tok-nb">say</span> <span class="tok-n">mean-bows</span>(<span class="tok-mi">3</span>);
<span class="tok-c1">#= OUTPUT: 0.857143</span>
<span class="tok-nb">say</span> <span class="tok-n">mean-bows</span>(<span class="tok-mi">4</span>);
<span class="tok-c1">#= OUTPUT: 2.766234</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>预算精灵谨慎地提出一个问题：«如果你任意增加giftoids的维度，这是否意味着保持有限？毕竟，弓是最昂贵的&#8230;&#8203;&#8230;&#8203;»</p>
</div>
<div class="paragraph">
<p>我会让你在假期里思考这个问题。快乐的包装。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_一个红色的圣诞老人">43. 第二十一天 - 一个红色的圣诞老人</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这一年即将结束，我们有很多值得庆祝的事情！与家人和朋友相比，庆祝今年年底更好的方式是什么？为了帮助实现这一目标，在我家，我们决定开办秘密圣诞老人游戏！所以，我的目标是写一个秘密圣诞老人计划！这就是我可以使用这个名为<a href="https://github.com/FCO/Red">Red的</a>精彩项目的地方。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red">Red</a>是一个仍在开发中的<strong>perl6</strong>的*ORM* （对象关系模型），尚未作为模块发布。但它正在增长，而且接近发布。</p>
</div>
<div class="paragraph">
<p>因此，让我们创建我们的第一张桌子：一张桌子，用于存储参与我们的秘密圣诞老人的人。代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Red</span>;

<span class="tok-n">model</span> <span class="tok-n">Person</span> {
   <span class="tok-k">has</span> <span class="tok-nb">UInt</span>     <span class="tok-nv">$.id</span>        <span class="tok-k">is</span> <span class="tok-n">serial</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.name</span>      <span class="tok-k">is</span> <span class="tok-n">column</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.email</span>     <span class="tok-k">is</span> <span class="tok-n">column</span>{ :<span class="tok-n">nullable</span> };
}

<span class="tok-k">my</span> <span class="tok-vg">$*RED-DB</span> = <span class="tok-n">database</span> <span class="tok-s">&quot;SQLite&quot;</span>;

<span class="tok-n">Person</span>.^<span class="tok-n">create-table</span>;

<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernando&gt;</span>,    :<span class="tok-n">email</span><span class="tok-s">&lt;fco@aco.com&gt;</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Aline&gt;</span>,       :<span class="tok-n">email</span><span class="tok-s">&lt;aja@aco.com&gt;</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernanda&gt;</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Sophia&gt;</span>;

.<span class="tok-nb">say</span> <span class="tok-k">for</span> <span class="tok-n">Person</span>.^<span class="tok-nb">all</span>.<span class="tok-nb">grep</span>(*.<span class="tok-n">email</span>.<span class="tok-nb">defined</span>).<span class="tok-n">map:</span> *.<span class="tok-nb">name</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://github.com/FCO/Red">Red</a>将<strong>关系数据库</strong>映射  到<strong>OOP</strong>。每个表都映射到一个  <a href="https://github.com/FCO/Red"><strong>Red</strong></a>类（<strong>模型</strong>），每个表的  <strong>对象*代表*一行</strong>。</p>
</div>
<div class="paragraph">
<p>我们创建*模型的方式*是使用<strong>模型</strong>特殊单词。一个*模型*仅仅是延伸的正常类<strong>红::型号</strong> ，具有<strong>MetamodelX ::红::型号</strong>的对象作为它的  <strong>元类</strong>。 <a href="https://github.com/FCO/Red"><strong>Red</strong></a>不会向您的模型添加任何未明确创建的方法。因此，要与*数据库*进行交互，您应该使用*元类*。</p>
</div>
<div class="paragraph">
<p>但是让我们继续吧。</p>
</div>
<div class="paragraph">
<p>代码创建一个名为  <strong>Person*的新*模型</strong>。此*模型*表示的*表*的名称将与模型名称相同：“Person”。如有必要，您可以使用特征更改表的名称 （例如  <strong>:)</strong>。<code>is table&lt;&#8230;&#8203;&gt;</code> <code>model Person is table&lt;another_name&gt; {&#8230;&#8203;}</code></p>
</div>
<div class="paragraph">
<p>该*模型*有3个*属性*：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>$ .name</strong>有一个  <code>is column</code> <strong>特征</strong> ;</p>
</li>
<li>
<p><strong>$ .email</strong>有  <code>is column{ :nullable }</code>;</p>
</li>
<li>
<p>和<strong>$ .id</strong>有一个  <code>is serial</code>。这意味着同样的`is column{ :id, :auto-increment }`。</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red"><strong>Red</strong></a>默认 使用*非空*列，因此如果要创建可以为空的列，则应使用 <code>is column{ :nullable }</code>。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因此*Person*上的所有属性都是*列*。在`is serial`（我指的是  <code>:id</code> 一部分）意味着它是表的主键。</p>
</div>
<div class="paragraph">
<p>之后，它为结果设置*动态变量*（<code>$*RED-DB</code>）<code>database "SQLite"</code>。该<strong>数据库</strong> *子*收到*司机*的名字和它期望的参数。</p>
</div>
<div class="paragraph">
<p>在这种情况下，它使用*SQLite*  驱动程序，如果您不传递任何参数，它将使用它作为  <strong>内存</strong> <strong>数据库</strong>。如果要使用名为*secret-santa.db*  的文件作为数据库文件，则可以执行此操作`database "SQLite", :database&lt;secret-santa.db&gt;`。或者，如果您想使用本地*Postgres*，只需使用   <code>database "Pg"</code>。 <a href="https://github.com/FCO/Red"><strong>Red</strong></a>  使用变量  <code>$*RED-DB</code> 来知道要使用的数据库。</p>
</div>
<div class="paragraph">
<p>好的，现在让我们创建*表*！正如我之前所说，<a href="https://github.com/FCO/Red"><strong>红</strong></a>没有添加任何*方法*你没有明确要求。因此，要创建*表，<strong>使用*元类</strong> ' <strong>方法</strong>。`Person.^create-table`是你如何创建*表*。</p>
</div>
<div class="paragraph">
<p>这将运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">CREATE</span> <span class="tok-n">TABLE</span> <span class="tok-n">person</span>(
    <span class="tok-n">id</span> <span class="tok-n">integer</span> <span class="tok-n">NOT</span> <span class="tok-n">NULL</span> <span class="tok-n">primary</span> <span class="tok-nb">key</span> <span class="tok-n">AUTOINCREMENT</span>,
    <span class="tok-nb">name</span> <span class="tok-n">varchar</span>(<span class="tok-mi">255</span>) <span class="tok-n">NOT</span> <span class="tok-n">NULL</span>,
    <span class="tok-n">email</span> <span class="tok-n">varchar</span>(<span class="tok-mi">255</span>) <span class="tok-n">NULL</span>
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们应该插入一些数据。我们用另一个*meta方法*（<code>.^create</code>）来做到这一点。该  <code>.^create</code> <strong>元方法*预期相同*参数</strong> <code>.new</code>  的期望。每个*命名参数*都将设置一个具有相同名称的  <strong>属性</strong>。 <code>.^create`将创建一个新的*Person*对象，将其保存在  <strong>数据库中</strong>（with `.^save: :insert</code>），然后返回它。</p>
</div>
<div class="paragraph">
<p>它运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">INSERT</span> <span class="tok-n">INTO</span> <span class="tok-n">person</span>(
    <span class="tok-n">email</span>,
    <span class="tok-nb">name</span>
) <span class="tok-n">VALUES</span>(
    <span class="tok-s">&#39;fco@aco.com&#39;</span>,
    <span class="tok-s">&#39;Fernando&#39;</span>
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个*模型*都有一个*ResultSeq*。这是代表每一个序列*行*的*表*。我们可以 用（或）得到它的*ResultSeq*。<strong>ResultSeq*有一些方法可以帮助您从*表中*获取信息，例如：  将过滤*行</strong>（就像在普通*Seq中一样*），但它不会在内存中执行此操作，它会返回带有该过滤器集的新  <strong>ResultSeq</strong>。检索其*迭代器时*，它使用*ResultSeq*上设置的所有内容运行<strong>SQL</strong>查询  。<code>.<sup>all<code>.</sup>rs</code>.grep</code></p>
</div>
<div class="paragraph">
<p>在我们的示例中，`Person.^all.grep(*.email.defined).map: *.name`将运行如下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">SELECT</span>
    <span class="tok-n">person</span>.<span class="tok-nb">name</span>
<span class="tok-n">FROM</span>
    <span class="tok-n">person</span>
<span class="tok-nb">WHERE</span>
    <span class="tok-n">email</span> <span class="tok-n">IS</span> <span class="tok-n">NOT</span> <span class="tok-n">NULL</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它会打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Fernando</span>
<span class="tok-n">Aline</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，我们有一个代码可以保存谁进入我们的秘密圣诞老人游戏。但每个人都想要不同的礼物。我们怎么知道每个人的意愿？</p>
</div>
<div class="paragraph">
<p>让我们修改代码，使其为参与秘密圣诞老人的每个人保存心愿单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Red</span>;

<span class="tok-n">model</span> <span class="tok-n">Person</span> { ... }

<span class="tok-n">model</span> <span class="tok-n">Wishlist</span> {
    <span class="tok-k">has</span> <span class="tok-nb">UInt</span>    <span class="tok-nv">$!id</span>        <span class="tok-k">is</span> <span class="tok-n">serial</span>;
    <span class="tok-k">has</span> <span class="tok-nb">UInt</span>    <span class="tok-nv">$!wisher-id</span> <span class="tok-k">is</span> <span class="tok-n">referencing</span>{ <span class="tok-n">Person</span>.<span class="tok-n">id</span> };
    <span class="tok-k">has</span> <span class="tok-n">Person</span>  <span class="tok-nv">$.wisher</span>    <span class="tok-k">is</span> <span class="tok-n">relationship</span>{ .<span class="tok-n">wisher-id</span> };
    <span class="tok-k">has</span> <span class="tok-nb">Str:D</span>   <span class="tok-nv">$.name</span>      <span class="tok-k">is</span> <span class="tok-n">column</span> <span class="tok-k">is</span> <span class="tok-k">required</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span>     <span class="tok-nv">$.link</span>      <span class="tok-k">is</span> <span class="tok-n">column</span>;
}

<span class="tok-n">model</span> <span class="tok-n">Person</span> <span class="tok-k">is</span> <span class="tok-k">rw</span> {
   <span class="tok-k">has</span> <span class="tok-nb">UInt</span>     <span class="tok-nv">$.id</span>        <span class="tok-k">is</span> <span class="tok-n">serial</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.name</span>      <span class="tok-k">is</span> <span class="tok-n">column</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.email</span>     <span class="tok-k">is</span> <span class="tok-n">column</span>;
   <span class="tok-k">has</span> <span class="tok-n">Wishlist</span> <span class="tok-nv">@.wishes</span>    <span class="tok-k">is</span> <span class="tok-n">relationship</span>{ .<span class="tok-n">wisher-id</span> }
}

<span class="tok-k">my</span> <span class="tok-vg">$*RED-DB</span> = <span class="tok-n">database</span> <span class="tok-s">&quot;SQLite&quot;</span>;

<span class="tok-n">Wishlist</span>.^<span class="tok-n">create-table</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create-table</span>;

<span class="tok-k">my</span> \<span class="tok-n">fernando</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernando&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;fco@aco.com&gt;</span>;
<span class="tok-n">fernando</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Comma&gt;</span>,          :<span class="tok-n">link</span><span class="tok-s">&lt;https://commaide.com&gt;</span>;
<span class="tok-n">fernando</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;perl6 books&quot;</span>),  :<span class="tok-n">link</span><span class="tok-s">&lt;https://perl6book.com&gt;</span>;
<span class="tok-n">fernando</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;mac book pro&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#&gt;</span>;

<span class="tok-k">my</span> \<span class="tok-n">aline</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Aline&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;aja@aco.com&gt;</span>;
<span class="tok-n">aline</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;a new closet&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg&gt;</span>;

<span class="tok-k">my</span> \<span class="tok-n">fernanda</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernanda&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;faco@aco.com&gt;</span>;
<span class="tok-n">fernanda</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;mimikyu plush&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831&gt;</span>;
<span class="tok-n">fernanda</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;camelia plush&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg&gt;</span>;

<span class="tok-k">my</span> \<span class="tok-n">sophia</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Sophia&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;saco@aco.com&gt;</span>;
<span class="tok-n">sophia</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;baby alive&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817&gt;</span>;

<span class="tok-nb">say</span> <span class="tok-s">&quot;\n{ .name }\n{ .wishes.map({&quot;</span> { .<span class="tok-nb">name</span> } =&gt; { .<span class="tok-nb">link</span> }<span class="tok-s">&quot; }).join(&quot;</span>\<span class="tok-n">n</span><span class="tok-s">&quot;).indent: 3 }&quot;</span> <span class="tok-k">for</span> <span class="tok-n">Person</span>.^<span class="tok-nb">all</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Fernando</span>
    <span class="tok-n">Comma</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">commaide</span>.<span class="tok-n">com</span>
    <span class="tok-n">perl6</span> <span class="tok-n">books</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">perl6book</span>.<span class="tok-n">com</span>
    <span class="tok-n">mac</span> <span class="tok-n">book</span> <span class="tok-n">pro</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">www</span>.<span class="tok-n">apple</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">shop</span><span class="tok-o">/</span><span class="tok-n">buy-mac</span><span class="tok-o">/</span><span class="tok-n">macbook-pro</span><span class="tok-o">/</span><span class="tok-mi">15</span><span class="tok-o">-</span><span class="tok-n">inch-space-gray-2</span><span class="tok-mf">.6</span><span class="tok-n">ghz-6-core-512gb</span><span class="tok-c1">#</span>

<span class="tok-n">Aline</span>
    <span class="tok-n">a</span> <span class="tok-nb">new</span> <span class="tok-n">closet</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">i</span>.<span class="tok-n">pinimg</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-mi">474</span><span class="tok-n">x</span><span class="tok-o">/</span><span class="tok-mo">02</span><span class="tok-o">/</span><span class="tok-mo">05</span><span class="tok-o">/</span><span class="tok-mi">93</span><span class="tok-o">/</span><span class="tok-mo">0205</span><span class="tok-mi">93</span><span class="tok-n">b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe</span>.<span class="tok-n">jpg</span>

<span class="tok-n">Fernanda</span>
    <span class="tok-n">mimikyu</span> <span class="tok-n">plush</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">www</span>.<span class="tok-n">pokemoncenter</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">mimikyu-poké-plush-</span><span class="tok-nv">%28standard-size%29---10-701-02831</span>
    <span class="tok-n">camelia</span> <span class="tok-n">plush</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">farm9</span>.<span class="tok-n">static</span>.<span class="tok-n">flickr</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-mi">8432</span><span class="tok-o">/</span><span class="tok-mi">28947786492_80056225</span><span class="tok-n">f3_b</span>.<span class="tok-n">jpg</span>

<span class="tok-n">Sophia</span>
    <span class="tok-n">baby</span> <span class="tok-n">alive</span> =&gt; <span class="tok-n">https:</span>//<span class="tok-n">www</span>.<span class="tok-n">target</span>.<span class="tok-n">com</span><span class="tok-o">/</span><span class="tok-n">p</span><span class="tok-o">/</span><span class="tok-n">baby-alive-face-paint-fairy-brunette</span>/-/<span class="tok-n">A-51304817</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们有一个新的  <strong>模型</strong> <strong>愿望清单</strong>  ，它引用了一个名为*withlist*的表  。它  <code>$!id</code> 作为  <strong>ID</strong>，  <code>$!name</code> 并  <code>$!link</code> 为列，也有一些新的东西！ <code>has UInt $!wisher-id is referencing{ Person.id };</code> 是一样  <code>has UInt $!wisher-id is column{ :references{ Person.id } };</code> ，这意味着它是一个*列*，这是一个  <strong>外键</strong>  引用  <strong>ID</strong> <strong>的人*的*列</strong>。它也有  <code>has Person $.wisher is relationship{ .wisher-id };</code> 它<strong>不是</strong>一个*列*，这是一个“虚拟”。在  <strong>$</strong>  <strong>印记</strong>  意味着有  <strong>只有1</strong>好心人˚F <strong>或</strong>愿望。并  <code>is relationship</code> 期待一个  <strong>Callable</strong> 这将获得一个  <strong>模型</strong>。如果它是  <strong>标量</strong>  ，它将接收当前  <strong>模型</strong>  作为唯一参数。所以，在这种情况下，它将是  <strong>愿望清单</strong>。该relationsip的回报  <strong>可赎回</strong>  必须是*列*引用其他一些*列*。</p>
</div>
<div class="paragraph">
<p>让我们看看这个表是如何创建的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">CREATE</span> <span class="tok-n">TABLE</span> <span class="tok-n">wishlist</span>(
   <span class="tok-n">id</span> <span class="tok-n">integer</span> <span class="tok-n">NOT</span> <span class="tok-n">NULL</span> <span class="tok-n">primary</span> <span class="tok-nb">key</span>,
   <span class="tok-nb">name</span> <span class="tok-n">varchar</span>(<span class="tok-mi">255</span>) <span class="tok-n">NOT</span> <span class="tok-n">NULL</span>,
   <span class="tok-nb">link</span> <span class="tok-n">varchar</span>(<span class="tok-mi">255</span>) <span class="tok-n">NULL</span>,
   <span class="tok-n">wisher_id</span> <span class="tok-n">integer</span> <span class="tok-n">NULL</span> <span class="tok-n">references</span> <span class="tok-n">person</span>(<span class="tok-n">id</span>)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，没有   创建*wisher*列。</p>
</div>
<div class="paragraph">
<p>该  <strong>人</strong> <strong>模式</strong>  也发生了变化！现在它有一个  <code>@.wishes</code> <strong>关系</strong>（<code>has Wishlist @.wishes is relationship{ .wisher-id }</code>）。它使用  <strong>@</strong>  <strong>sigil，</strong>  因此每个  <strong>人</strong> 都可以拥有多个愿望。 传递的  <strong>Callable*将接收*Positional</strong> <strong>属性*的类型   （ 在此情况下为*Wishlist</strong>），并且必须返回引用其他列的列。</p>
</div>
<div class="paragraph">
<p>创建的表与以前相同。</p>
</div>
<div class="paragraph">
<p>我们之前创建了一个新的  <strong>Person</strong>  ：  <code>my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;<a href="mailto:fco@aco.com">fco@aco.com</a>&gt;;</code> 现在我们可以使用*关系*（<strong>愿望</strong>）来创建一个新的愿望（）。这为Fernando运行以下SQL创建了一个新的愿望：<code>fernando.wishes.create: :name&lt;Comma&gt;, :link<a href="https://commaide.com" class="bare">https://commaide.com</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">INSERT</span> <span class="tok-n">INTO</span> <span class="tok-n">wishlist</span>(
   <span class="tok-nb">name</span>,
   <span class="tok-nb">link</span>,
   <span class="tok-n">wisher_id</span>
) <span class="tok-n">VALUES</span>(
   <span class="tok-s">&#39;Comma&#39;</span>,
   <span class="tok-s">&#39;https://commaide.com&#39;</span>,
   <span class="tok-mi">1</span>
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你看过了吗？ <code>wisher_id</code> 是  <strong>1</strong> &#8230;&#8203; 1是费尔南多的身份。一旦你创建了Fernando的<strong>.wishes（）</strong>的愿望  ，它已经知道它属于Fernando。</p>
</div>
<div class="paragraph">
<p>然后我们为我们创造的每个人定义愿望。</p>
</div>
<div class="paragraph">
<p>然后我们遍历 数据库中的每个  <strong>Person</strong>（<code>Person.^all</code>）并打印其名称并循环该人的意愿并打印其名称和链接。</p>
</div>
<div class="paragraph">
<p>哦，我们可以拯救谁参与&#8230;&#8203;&#8230;&#8203;得到他们想要的东西&#8230;&#8203;&#8230;&#8203;但是平局？我应该送谁礼物？为此，我们再次更改程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">lib</span> <span class="tok-s">&lt;lib&gt;</span>;
<span class="tok-k">use</span> <span class="tok-n">Red</span>;

<span class="tok-n">model</span> <span class="tok-n">Person</span> { ... }

<span class="tok-n">model</span> <span class="tok-n">Wishlist</span> {
    <span class="tok-k">has</span> <span class="tok-nb">UInt</span>    <span class="tok-nv">$!id</span>        <span class="tok-k">is</span> <span class="tok-n">id</span>;
    <span class="tok-k">has</span> <span class="tok-nb">UInt</span>    <span class="tok-nv">$!wisher-id</span> <span class="tok-k">is</span> <span class="tok-n">referencing</span>{ <span class="tok-n">Person</span>.<span class="tok-n">id</span> };
    <span class="tok-k">has</span> <span class="tok-n">Person</span>  <span class="tok-nv">$.wisher</span>    <span class="tok-k">is</span> <span class="tok-n">relationship</span>{ .<span class="tok-n">wisher-id</span> };
    <span class="tok-k">has</span> <span class="tok-nb">Str:D</span>   <span class="tok-nv">$.name</span>      <span class="tok-k">is</span> <span class="tok-n">column</span> <span class="tok-k">is</span> <span class="tok-k">required</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span>     <span class="tok-nv">$.link</span>      <span class="tok-k">is</span> <span class="tok-n">column</span>;
}

<span class="tok-n">model</span> <span class="tok-n">Person</span> <span class="tok-k">is</span> <span class="tok-k">rw</span> {
   <span class="tok-k">has</span> <span class="tok-nb">UInt</span>     <span class="tok-nv">$.id</span>        <span class="tok-k">is</span> <span class="tok-n">id</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.name</span>      <span class="tok-k">is</span> <span class="tok-n">column</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.email</span>     <span class="tok-k">is</span> <span class="tok-n">column</span>;
   <span class="tok-k">has</span> <span class="tok-nb">UInt</span>     <span class="tok-nv">$!pair-id</span>   <span class="tok-k">is</span> <span class="tok-n">referencing</span>{ <span class="tok-vg">::?CLASS</span>.^<span class="tok-n">alias</span>.<span class="tok-n">id</span> };
   <span class="tok-k">has</span> <span class="tok-vg">::?CLASS</span> <span class="tok-nv">$.pair</span>      <span class="tok-k">is</span> <span class="tok-n">relationship</span>{ .<span class="tok-n">pair-id</span> };
   <span class="tok-k">has</span> <span class="tok-n">Wishlist</span> <span class="tok-nv">@.wishes</span>    <span class="tok-k">is</span> <span class="tok-n">relationship</span>{ .<span class="tok-n">wisher-id</span> }

   <span class="tok-k">method</span> <span class="tok-n">draw</span>(<span class="tok-vg">::?CLASS</span>:<span class="tok-n">U:</span>) {
      <span class="tok-k">my</span> <span class="tok-nv">@people</span> = <span class="tok-k">self</span>.^<span class="tok-nb">all</span>.<span class="tok-n">pick:</span> *;
      <span class="tok-k">for</span> <span class="tok-n">flat</span> <span class="tok-nv">@people</span>.<span class="tok-n">rotor:</span> <span class="tok-mi">2</span> =&gt; -<span class="tok-mi">1</span> -&gt; <span class="tok-nv">$p1</span>, <span class="tok-nv">$p2</span> {
         <span class="tok-nv">$p1</span>.<span class="tok-nb">pair</span> = <span class="tok-nv">$p2</span>;
         <span class="tok-nv">$p1</span>.^<span class="tok-n">save</span>;
      }
      <span class="tok-k">given</span> <span class="tok-nv">@people</span>.<span class="tok-n">tail</span> {
         .<span class="tok-nb">pair</span> = <span class="tok-nv">@people</span>.<span class="tok-n">head</span>;
         .^<span class="tok-n">save</span>
      }
   }
}

<span class="tok-k">my</span> <span class="tok-vg">$*RED-DB</span> = <span class="tok-n">database</span> <span class="tok-s">&quot;SQLite&quot;</span>;

<span class="tok-n">Wishlist</span>.^<span class="tok-n">create-table</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create-table</span>;

<span class="tok-k">my</span> \<span class="tok-n">fernando</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernando&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;fco@aco.com&gt;</span>;
<span class="tok-n">fernando</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Comma&gt;</span>,            :<span class="tok-n">link</span><span class="tok-s">&lt;https://commaide.com&gt;</span>;
<span class="tok-n">fernando</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;perl6 books&quot;</span>),    :<span class="tok-n">link</span><span class="tok-s">&lt;https://perl6book.com&gt;</span>;
<span class="tok-n">fernando</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;mac book pro&quot;</span>),   :<span class="tok-n">link</span><span class="tok-s">&lt;https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#&gt;</span>;

<span class="tok-k">my</span> \<span class="tok-n">aline</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Aline&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;aja@aco.com&gt;</span>;
<span class="tok-n">aline</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;a new closet&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg&gt;</span>;

<span class="tok-k">my</span> \<span class="tok-n">fernanda</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernanda&gt;</span>, :<span class="tok-n">email</span><span class="tok-s">&lt;faco@aco.com&gt;</span>;
<span class="tok-n">fernanda</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;mimikyu plush&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831&gt;</span>;
<span class="tok-n">fernanda</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;camelia plush&quot;</span>), :<span class="tok-n">link</span><span class="tok-s">&lt;https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg&gt;</span>;

<span class="tok-k">my</span> \<span class="tok-n">sophia</span> = <span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Sophia&gt;</span>,   :<span class="tok-n">email</span><span class="tok-s">&lt;saco@aco.com&gt;</span>;
<span class="tok-n">sophia</span>.<span class="tok-n">wishes</span>.<span class="tok-n">create:</span> :<span class="tok-n">name</span>(<span class="tok-s">&quot;baby alive&quot;</span>),      :<span class="tok-n">link</span><span class="tok-s">&lt;https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817&gt;</span>;

<span class="tok-n">Person</span>.<span class="tok-n">draw</span>;

<span class="tok-nb">say</span> <span class="tok-s">&quot;{ .name } -&gt; { .pair.name }\n\tWishlist: { .pair.wishes.map(*.name).join: &quot;</span>, <span class="tok-s">&quot; }&quot;</span> <span class="tok-k">for</span> <span class="tok-n">Person</span>.^<span class="tok-nb">all</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在<strong>Person</strong>  有两个新*属性*  （<strong>$！pair-id</strong>和<strong>$ .pair</strong>）和一个新方法（<strong>draw</strong>）。 <strong>$！pair-id</strong>  是一个 引用 同一个*表*  （<strong>Person</strong>）上  的字段<strong>id</strong>的*外键*，因此我们必须使用  <strong>别名</strong>  （）。另一个是使用该*外键*的*关系*  （<strong>$ .pair</strong>）。<code>.^alias</code></p>
</div>
<div class="paragraph">
<p>新方法（<strong>平局</strong>）是神奇发生的地方。它使用方法  <strong>.pick：\</strong>*  在普通的  <strong>Positional</strong>  上将洗牌。它在这里做同样的事情，查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql"><span></span><span class="tok-k">SELECT</span>
   <span class="tok-n">person</span><span class="tok-p">.</span><span class="tok-n">email</span> <span class="tok-p">,</span> <span class="tok-n">person</span><span class="tok-p">.</span><span class="tok-n">id</span> <span class="tok-p">,</span> <span class="tok-n">person</span><span class="tok-p">.</span><span class="tok-n">name</span> <span class="tok-p">,</span> <span class="tok-n">person</span><span class="tok-p">.</span><span class="tok-n">pair_id</span> <span class="tok-k">as</span> <span class="tok-ss">&quot;pair-id&quot;</span>
<span class="tok-k">FROM</span>
   <span class="tok-n">person</span>
<span class="tok-k">ORDER</span> <span class="tok-k">BY</span>
   <span class="tok-n">random</span><span class="tok-p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦我们有了洗牌列表，我们就会使用  <strong>.rotor</strong>  来获取两个项目并返回一个，所以我们保存每个人给予下一个人的那一对，并且列表中的最后一个人将给第一个人。</p>
</div>
<div class="paragraph">
<p>这是我们最终代码的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Fernando</span> -&gt; <span class="tok-n">Sophia</span>
	<span class="tok-n">Wishlist:</span> <span class="tok-n">baby</span> <span class="tok-n">alive</span>
<span class="tok-n">Aline</span> -&gt; <span class="tok-n">Fernanda</span>
	<span class="tok-n">Wishlist:</span> <span class="tok-n">mimikyu</span> <span class="tok-n">plush</span>, <span class="tok-n">camelia</span> <span class="tok-n">plush</span>
<span class="tok-n">Fernanda</span> -&gt; <span class="tok-n">Fernando</span>
	<span class="tok-n">Wishlist:</span> <span class="tok-n">COMMA</span>, <span class="tok-n">perl6</span> <span class="tok-n">books</span>, <span class="tok-n">mac</span> <span class="tok-n">book</span> <span class="tok-n">pro</span>
<span class="tok-n">Sophia</span> -&gt; <span class="tok-n">Aline</span>
	<span class="tok-n">Wishlist:</span> <span class="tok-n">a</span> <span class="tok-nb">new</span> <span class="tok-n">closet</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>作为奖励，让我们看一下Red将要跟随的曲目。这是当前的工作代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">Red</span>;

<span class="tok-n">model</span> <span class="tok-n">Person</span> {
   <span class="tok-k">has</span> <span class="tok-nb">UInt</span>     <span class="tok-nv">$.id</span>        <span class="tok-k">is</span> <span class="tok-n">id</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.name</span>      <span class="tok-k">is</span> <span class="tok-n">column</span>;
   <span class="tok-k">has</span> <span class="tok-nb">Str</span>      <span class="tok-nv">$.email</span>     <span class="tok-k">is</span> <span class="tok-n">column</span>{ :<span class="tok-n">nullable</span> };
}

<span class="tok-k">my</span> <span class="tok-vg">$*RED-DB</span> = <span class="tok-n">database</span> <span class="tok-s">&quot;SQLite&quot;</span>;

<span class="tok-n">Person</span>.^<span class="tok-n">create-table</span>;

<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernando&gt;</span>,    :<span class="tok-n">email</span><span class="tok-s">&lt;fco@aco.com&gt;</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Aline&gt;</span>,       :<span class="tok-n">email</span><span class="tok-s">&lt;aja@aco.com&gt;</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Fernanda&gt;</span>;
<span class="tok-n">Person</span>.^<span class="tok-n">create:</span> :<span class="tok-n">name</span><span class="tok-s">&lt;Sophia&gt;</span>;

.<span class="tok-nb">say</span> <span class="tok-k">for</span> <span class="tok-n">Person</span>.^<span class="tok-nb">all</span>.<span class="tok-n">map:</span> { <span class="tok-s">&quot;{ .name }{ &quot;</span> =&gt; { .<span class="tok-n">email</span> }<span class="tok-s">&quot; if .email }&quot;</span> };</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是它运行的SQL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql"><span></span><span class="tok-k">SELECT</span>
   <span class="tok-k">CASE</span>
      <span class="tok-k">WHEN</span> <span class="tok-p">(</span><span class="tok-n">email</span> <span class="tok-o">==</span> <span class="tok-s1">&#39;&#39;</span> <span class="tok-k">OR</span> <span class="tok-n">email</span> <span class="tok-k">IS</span> <span class="tok-k">NULL</span><span class="tok-p">)</span> <span class="tok-k">THEN</span> <span class="tok-n">name</span>
   <span class="tok-k">ELSE</span> <span class="tok-n">name</span> <span class="tok-o">||</span> <span class="tok-s1">&#39; =&gt; &#39;</span> <span class="tok-o">||</span> <span class="tok-n">email</span>
   <span class="tok-k">END</span>
    <span class="tok-k">as</span> <span class="tok-ss">&quot;data&quot;</span>
<span class="tok-k">FROM</span>
   <span class="tok-n">person</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Fernando</span> =&gt; <span class="tok-n">fco</span><span class="tok-nv">@aco</span>.<span class="tok-n">com</span>
<span class="tok-n">Aline</span> =&gt; <span class="tok-n">aja</span><span class="tok-nv">@aco</span>.<span class="tok-n">com</span>
<span class="tok-n">Fernanda</span>
<span class="tok-n">Sophia</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_测试_cro_http_api">44. 第二十二天 - 测试 Cro HTTP API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_测试cro_http_api">44.1. 测试Cro HTTP API</h3>
<div class="paragraph">
<p>今年我花了大量的工作时间用于构建一些 Perl 6 应用程序。经过为 Perl 6 编译器和运行时开发贡献代码十年之后，最终使用它来提供解决实际问题的生产解决方案感觉很棒。我还不确定在我创建的<a href="http://www.commaide.com/">IDE中</a>编写代码，使用我设计的<a href="https://cro.services/">HTTP库</a>，由我实现大部分的<a href="https://rakudo.org/">编译器编译</a>，并在我扮演架构师的<a href="https://moarvm.org/">VM</a>上运行，是否会使我成为世界上最差的“尚未发明”的案例，或者只是真正的全栈。</p>
</div>
<div class="paragraph">
<p>无论我在做什么，我都非常重视自动化测试。每一次通过测试我都知道有东西能工作了  - 当我改进有问题的软件时，我不会破坏这些测试。即使使用自动化测试，也会发生错误，但是添加测试来弥补错误至少意味着我将来会犯下*不同的*错误，这可能有点可以原谅。</p>
</div>
<div class="paragraph">
<p>我目前正在处理的系统中的大多数代码和复杂性都在其域对象中。这些是通过使用Cro实现的HTTP API实现的 - 与系统的其他部分一样，此 HTTP API 具有自动化测试。他们使用我的一个旧模块`Test::Mock`- 以及今年发布的新模块，<code>Cro::HTTP::Test</code>。在今天的 Advent 文章中，我将讨论我如何一起使用它们，结果我觉得非常讨人喜欢。</p>
</div>
<div class="sect3">
<h4 id="_一个示例问题">44.1.1. 一个示例问题</h4>
<div class="paragraph">
<p>这是 advent 日历，所以当然我需要一个足够节日化的例子问题。对我而言，中欧圣诞时间的亮点之一是圣诞市场，有许多都坐落在美丽的历史城市广场上。除了香肠和热葡萄酒之外，我们还需要在广场上吗？当然，这是一棵高大帅气的圣诞树！但如何找到最好的树？好吧，我们通过建立一个系统来提供互联网帮助，他们可以提交他们认为可能适合的圣诞树的建议。什么可能出错？</p>
</div>
<div class="paragraph">
<p>可以 PUT 到路由 <code>/trees/{latitude}/{longitude}</code> 以在该位置提交候选圣诞树。预期的有效负载是带有树的高度( <code>height</code>) 的 JSON blob，以及 10-200 个文本字符的描述(<code>description</code>)，解释为什么这棵圣诞树太棒了。如果同一位置已经提交了圣诞树，则应返回 <code>409 Conflict</code> 响应。如果圣诞树被接受，那么将生成一个简单的 <code>200 OK</code> 响应，并带有一个 JSON 格式的主体描述该圣诞树。</p>
</div>
<div class="paragraph">
<p>同一 URI 的 GET 将返回相关树的描述，而 GET <code>/trees</code> 将返回已提交的树，最高的圣诞树排第一个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_可测性">44.1.2. 可测性</h4>
<div class="paragraph">
<p>回到高中，科学课肯定是我最喜欢的。我们不时地做实验。当然，每个实验都需要编写 - 包括之前的计划，结果和对它们的分析。规划中最重要的部分之一是关于如何确保“公平测试”：我们如何试图控制我们还未尝试测试的所有事情，以便我们可以信任我们的观察并从中得出结论？</p>
</div>
<div class="paragraph">
<p>软件测试涉及大致相同的思考过程：我们如何运用我们感兴趣的组件，同时控制它们运行的上下文？有时，我们很幸运，我们正在测试纯粹的逻辑：它不依赖于我们提供给它的东西以外的任何东西。事实上，我们可以在这方面*创造自己的运气*，发现我们系统中可以是纯函数或不可变对象的部分。从我正在研究的当前系统中获取示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们有一个由一堆规范文件构建的对象模型。
构建它的过程非常复杂，包括一系列健全性
检查，一些图形算法等等。但结果是
一堆*不可变的对象*。一旦建成，它们永远不会改变。
测试很简单：丢出一堆测试输入，并检查它是否
构建了预期的对象。</p>
</li>
<li>
<p>我们有一个计算器的小语言。
语言中表达式使用的数据作为参数传递给计算器，
然后我们可以检查结果是否符合预期。因此，计算器
是一个*纯函数*。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，为可测试性做的第一件事就是找到可以像这样的系统部分并以这种方式构建它们。唉，并非所有事情都如此简单。HTTP API 通常是可变状态的网关，数据库操作等。此外，良好的 HTTP API 会将域级别的错误条件映射到适当的 HTTP 状态代码。我们希望能够在我们的测试中创建这样的情况，以便覆盖它们。这是一个类似 `Test::Mock`工具入场的地方, 但要使用它，我们需要以一种对测试友好的方式考虑我们的Cro服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_打桩服务">44.1.3. 打桩服务</h4>
<div class="paragraph">
<p>对于那些刚接触Cro的人，让我们来看看我们可以编写的最低限度，以便启动和运行HTTP服务，提供有关树的一些假数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl"><span></span><span class="tok-k">use</span> <span class="tok-nn">Cro::HTTP::Router</span><span class="tok-p">;</span>
<span class="tok-k">use</span> <span class="tok-nn">Cro::HTTP::Server</span><span class="tok-p">;</span>

<span class="tok-k">my</span> <span class="tok-nv">$application</span> <span class="tok-o">=</span> <span class="tok-n">route</span> <span class="tok-p">{</span>
    <span class="tok-nn">get</span> <span class="tok-o">-&gt;</span> <span class="tok-s">&#39;trees&#39;</span> <span class="tok-p">{</span>
        <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span><span class="tok-p">,</span> <span class="tok-p">[</span>
            <span class="tok-p">{</span>
                <span class="tok-n">longitude</span> <span class="tok-o">=&gt;</span> <span class="tok-mf">50.4311548</span><span class="tok-p">,</span>
                <span class="tok-n">latitude</span> <span class="tok-o">=&gt;</span> <span class="tok-mf">14.586079</span><span class="tok-p">,</span>
                <span class="tok-n">height</span> <span class="tok-o">=&gt;</span> <span class="tok-mf">4.2</span><span class="tok-p">,</span>
                <span class="tok-n">description</span> <span class="tok-o">=&gt;</span> <span class="tok-s">&#39;Nice color, very bushy&#39;</span>
            <span class="tok-p">},</span>
            <span class="tok-p">{</span>
                <span class="tok-n">longitude</span> <span class="tok-o">=&gt;</span> <span class="tok-mf">50.5466504</span><span class="tok-p">,</span>
                <span class="tok-n">latitude</span> <span class="tok-o">=&gt;</span> <span class="tok-mf">14.8438714</span><span class="tok-p">,</span>
                <span class="tok-n">height</span> <span class="tok-o">=&gt;</span> <span class="tok-mf">7.8</span><span class="tok-p">,</span>
                <span class="tok-n">description</span> <span class="tok-o">=&gt;</span> <span class="tok-s">&#39;Really tall and wide&#39;</span>
            <span class="tok-p">},</span>
        <span class="tok-p">]</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-k">my</span> <span class="tok-nv">$server</span> <span class="tok-o">=</span> <span class="tok-nn">Cro::HTTP::</span><span class="tok-n">Server</span><span class="tok-o">.</span><span class="tok-k">new</span><span class="tok-p">(:</span><span class="tok-n">port</span><span class="tok-p">(</span><span class="tok-mi">10000</span><span class="tok-p">),</span> <span class="tok-p">:</span><span class="tok-nv">$application</span><span class="tok-p">);</span>
<span class="tok-nv">$server</span><span class="tok-o">.</span><span class="tok-n">start</span><span class="tok-p">;</span>
<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span><span class="tok-p">(</span><span class="tok-n">SIGINT</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nv">$server</span><span class="tok-o">.</span><span class="tok-n">stop</span><span class="tok-p">;</span>
    <span class="tok-nb">exit</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这不是一个能够测试我们路由的好方法。更好的方法是将路由放入 <code>lib/BestTree.pm6</code> 模块中的子例程中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">unit</span> <span class="tok-k">module</span> <span class="tok-n">BestTree</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Router</span>;

<span class="tok-k">sub</span> <span class="tok-n">routes</span>() <span class="tok-k">is</span> <span class="tok-k">export</span> {
    <span class="tok-n">route</span> {
        <span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;trees&#39;</span> {
            <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, [
                {
                    <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">50.4311548</span>,
                    <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">14.586079</span>,
                    <span class="tok-n">height</span> =&gt; <span class="tok-mf">4.2</span>,
                    <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Nice color, very bushy&#39;</span>
                },
                {
                    <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">50.5466504</span>,
                    <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">14.8438714</span>,
                    <span class="tok-n">height</span> =&gt; <span class="tok-mf">7.8</span>,
                    <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Really tall and wide&#39;</span>
                },
            ]
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并从脚本中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">BestTree</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Server</span>;

<span class="tok-k">my</span> <span class="tok-nv">$application</span> = <span class="tok-n">routes</span>();
<span class="tok-k">my</span> <span class="tok-nv">$server</span> = <span class="tok-n">Cro::HTTP::Server</span>.<span class="tok-nb">new</span>(:<span class="tok-n">port</span>(<span class="tok-mi">10000</span>), :<span class="tok-nv">$application</span>);
<span class="tok-nv">$server</span>.<span class="tok-n">start</span>;
<span class="tok-n">react</span> <span class="tok-n">whenever</span> <span class="tok-n">signal</span>(<span class="tok-n">SIGINT</span>) {
    <span class="tok-nv">$server</span>.<span class="tok-n">stop</span>;
    <span class="tok-k">exit</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果我们有一些东西可以用来测试`route`块做正确的事情，我们可以使用(<code>use</code>)这个模块，继续我们的测试。</p>
</div>
</div>
<div class="sect3">
<h4 id="_存储模型等">44.1.4. 存储、模型等</h4>
<div class="paragraph">
<p>然而，还有另一个问题。我们的圣诞树服务将在一些数据库中存储树信息，并执行各种规则。这个逻辑应该去哪里？</p>
</div>
<div class="paragraph">
<p>我们有许多方法来安排这段代码，但最关键的是，这种逻辑并不属于我们的Cro路由处理程序。他们的工作是在域对象和HTTP世界之间进行映射，例如将域异常转换为适当的HTTP错误响应。那个映射是我们想要测试的。</p>
</div>
<div class="paragraph">
<p>所以，在我们继续之前，让我们来定义一些这些东西的外观。我们将有一个`BestTree::Tree`代表树的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">BestTree::Tree</span> {
    <span class="tok-k">has</span> <span class="tok-nb">Rat</span> <span class="tok-nv">$.latitude</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Rat</span> <span class="tok-nv">$.longitude</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Rat</span> <span class="tok-nv">$.height</span>;
    <span class="tok-k">has</span> <span class="tok-nb">Str</span> <span class="tok-nv">$.description</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将使用一个`BestTree::Store`对象。我们实际上不会将此作为此帖的一部分来实现; 这将是我们在测试中假装的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">class</span> <span class="tok-n">BestTree::Store</span> {
    <span class="tok-k">method</span> <span class="tok-n">all-trees</span>() { ... }
    <span class="tok-k">method</span> <span class="tok-n">suggest-tree</span>(<span class="tok-n">BestTree::Tree</span> <span class="tok-nv">$tree</span> --&gt; <span class="tok-n">Nil</span>) { ... }
    <span class="tok-k">method</span> <span class="tok-n">find-tree</span>(<span class="tok-nb">Rat</span> <span class="tok-nv">$latitude</span>, <span class="tok-nb">Rat</span> <span class="tok-nv">$longitude</span> --&gt; <span class="tok-n">BestTree::Tree</span>) { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们如何安排事情以便我们可以控制路由使用的存储，以进行测试？一个简单的方法是使它成为我们`routes`子程序的参数，这意味着它将在`route`块中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">routes</span>(<span class="tok-n">BestTree::Store</span> <span class="tok-nv">$store</span>) <span class="tok-k">is</span> <span class="tok-k">export</span> {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个功能因素。有些人可能更喜欢使用某种容器来使用某种基于OO的依赖注入。这也适用于Cro：只需要一个返回`route`块的方法。（如果使用Cro构建非常小的东西，请查看<a href="https://cro.services/docs/structuring-services">有关结构化服务</a>的<a href="https://cro.services/docs/structuring-services">文档，</a>以获得有关此方面的一些进一步建议。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_获取树的清单">44.1.5. 获取树的清单</h4>
<div class="paragraph">
<p>现在我们准备开始编写测试了！让我们存根测试文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">BestTree</span>;
<span class="tok-k">use</span> <span class="tok-n">BestTree::Store</span>;
<span class="tok-k">use</span> <span class="tok-n">Cro::HTTP::Test</span>;
<span class="tok-k">use</span> <span class="tok-n">Test::Mock</span>;
<span class="tok-k">use</span> <span class="tok-n">Test</span>;

<span class="tok-c1"># Tests will go here</span>

<span class="tok-n">done-testing</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用`BestTree`，它包含我们想要测试的路由，以及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Cro::HTTP::Test</code>，我们将用它来轻松编写我们的路由测试</p>
</li>
<li>
<p><code>Test::Mock</code>，我们将用它来伪造存储</p>
</li>
<li>
<p><code>Test</code>，我们并不严格需要，但有权访问`subtest`将
让我们产生更有条理的测试输出</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来，我们将在测试中使用几个树对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$fake-tree-a</span> = <span class="tok-n">BestTree::Tree</span>.<span class="tok-n">new:</span>
        <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">50.4311548</span>,
        <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">14.586079</span>,
        <span class="tok-n">height</span> =&gt; <span class="tok-mf">4.2</span>,
        <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Nice color, very bushy&#39;</span>;
<span class="tok-k">my</span> <span class="tok-nv">$fake-tree-b</span> = <span class="tok-n">BestTree::Tree</span>.<span class="tok-n">new:</span>
        <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">50.5466504</span>,
        <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">14.8438714</span>,
        <span class="tok-n">height</span> =&gt; <span class="tok-mf">7.8</span>,
        <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Really tall and wide&#39;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是第一次测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">subtest</span> <span class="tok-s">&#39;Get all trees&#39;</span> =&gt; {
    <span class="tok-k">my</span> <span class="tok-nv">$fake-store</span> = <span class="tok-n">mocked</span> <span class="tok-n">BestTree::Store</span>, <span class="tok-n">returning</span> =&gt; {
        <span class="tok-n">all-trees</span> =&gt; [<span class="tok-nv">$fake-tree-a</span>, <span class="tok-nv">$fake-tree-b</span>]
    };
    <span class="tok-n">test-service</span> <span class="tok-n">routes</span>(<span class="tok-nv">$fake-store</span>), {
        <span class="tok-n">test</span> <span class="tok-n">get</span>(<span class="tok-s">&#39;/trees&#39;</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">200</span>,
                <span class="tok-n">json</span> =&gt; [
                    {
                        <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">50.4311548</span>,
                        <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">14.586079</span>,
                        <span class="tok-n">height</span> =&gt; <span class="tok-mf">4.2</span>,
                        <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Nice color, very bushy&#39;</span>
                    },
                    {
                        <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">50.5466504</span>,
                        <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">14.8438714</span>,
                        <span class="tok-n">height</span> =&gt; <span class="tok-mf">7.8</span>,
                        <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Really tall and wide&#39;</span>
                    }
                ];
        <span class="tok-n">check-mock</span> <span class="tok-nv">$fake-store</span>,
                *.<span class="tok-n">called</span>(<span class="tok-s">&#39;all-trees&#39;</span>, <span class="tok-nb">times</span> =&gt; <span class="tok-mi">1</span>, <span class="tok-n">with</span> =&gt; \());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们伪造一个 <code>BestTree::Store</code>，无论何时`all-trees`被调用，都将返回我们指定的伪数据。然后我们使用`test-service`，传递`route`用假存储创建的块。随后的块内的所有 <code>test</code> 调用都将针对该`route`块执行。</p>
</div>
<div class="paragraph">
<p>请注意，在这里我们不必担心运行HTTP服务来托管我们要测试的路由。实际上，由于Cro的管道架构，我们很容易就可以使用Cro HTTP客户端，连接其TCP消息输出以将它想要的数据发送到 Perl 6 `Channel`中，然后将这些数据推送到服务管道的TCP消息的输入管道中，反之亦然。这意味着我们一路测试到发送和接收的字节，但实际上不必命中本地网络堆栈。（旁白：您也可以使用`Cro::HTTP::Test`URI，这意味着如果您真的想要启动测试服务器，或者甚至想针对在不同进程中运行的其他服务编写测试，您可以这样做。）</p>
</div>
<div class="paragraph">
<p>该`test`程序规定了测试案例。它的第一个参数描述了我们希望执行的请求 - 在这种情况下，是一个到 <code>/trees</code> 的`get` 。然后，命名参数指定响应的外观。该`status`检查将确保我们取回了预期的HTTP状态代码。该`json`检查实际上是一个里面有俩个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它检查 HTTP 的 content-type 是否为 JSON</p>
</li>
<li>
<p>它检查反序列化为提供的JSON的正文（如果你不想
测试它的每一个，在那里传递一个块，应该计算为`True`）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这就是我们所做的，并且我们运行了测试，我们会发现它们神秘地通过了，即使我们还没有编辑我们的`route`块的`get`处理程序来实际使用存储！为什么？因为事实证明我很懒，并且使用我之前的小服务器示例中的数据作为我的测试数据。不用担心：为了使测试更强大，我们可以添加一个对 <code>check-mock</code> 的调用，然后断言我们的假存储确实调用了一次 <code>all-trees</code> 方法，并且没有传递参数。</p>
</div>
<div class="paragraph">
<p>这让我们通过正确实现处理程序来使测试通过：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;trees&#39;</span> {
    <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, [
        <span class="tok-nv">$store</span>.<span class="tok-n">all-trees</span>.<span class="tok-n">map:</span> -&gt; <span class="tok-nv">$tree</span> {
            {
                <span class="tok-n">latitude</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">latitude</span>,
                <span class="tok-n">longitude</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">longitude</span>,
                <span class="tok-n">height</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">height</span>,
                <span class="tok-n">description</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">description</span>
            }
        }
    ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_得到一棵树">44.1.6. 得到一棵树</h4>
<div class="paragraph">
<p>下一次测试的时间：获得一棵树。这里有两种情况需要考虑：一个是树是在哪里找到的，以及树是在哪里找不到的。这是对树是在哪里找到的情况的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">subtest</span> <span class="tok-s">&#39;Get a tree that exists&#39;</span> =&gt; {
    <span class="tok-k">my</span> <span class="tok-nv">$fake-store</span> = <span class="tok-n">mocked</span> <span class="tok-n">BestTree::Store</span>, <span class="tok-n">returning</span> =&gt; {
        <span class="tok-n">find-tree</span> =&gt; <span class="tok-nv">$fake-tree-b</span>
    };
    <span class="tok-n">test-service</span> <span class="tok-n">routes</span>(<span class="tok-nv">$fake-store</span>), {
        <span class="tok-n">test</span> <span class="tok-n">get</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">200</span>,
                <span class="tok-n">json</span> =&gt; {
                    <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">50.5466504</span>,
                    <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">14.8438714</span>,
                    <span class="tok-n">height</span> =&gt; <span class="tok-mf">7.8</span>,
                    <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Really tall and wide&#39;</span>
                };
        <span class="tok-n">check-mock</span> <span class="tok-nv">$fake-store</span>,
                *.<span class="tok-n">called</span>(<span class="tok-s">&#39;find-tree&#39;</span>, <span class="tok-nb">times</span> =&gt; <span class="tok-mi">1</span>, <span class="tok-n">with</span> =&gt; \(<span class="tok-mf">50.5466504</span>, <span class="tok-mf">14.8438714</span>));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在运行它失败了。事实上，`status`代码检查首先失败，因为我们还没有实现路由，因此得到404，而不是预期的200. 所以，这是一个让它通过的实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>        <span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;trees&#39;</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$latitude</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$longitude</span> {
            <span class="tok-k">given</span> <span class="tok-nv">$store</span>.<span class="tok-n">find-tree</span>(<span class="tok-nv">$latitude</span>, <span class="tok-nv">$longitude</span>) -&gt; <span class="tok-nv">$tree</span> {
                <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, {
                    <span class="tok-n">latitude</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">latitude</span>,
                    <span class="tok-n">longitude</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">longitude</span>,
                    <span class="tok-n">height</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">height</span>,
                    <span class="tok-n">description</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">description</span>
                }
            }
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>从其他路由来看，这部分看起来有些熟悉，不是吗？所以，有了两次通过测试，让我们继续重构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;trees&#39;</span> {
    <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>,
            [<span class="tok-nv">$store</span>.<span class="tok-n">all-trees</span>.<span class="tok-nb">map</span>(<span class="tok-nv">&amp;tree-for-json</span>)];
}

<span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;trees&#39;</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$latitude</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$longitude</span> {
    <span class="tok-k">given</span> <span class="tok-nv">$store</span>.<span class="tok-n">find-tree</span>(<span class="tok-nv">$latitude</span>, <span class="tok-nv">$longitude</span>) -&gt; <span class="tok-nv">$tree</span> {
        <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, <span class="tok-n">tree-for-json</span>(<span class="tok-nv">$tree</span>);
    }
}

<span class="tok-k">sub</span> <span class="tok-n">tree-for-json</span>(<span class="tok-n">BestTree::Tree</span> <span class="tok-nv">$tree</span> --&gt; <span class="tok-nb">Hash</span>) {
    <span class="tok-k">return</span> {
        <span class="tok-n">latitude</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">latitude</span>,
        <span class="tok-n">longitude</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">longitude</span>,
        <span class="tok-n">height</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">height</span>,
        <span class="tok-n">description</span> =&gt; <span class="tok-nv">$tree</span>.<span class="tok-n">description</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试通过，我们知道我们的重构很好。但是等一下，如果那里没有树怎么办？在这种情况下，存储将返回`Nil`。我们想把它映射到404.这是另一个测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">subtest</span> <span class="tok-s">&#39;Get a tree that does not exist&#39;</span> =&gt; {
    <span class="tok-k">my</span> <span class="tok-nv">$fake-store</span> = <span class="tok-n">mocked</span> <span class="tok-n">BestTree::Store</span>, <span class="tok-n">returning</span> =&gt; {
        <span class="tok-n">find-tree</span> =&gt; <span class="tok-n">Nil</span>
    };
    <span class="tok-n">test-service</span> <span class="tok-n">routes</span>(<span class="tok-nv">$fake-store</span>), {
        <span class="tok-n">test</span> <span class="tok-n">get</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">404</span>;
        <span class="tok-n">check-mock</span> <span class="tok-nv">$fake-store</span>,
                *.<span class="tok-n">called</span>(<span class="tok-s">&#39;find-tree&#39;</span>, <span class="tok-nb">times</span> =&gt; <span class="tok-mi">1</span>, <span class="tok-n">with</span> =&gt; \(<span class="tok-mf">50.5466504</span>, <span class="tok-mf">14.8438714</span>));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，由于我们在路由块中没有考虑这种情况，因此失败了, 返回 500 错误码。令人高兴的是，这个很容易处理：把 <code>given`变成 `with</code>，它检查我们得到了一个已定义的对象，然后添加一个`else`并生成404 Not Found响应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">get</span> -&gt; <span class="tok-s">&#39;trees&#39;</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$latitude</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$longitude</span> {
    <span class="tok-n">with</span> <span class="tok-nv">$store</span>.<span class="tok-n">find-tree</span>(<span class="tok-nv">$latitude</span>, <span class="tok-nv">$longitude</span>) -&gt; <span class="tok-nv">$tree</span> {
        <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, <span class="tok-n">tree-for-json</span>(<span class="tok-nv">$tree</span>);
    }
    <span class="tok-k">else</span> {
        <span class="tok-o">not-</span><span class="tok-n">found</span>;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_提交一棵树">44.1.7. 提交一棵树</h4>
<div class="paragraph">
<p>最后但并非最不重要的是，让我们测试建议新树的路由。这是成功的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">subtest</span> <span class="tok-s">&#39;Suggest a tree successfully&#39;</span> =&gt; {
    <span class="tok-k">my</span> <span class="tok-nv">$fake-store</span> = <span class="tok-n">mocked</span> <span class="tok-n">BestTree::Store</span>;
    <span class="tok-n">test-service</span> <span class="tok-n">routes</span>(<span class="tok-nv">$fake-store</span>), {
        <span class="tok-k">my</span> <span class="tok-nv">%body</span> = <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Awesome tree&#39;</span>, <span class="tok-n">height</span> =&gt; <span class="tok-mf">4.25</span>;
        <span class="tok-n">test</span> <span class="tok-n">put</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>, <span class="tok-n">json</span> =&gt; <span class="tok-nv">%body</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">200</span>,
                <span class="tok-n">json</span> =&gt; {
                    <span class="tok-n">latitude</span> =&gt; <span class="tok-mf">50.5466504</span>,
                    <span class="tok-n">longitude</span> =&gt; <span class="tok-mf">14.8438714</span>,
                    <span class="tok-n">height</span> =&gt; <span class="tok-mf">4.25</span>,
                    <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Awesome tree&#39;</span>
                };
        <span class="tok-n">check-mock</span> <span class="tok-nv">$fake-store</span>,
                *.<span class="tok-n">called</span>(<span class="tok-s">&#39;suggest-tree&#39;</span>, <span class="tok-nb">times</span> =&gt; <span class="tok-mi">1</span>, <span class="tok-n">with</span> =&gt; :(
                    <span class="tok-n">BestTree::Tree</span> <span class="tok-nv">$tree</span> <span class="tok-k">where</span> {
                        .<span class="tok-n">latitude</span> == <span class="tok-mf">50.5466504</span> &amp;&amp;
                        .<span class="tok-n">longitude</span> == <span class="tok-mf">14.8438714</span> &amp;&amp;
                        .<span class="tok-n">height</span> == <span class="tok-mf">4.25</span> &amp;&amp;
                        .<span class="tok-n">description</span> <span class="tok-o">eq</span> <span class="tok-s">&#39;Awesome tree&#39;</span>
                    }
                ));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>大部分都很熟悉，除了这次`check-mock` 调用看起来有点不同。<code>Test::Mock`让我们用两种不同的方式测试参数： `Capture</code>（我们到目前为止）或者 <code>Signature</code>。这个`Capture`案例非常适用于所有简单情况，我们只处理无聊的值。但是，一旦我们进入引用类型，或者如果我们实际上并不关心确切的值并且只是想断言我们关心的事情，签名就会让我们灵活地做到这一点。这里，我们使用一个`where`子句来检查路由处理程序构造的树对象是否包含预期的数据。</p>
</div>
<div class="paragraph">
<p>这是执行此操作的路由处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">put</span> -&gt; <span class="tok-s">&#39;trees&#39;</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$latitude</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$longitude</span> {
    <span class="tok-n">request-body</span> -&gt; (<span class="tok-nb">Rat</span>(<span class="tok-n">Real</span>) :<span class="tok-nv">$height</span>!, <span class="tok-nb">Str</span> :<span class="tok-nv">$description</span>!) {
        <span class="tok-k">my</span> <span class="tok-nv">$tree</span> = <span class="tok-n">BestTree::Tree</span>.<span class="tok-n">new:</span> :<span class="tok-nv">$latitude</span>, :<span class="tok-nv">$longitude</span>,
                :<span class="tok-nv">$height</span>, :<span class="tok-nv">$description</span>;
        <span class="tok-nv">$store</span>.<span class="tok-n">suggest-tree</span>(<span class="tok-nv">$tree</span>);
        <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, <span class="tok-n">tree-for-json</span>(<span class="tok-nv">$tree</span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意Cro如何让我们使用Perl 6签名来构建请求体。在一行中，我们说过：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求正文必须具有高度和描述</p>
</li>
<li>
<p>我们希望高度是一个`Real`数字</p>
</li>
<li>
<p>我们希望描述是一个字符串</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果其中任何一个失败，Cro将自动为我们产生400不良请求。事实上，我们可以编写测试来覆盖它 - 以及一个新的测试，以确保冲突将导致409。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">subtest</span> <span class="tok-s">&#39;Problems suggesting a tree&#39;</span> =&gt; {
    <span class="tok-k">my</span> <span class="tok-nv">$fake-store</span> = <span class="tok-n">mocked</span> <span class="tok-n">BestTree::Store</span>, <span class="tok-n">computing</span> =&gt; {
        <span class="tok-n">suggest-tree</span> =&gt; {
            <span class="tok-k">die</span> <span class="tok-o">X</span>::<span class="tok-n">BestTree::Store::AlreadySuggested</span>.<span class="tok-nb">new</span>;
        }
    }
    <span class="tok-n">test-service</span> <span class="tok-n">routes</span>(<span class="tok-nv">$fake-store</span>), {
        <span class="tok-c1"># Missing or bad data.</span>
        <span class="tok-n">test</span> <span class="tok-n">put</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>, <span class="tok-n">json</span> =&gt; {}),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">400</span>;
        <span class="tok-k">my</span> <span class="tok-nv">%bad-body</span> = <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;ok&#39;</span>;
        <span class="tok-n">test</span> <span class="tok-n">put</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>, <span class="tok-n">json</span> =&gt; <span class="tok-nv">%bad-body</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">400</span>;
        <span class="tok-nv">%bad-body&lt;height&gt;</span> = <span class="tok-s">&#39;grinch&#39;</span>;
        <span class="tok-n">test</span> <span class="tok-n">put</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>, <span class="tok-n">json</span> =&gt; <span class="tok-nv">%bad-body</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">400</span>;

        <span class="tok-c1"># Conflict.</span>
        <span class="tok-k">my</span> <span class="tok-nv">%body</span> = <span class="tok-n">description</span> =&gt; <span class="tok-s">&#39;Awesome tree&#39;</span>, <span class="tok-n">height</span> =&gt; <span class="tok-mf">4.25</span>;
        <span class="tok-n">test</span> <span class="tok-n">put</span>(<span class="tok-s">&#39;/trees/50.5466504/14.8438714&#39;</span>, <span class="tok-n">json</span> =&gt; <span class="tok-nv">%body</span>),
                <span class="tok-n">status</span> =&gt; <span class="tok-mi">409</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要新事物是我们使用`computing`而不是带有 <code>mocked</code> 的`returning`。在这种情况下，我们传递一个块，它将被执行。（然而，该块不会获取方法参数。如果我们想要获取这些参数，则有第三个选项，<code>overriding</code>, 其中我们可以获取参数并编写一个假的方法体。）</p>
</div>
<div class="paragraph">
<p>以及如何处理？通过使我们的路由处理程序捕获并映射类型化的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">put</span> -&gt; <span class="tok-s">&#39;trees&#39;</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$latitude</span>, <span class="tok-nb">Rat</span>() <span class="tok-nv">$longitude</span> {
    <span class="tok-n">request-body</span> -&gt; (<span class="tok-nb">Rat</span>(<span class="tok-n">Real</span>) :<span class="tok-nv">$height</span>!, <span class="tok-nb">Str</span> :<span class="tok-nv">$description</span>!) {
        <span class="tok-k">my</span> <span class="tok-nv">$tree</span> = <span class="tok-n">BestTree::Tree</span>.<span class="tok-n">new:</span> :<span class="tok-nv">$latitude</span>, :<span class="tok-nv">$longitude</span>,
                :<span class="tok-nv">$height</span>, :<span class="tok-nv">$description</span>;
        <span class="tok-nv">$store</span>.<span class="tok-n">suggest-tree</span>(<span class="tok-nv">$tree</span>);
        <span class="tok-n">content</span> <span class="tok-s">&#39;application/json&#39;</span>, <span class="tok-n">tree-for-json</span>(<span class="tok-nv">$tree</span>);
        <span class="tok-k">CATCH</span> {
            <span class="tok-k">when</span> <span class="tok-o">X</span>::<span class="tok-n">BestTree::Store::AlreadySuggested</span> {
                <span class="tok-n">conflict</span>;
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_结束思考">44.1.8. 结束思考</h4>
<div class="paragraph">
<p>有了`Cro::HTTP::Test`，现在有一种很好的方法可以在Perl 6中编写HTTP测试。结合可测试的设计，也许是一个类似的模块`Test::Mock`，我们也可以将我们的Cro路由处理程序与其他所有东西隔离开来，从而简化测试。</p>
</div>
<div class="paragraph">
<p>我们的路由处理程序中的逻辑相对简单; 通常是小样本问题。然而，即使在这里，我发现旅程中有价值，而不仅仅是在目的地。为HTTP API编写测试的行为让我置身于任何将调用API的人的心中，这可能是一个有用的观点。经验还告诉我们，测试“太简单到失败”最终会导致错误：我可能会认为我犯得太聪明了。纪律有很长的路要走。在哪个方面，我现在会受到纪律处分，不时地从键盘上休息一下，然后去享受圣诞市场。-Ofun！</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_blin很快就到圣诞节了">45. 第二十三天 - Blin，很快就到圣诞节了！</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://perl6advent.wordpress.com/2016/12/23/">两年前</a>我已经在出现一篇 advent 文章里提到过 Bisectable，但自那时以来发生了很多变化，所以我觉得是时候简要介绍一下 <code>bisectable</code> 机器人和它的朋友们了。</p>
</div>
<div class="paragraph">
<p>首先，让我们来定义正在解决的问题。有时会<a href="https://github.com/rakudo/rakudo/issues?q=is%3Aopen+is%3Aissue+label%3Aregression">发生</a>提交引入意外更改行为（错误）。通常我们称之为回归，在某些情况下，找出错误并修复它的最简单方法是首先找到引入回归的提交。</p>
</div>
<div class="paragraph">
<p>Rakudo 2015.12 和 2018.12 之间有<a href="https://github.com/Rakudo/Rakudo/compare/2015.12&#8230;&#8203;2018.12">9000个</a>提交，尽管它不*超过9000*，但仍然很多。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们不需要测试所有修改。假设行为不是一直来回变化，我们可以使用<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">二分法查找</a>。</p>
</div>
<div class="sect2">
<h3 id="_git_bisect_和二分法查找">45.1. <code>git bisect</code> 和二分法查找</h3>
<div class="paragraph">
<p>基本上，给定任何提交范围，我们在范围的“中间”取一个提交提交并测试它。如果它是“坏”或者它显示“新”（现在是不正确的）行为，那么我们就可以抛弃我们范围的后半部分（因为我们知道更改必须在该提交之前发生或完全在该提交之后）。同样，如果它是“好”（或“旧”），我们会扔掉另一半。因此，我们只需检查`log n`个修改（≈13），而不是测试所有 9000 次提交。</p>
</div>
<div class="paragraph">
<p>Git 附带了<a href="https://git-scm.com/docs/git-bisect"><code>git bisect</code></a>为您实现二分法查找逻辑的命令。你所要做的就是给它一些起点，然后对于每次提交它跳转过去，告诉它是好还是坏。如果你做了足够多次，它会告诉你哪个提交有问题。</p>
</div>
<div class="paragraph">
<p>这一切都很好，但有两个问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_问题跳过">45.2. 问题❶：跳过</h3>
<div class="paragraph">
<p>让我们想象一下`2 + 2`用来返回的情况`4`（正确！），但现在返回`42`（&#8230;&#8203;&#8230;&#8203;也正确，但不完全对）。</p>
</div>
<div class="paragraph">
<p>所以你启动了 bisection 过程，git 在修改之间跳转，你测试它们。如果它是`4`那么`good`（或`old`），如果它是`42`那么它是`bad`（或`new`）。但后来你偶然发现了这种行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>&gt; <span class="tok-mi">2</span> + <span class="tok-mi">2</span>

<span class="tok-n">Merry</span> <span class="tok-n">Christmas</span>!</code></pre>
</div>
</div>
<div class="paragraph">
<p>… 怎么办？显然，那个具体修改有点特殊。我们无法判断我们的错误是否存在，我们根本无法知道。是的，它不会打印`4`，但我们正在寻找一个非常具体的错误，因此它也不会被归类为“新”行为。当然，我们可以抛硬币并随机标记为`old`或者`new`，并希望圣诞节奇迹&#8230;&#8203;&#8230;&#8203;但是有50％的概率（如果我们只看到其中一个）将二分法查找转移到错误的方向。</p>
</div>
<div class="paragraph">
<p>对于这些情况，git 提供了一个特殊<a href="https://git-scm.com/docs/git-bisect#_bisect_skip">`skip`命令</a>。</p>
</div>
<div class="paragraph">
<p>如果你是手动测试，那么处理这些修改就有点简单（只要你记得你应该跳过(<code>skip</code>)他们）。但是，由于问题❷，很多人都倾向于使用`git bisect run`脚本自动化过程。也可以使用脚本跳过修改（使用退出代码`125`），但是如何确定应该跳过哪些修改并不是那么明显。</p>
</div>
</div>
<div class="sect2">
<h3 id="_问题构建时间">45.3. 问题❷：构建时间</h3>
<div class="paragraph">
<p>让我们用乐观的数字13来估计我们要测试的修改量。请记住，它不包括我们必须跳过的提交，以及可能需要测试的其他额外构建。</p>
</div>
<div class="paragraph">
<p>构建rakudo所需的时间因硬件而异，但我们乐观地说，在特定的提交中构建rakudo需要2分钟时间并对其进行测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-mi">13</span> × <span class="tok-mi">2</span> = <span class="tok-mi">26</span> (<span class="tok-n">minutes</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>那不是很方便，对吧？如果在此过程中出现问题&#8230;&#8203;&#8230;&#8203;你重新开始，<a href="https://www.youtube.com/watch?v=mPzjbXgaVOk&amp;feature=youtu.be&amp;t=16">然后等待</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bisectable">45.4. Bisectable</h3>
<div class="paragraph">
<p>在2016年，在看到那些必须手动运行 <code>git bisect</code> 的人（实际上，大部分是<a href="https://colabti.org/irclogger/irclogger_log/perl6?date=2016-05-17#l1353">我自己</a>）的痛苦之后，<a href="https://colabti.org/irclogger/irclogger_log/perl6?date=2016-05-17#l1335">我想知道</a>：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>有没有人想过为每一次提交构建rakudo，以便你可以快速运行git bisect？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>该想法的成本效益分析受到了迅速质疑：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>AlexDaniel：你认为未来二分法将会很普遍吗？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我提供了非常详细的理由：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>perlpilot：是的</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>三天后，机器人加入了频道。<a href="https://colabti.org/irclogger/irclogger_log/perl6?date=2016-05-20#l345">这些反应</a>非常有趣：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>哇
哦
OooOOOoooh
Cooooool</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>当时我们很少知道结果会怎样。即使我不知道它会变得多么有用。<a href="https://colabti.org/irclogger/irclogger_log/perl6?date=2018-11-13#l678">快进2年</a>：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>关于提交的大小：我尽量保持它们尽可能小，并且尽可能地包含它们，以便
在这种意义上更容易二分，bisectable6 也改变了我编码的方式
还有：bisectable6 让我更少担心我提交的更改
因为它通常限制很多地点寻找以修复问题，他们可以在几分钟而不是几小时内修复
或至少很快显示原因（所以短时间修复可能意味着 revert）
\ o /</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但它并不总是完美的。引入机器人大约一小时后，它被用于其目的：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>bisect：<code>try { NaN.Rat == NaN; exit 0 }; exit 1</code>
moritz：（2016-05-02）<a href="https://github.com/rakudo/rakudo/commit/949a7c7" class="bare">https://github.com/rakudo/rakudo/commit/949a7c7</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但是，由于一个<a href="https://github.com/perl6/whateverable/commit/68ba961854b17298225dd9b886b2af874e567556">off-by-one</a>，它返回了错误的提交。实际提交是<a href="https://github.com/rakudo/rakudo/commit/e2f1fa7">e2f1fa7</a>，而<a href="https://github.com/rakudo/rakudo/commit/949a7c7">949a7c7</a>是其父级。</p>
</div>
<div class="paragraph">
<p>老实说，那时机器人非常糟糕。例如，它完全依赖于退出代码，所以你不能只是把 `2 + 2`抛给它并期望它检查输出。最终，实施了不同的模式，现在机器人首先检查起点上的行为（例如2015.12和HEAD），并确定执行二分法的最佳策略。例如，如果信号不同（例如SEGV），则它基于信号一分为二。如果信号相同，但退出代码不同，则使用退出代码。如果无法使用其他所有内容，则使用输出进行一分为二。</p>
</div>
<div class="paragraph">
<p>请记住，如果`perl6`无法构建二进制文件，则可以检查二分法。这意味着在大多数情况下，您不需要添加自己的逻辑来跳过。它不仅将二分法时间从几十分钟缩短到几秒钟，而且还提供更可靠/正确的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_存储">45.5. 存储</h3>
<div class="paragraph">
<p>一段时间之后，提交范围扩展到`2014.01`&#8230;&#8203;&#8230;&#8203; <code>HEAD</code>，意味着所有提交都是从第一个有关Moar的Rakudo发布开始的。目前它有超过17000个构建。它可能听起来很多，但每个rakudo安装只需≈28MB，这不是*太多*。拥有几TB存储空间可以让您在未来几年内继续使用。</p>
</div>
<div class="paragraph">
<p>话虽如此，我的服务器上没有那么奢侈。它有一个120 GB SSD的RAID，因此整个事情不仅要适应这么小的空间，而且还应该为系统的其余部分留出足够的空间。</p>
</div>
<div class="paragraph">
<p>有很多实验（<a href="https://github.com/perl6/whateverable/issues/23">一</a>，<a href="https://github.com/perl6/whateverable/issues/117">二</a>）涉及找出节省空间的最佳策略，但*长话短说*，我们可以低至每个版本大约半兆字节！当然，它总是在压缩比和解压缩速度之间进行权衡，但使用现代压缩算法（<a href="https://github.com/facebook/zstd">zstd</a>，<a href="https://github.com/ckolivas/lrzip">lrzip</a>）一切都相对容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_更多机器人更好">45.6. 更多机器人，更好</h3>
<div class="paragraph">
<p>在Bisectable发布后不久，人们看到了其他工具的机会。想要在特定提交上运行一些代码吗？当然，这有<a href="https://github.com/perl6/whateverable/wiki/Committable">一个机器人</a>。想下载预构建的rakudo存档而不是浪费你自己的cpu时间吗？是的，<a href="https://github.com/perl6/whateverable/wiki/Shareable">还有另一个机器人</a>。想要绘制一些关于rakudo的信息吗？<a href="https://github.com/perl6/whateverable/wiki/Statisfiable">当然有一个机器人！</a></p>
</div>
<div class="paragraph">
<p>机器人一直持续增加直到我们有了共计<a href="https://github.com/perl6/whateverable/wiki"><strong>17个机器人！</strong></a>有些人认为这些机器人应该停止这样的倍增，也许人们是正确的。但我想重点是，现在很容易在Whateverable上为开发人员创建更多工具，这当然很棒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_好的现在怎么样">45.7. 好的，现在怎么样？</h3>
<div class="paragraph">
<p>因此，bisectable可以在很短的时间内将数千个提交一分为二。它占用的存储空间非常小，并且用户不需要完全理解二分过程。既然二分是免费且容易的，我们可以做更多吗？</p>
</div>
</div>
<div class="sect2">
<h3 id="_是的blin">45.8. 是的，Blin！</h3>
<div class="paragraph">
<p>你可能听说过<a href="https://perl6.party/post/Perl-6-Release-Quality-Assurance-Full-Ecosystem-Toaster">Toaster</a>。Toaster是一种尝试在两个或多个修订版中安装生态系统中的每个模块的工具。例如，假设最后一个版本是2018.12，发布经理即将从主HEAD中删除rakudo版本。然后，您可以在 <code>2018.12`和`master</code> 上运行 toaster，它会显示哪些模块用于干净安装，但不再做。</p>
</div>
<div class="paragraph">
<p>这给了我们Rakudo可能出错的信息，但并没有告诉我究竟是什么。鉴于此帖主要是关于Bisectable，你可能会猜到这是怎么回事。</p>
</div>
</div>
<div class="sect2">
<h3 id="_blin_项目_重新发明了_toasting">45.9. Blin 项目- 重新发明了 Toasting</h3>
<div class="paragraph">
<p>Blin是Rakudo版本的质量保证工具。它用于在rakudo中查找回归，但与Toaster不同，它不仅告诉哪些模块不再可安装，还将rakudo一分为二，以找出导致问题的提交。当然，它是围绕Whateverable构建的，因此额外的功能不会花费太多（甚至不需要很多代码）。作为奖励，它生成了<a href="https://gist.github.com/AlexDaniel/d7b789eefb34db31ee14f16dadd9a3ad">很好的图形</a>来可视化问题如何从模块依赖性传播（虽然这不是很常见）。</p>
</div>
<div class="paragraph">
<p>Blin的一个重要特性是它只尝试安装每个模块一次。因此，如果模块B依赖于模块A，A将被测试并安装一次，然后重新用于B的测试。因为这个过程是并行化的，您可能想知道它是如何实现的。<a href="https://github.com/perl6/Blin/blob/b535dc0d727a61047199dd6ee67d07d626941965/bin/blin.p6#L285">基本上</a>，它使用被低估的`react/whenever`功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-c1"># slightly simplified</span>
<span class="tok-n">react</span> {
    <span class="tok-k">for</span> <span class="tok-nv">@modules</span> -&gt; <span class="tok-nv">$module</span> {
        <span class="tok-n">whenever</span> <span class="tok-n">Promise</span>.<span class="tok-n">allof</span>(<span class="tok-nv">$module</span>.<span class="tok-n">depends</span>.<span class="tok-nb">keys</span>».<span class="tok-n">done</span>) {
            <span class="tok-n">start</span> { <span class="tok-n">process-module</span> <span class="tok-nv">$module</span>, … }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每个模块（我们现在有超过1200个），它会创建自己的`whenever`块，在满足其依赖关系时触发。在我看来，这是Blin中主要逻辑的全部实现，其他一切只是粘合剂以获得Whateverable和Zef协同工作以实现我们所需要的，+一些输出生成。</p>
</div>
<div class="paragraph">
<p>在某种程度上，Blin对我们为Rakudo做质量保证的方式没有太大的改变。Toaster已经能够给我们一些基本的信息（尽管速度较慢），以便我们可以开始调查，而在过去，我知道将奇怪的东西（例如带有依赖关系的完整模块）推入二分法。只是现在它变得更容易了，当<a href="https://en.wikipedia.org/wiki/AI_takeover"><strong>The Day</strong></a>到来时，我不会因机器人滥用而受到惩罚。</p>
</div>
</div>
<div class="sect2">
<h3 id="_未来">45.10. 未来</h3>
<div class="paragraph">
<p><a href="https://github.com/perl6/whateverable/issues">Whateverable</a>和<a href="https://github.com/perl6/Blin/issues">Blin</a>一起有243个未解决的问题。这两个项目都非常有用，而且非常有用，但正如我们所说，它们不是很棒。大多数问题相对容易和有趣，但它们需要时间。如果您有任何帮助，或者您想维护这些项目，请随时这样做。如果你想基于Whateverable构建自己的工具（我们可能需要很多！），请参阅这个<a href="https://gist.github.com/AlexDaniel/88b38af5db9adcf0b711ac3df31dd431">hello world gist</a>。</p>
</div>
<div class="paragraph">
<p>🎅🎄， 🥞</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十四天_使用_perl_6_进行主题建模">46. 第二十四天 - 使用 Perl 6 进行主题建模</h2>
<div class="sectionbody">
<div class="paragraph">
<p>嗨，大家好。</p>
</div>
<div class="paragraph">
<p>今天，让我介绍<a href="https://github.com/titsuki/p6-Algorithm-LDA">Algorithm::LDA</a>。
该模块是用于主题建模的Latent Dirichlet Allocation（即LDA）实现。</p>
</div>
<div class="sect2">
<h3 id="_介绍_4">46.1. 介绍</h3>
<div class="paragraph">
<p>什么是LDA？LDA是一种流行的无监督机器学习方法。
它模拟文档生成过程，并将每个文档表示为主题的混合。</p>
</div>
<div class="paragraph">
<p>那么，“混合主题”是什么意思呢？图1显示了一篇文章，其中一些单词以三种颜色突出显示：黄色，粉红色和蓝色。关于遗传学的词语用黄色标出; 关于进化生物学的文字用粉红色标出; 有关数据分析的文字标有蓝色。想象一下，本文中的所有单词都是彩色的，然后我们可以将这篇文章表示为主题（即颜色）的混合。</p>
</div>
<div class="paragraph">
<p>图1 :( 此图片来自“概率主题模型”。（David Blei 2012））
<a href="https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830">![图。1</a>](<a href="https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830" class="bare">https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830</a>)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">好的，那么我将在下一节中演示如何使用Algorithm </dt>
<dd>
<p>LDA。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_建模报价">46.2. 建模报价</h3>
<div class="paragraph">
<p>在本文中，我们将探索<a href="https://www.wikiquote.org/">Wikiquote</a>。Wikiquote是一个提供源代码报价的云源平台。
通过使用Wikiquote API，我们获得用于LDA估计的报价。之后，我们执行LDA并绘制结果。
最后，我们使用生成的模型创建信息检索应用程序。</p>
</div>
<div class="sect3">
<h4 id="_初步">46.2.1. 初步</h4>
<div class="sect4">
<h5 id="_wikiquote_api">Wikiquote API</h5>
<div class="paragraph">
<p>Wikiquote具有<a href="https://en.wikiquote.org/w/api.php?action=help&amp;modules=query">动作API</a>，提供获取Wikiquote资源的方法。
例如，您可以按如下方式获取主页面的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ curl <span class="tok-s2">&quot;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;titles=Main%20Page&amp;rvprop=content&amp;format=json&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span></span>{&quot;batchcomplete&quot;:&quot;&quot;,&quot;warnings&quot;:{&quot;main&quot;:{&quot;*&quot;:&quot;Subscribe to the mediawiki-api-announce mailing list at <span class="tok-p">&lt;</span><span class="tok-nt">https:</span><span class="tok-err">//</span><span class="tok-na">lists</span><span class="tok-err">.</span><span class="tok-na">wikimedia</span><span class="tok-err">.</span><span class="tok-na">org</span><span class="tok-err">/</span><span class="tok-na">mailman</span><span class="tok-err">/</span><span class="tok-na">listinfo</span><span class="tok-err">/</span><span class="tok-na">mediawiki-api-announce</span><span class="tok-p">&gt;</span> for notice of API deprecations and breaking changes. Use [[Special:ApiFeatureUsage]] to see usage of deprecated features by your application.&quot;},&quot;revisions&quot;:{&quot;*&quot;:&quot;Because \&quot;rvslots\&quot; was not specified, a legacy format has been used for the output. This format is deprecated, and in the future the new format will always be used.&quot;}},&quot;query&quot;:{&quot;pages&quot;:{&quot;1&quot;:{&quot;pageid&quot;:1,&quot;ns&quot;:0,&quot;title&quot;:&quot;Main Page&quot;,&quot;revisions&quot;:[{&quot;contentformat&quot;:&quot;text/x-wiki&quot;,&quot;contentmodel&quot;:&quot;wikitext&quot;,&quot;*&quot;:&quot;\n
{{Main page header}}
\n
{{Main Page Quote of the day}}
\n<span class="tok-p">&lt;/</span><span class="tok-nt">div</span><span class="tok-p">&gt;</span>\n\n \n{{Main Page Selected pages}}\n{{Main categories}}\n\n\n \n{{New pages}}\n{{Main Page Community}}\n\n\n\n==Wikiquote&#39;s sister projects==\n{{otherwiki}}\n\n==Wikiquote languages==\n{{Wikiquotelang}}\n\n__NOTOC__ __NOEDITSECTION__\n{{noexternallanglinks:ang|simple}}\n[[Category:Main page]]&quot;}]}}}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_www">WWW</h5>
<div class="paragraph">
<p><a href="https://github.com/zoffixznet/perl6-WWW">WWW</a>通过Zoffix Znet是它提供了易于使用的API，包括获取和解析JSON非常简单的库。
例如，正如README所说，您可以轻松地按`jget(URL)&lt;HASHKEY&gt;`样式获取内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nb">say</span> <span class="tok-n">jget</span>(<span class="tok-s">&#39;https://httpbin.org/get?foo=42&amp;bar=x&#39;</span>)<span class="tok-s">&lt;args&gt;&lt;foo&gt;</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要安装WWW：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>zef install WWW</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_chartgnuplot">Chart::Gnuplot</h5>
<div class="paragraph">
<p><a href="https://github.com/titsuki/p6-Chart-Gnuplot">Chart::Gnuplot</a> by titsuki是<a href="http://www.gnuplot.info/">gnuplot</a>的绑定。</p>
</div>
<div class="paragraph">
<p>要安装 Chart::Gnuplot：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">zef</span> <span class="tok-n">install</span> <span class="tok-n">Chart::Gnuplot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在本文中，我们使用此模块; 但是，如果你不熟悉gnuplot，有很多选择：<a href="https://github.com/moritz/svg-plot">SVG::Plot</a>，<a href="https://github.com/azawawi/perl6-graphics-plplot">Graphics::PLplot</a>，<a href="https://0racle.info/articles/matplotlib_in_p6_intro">通过Inline::Python调用matplotlib函数</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_来自nltk的stopwords">来自NLTK的Stopwords</h5>
<div class="paragraph">
<p>NLTK是一个用于自然语言处理的工具包。
不仅是 API，它还提供语料库。
您可以通过“70”获得英语的停用词。关键词语料库“：<a href="http://www.nltk.org/nltk_data/">http</a>：//www.nltk.org/nltk_data/</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习1获取报价并创建已清理的文档">46.2.2. 练习1：获取报价并创建已清理的文档</h4>
<div class="paragraph">
<p>一开始，我们必须从Wikiquote获取引用并创建干净的文档。</p>
</div>
<div class="paragraph">
<p>本部分的主要目标是根据以下格式创建文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-s">&lt;docid&gt;</span> <span class="tok-s">&lt;personid&gt;</span> <span class="tok-s">&lt;word&gt;</span> <span class="tok-s">&lt;word&gt;</span> <span class="tok-s">&lt;word&gt;</span> ...
<span class="tok-s">&lt;docid&gt;</span> <span class="tok-s">&lt;personid&gt;</span> <span class="tok-s">&lt;word&gt;</span> <span class="tok-s">&lt;word&gt;</span> <span class="tok-s">&lt;word&gt;</span> ...
<span class="tok-s">&lt;docid&gt;</span> <span class="tok-s">&lt;personid&gt;</span> <span class="tok-s">&lt;word&gt;</span> <span class="tok-s">&lt;word&gt;</span> <span class="tok-s">&lt;word&gt;</span> ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">v6</span>.<span class="tok-n">c</span>;
<span class="tok-k">use</span> <span class="tok-n">WWW</span>;
<span class="tok-k">use</span> <span class="tok-n">URI::Escape</span>;

<span class="tok-k">sub</span> <span class="tok-n">get-members-from-category</span>(<span class="tok-nb">Str</span> <span class="tok-nv">$category</span> --&gt; <span class="tok-nb">List</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$member-url</span> = <span class="tok-s">&quot;https://en.wikiquote.org/w/api.php?action=query&amp;list=categorymembers&amp;cmtitle={$category}&amp;cmlimit=100&amp;format=json&quot;</span>;
    @(<span class="tok-n">jget</span>(<span class="tok-nv">$member-url</span>)<span class="tok-s">&lt;query&gt;&lt;categorymembers&gt;</span>.<span class="tok-nb">map</span>(*<span class="tok-s">&lt;title&gt;</span>));
}

<span class="tok-k">sub</span> <span class="tok-n">get-pages</span>(<span class="tok-nb">Str</span> <span class="tok-nv">@members</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$batch</span> = <span class="tok-mi">50</span> --&gt; <span class="tok-nb">List</span>) {
    <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$start</span> = <span class="tok-mi">0</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@pages</span>;
    <span class="tok-k">while</span> <span class="tok-nv">$start</span> &lt; <span class="tok-nv">@members</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$list</span> = <span class="tok-nv">@members</span>[<span class="tok-nv">$start</span><span class="tok-o">..^</span><span class="tok-nb">List</span>(<span class="tok-nv">$start</span> + <span class="tok-nv">$batch</span>, +<span class="tok-nv">@members</span>).<span class="tok-nb">min</span>].<span class="tok-nb">map</span>({ <span class="tok-n">uri_escape</span>(<span class="tok-nv">$_</span>) }).<span class="tok-nb">join</span>(<span class="tok-s">&#39;%7C&#39;</span>);
        <span class="tok-k">my</span> <span class="tok-nv">$url</span> = <span class="tok-s">&quot;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2&amp;titles={$list}&quot;</span>;
        <span class="tok-nv">@pages</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-n">jget</span>(<span class="tok-nv">$url</span>)<span class="tok-s">&lt;query&gt;&lt;pages&gt;</span>.<span class="tok-nb">map</span>({ %(<span class="tok-nb">body</span> =&gt; .<span class="tok-s">&lt;revisions&gt;</span>[<span class="tok-mi">0</span>]<span class="tok-s">&lt;content&gt;</span>, <span class="tok-n">title</span> =&gt; .<span class="tok-s">&lt;title&gt;</span>) });
        <span class="tok-nv">$start</span> += <span class="tok-nv">$batch</span>;
    }
    <span class="tok-nv">@pages</span>;
}

<span class="tok-k">sub</span> <span class="tok-n">create-documents-from-pages</span>(<span class="tok-nv">@pages</span>, <span class="tok-nv">@members</span> --&gt; <span class="tok-nb">List</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">@documents</span>;
    <span class="tok-k">for</span> <span class="tok-nv">@pages</span> -&gt; <span class="tok-nv">$page</span> {
        <span class="tok-k">my</span> <span class="tok-nv">@quotations</span> = <span class="tok-nv">$page&lt;body&gt;</span>.<span class="tok-nb">split</span>(<span class="tok-s">&quot;\n&quot;</span>)\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/</span>, { <span class="tok-nv">$&lt;text&gt;</span> }, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/</span>, { <span class="tok-nv">$&lt;text&gt;</span> }, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;[&quot;</span>, <span class="tok-s">&quot;[&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;]&quot;</span>, <span class="tok-s">&quot;]&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;&amp;amp;&quot;</span>, <span class="tok-s">&quot;&amp;&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;&amp;nbsp;&quot;</span>, <span class="tok-s">&quot;&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/:i [ \&lt;\/?\s?br\&gt; | \&lt;br\s?\/?\&gt; ]/</span>, <span class="tok-s">&quot; &quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">grep</span>(<span class="tok-sr">/^\*&lt;-[*]&gt;/</span>)\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/^\*\s+/</span>, <span class="tok-s">&quot;&quot;</span>));

        <span class="tok-c1"># Note: The order of array wikiquote API returned is agnostic.</span>
        <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$index</span> = <span class="tok-nv">@members</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">grep</span>({ .<span class="tok-nb">value</span> <span class="tok-o">eq</span> <span class="tok-nv">$page&lt;title&gt;</span> }).<span class="tok-nb">map</span>(*.<span class="tok-nb">key</span>).<span class="tok-n">head</span>;
        <span class="tok-nv">@documents</span>.<span class="tok-nb">push</span>(%(<span class="tok-nb">body</span> =&gt; <span class="tok-nv">$_</span>, <span class="tok-n">personid</span> =&gt; <span class="tok-nv">$index</span>)) <span class="tok-k">for</span> <span class="tok-nv">@quotations</span>;
    }
    <span class="tok-nv">@documents</span>.<span class="tok-nb">sort</span>({ <span class="tok-nv">$^a&lt;personid&gt;</span> &lt;=&gt; <span class="tok-nv">$^b&lt;personid&gt;</span> }).<span class="tok-nb">pairs</span>.<span class="tok-nb">map</span>({ %(<span class="tok-n">docid</span> =&gt; .<span class="tok-nb">key</span>, <span class="tok-n">personid</span> =&gt; .<span class="tok-nb">value</span><span class="tok-s">&lt;personid&gt;</span>, <span class="tok-nb">body</span> =&gt; .<span class="tok-nb">value</span><span class="tok-s">&lt;body&gt;</span>) }).<span class="tok-n">list</span>
}

<span class="tok-k">my</span> <span class="tok-nb">Str</span> <span class="tok-nv">@members</span> = <span class="tok-n">get-members-from-category</span>(<span class="tok-s">&quot;Category:1954_births&quot;</span>);
<span class="tok-k">my</span> <span class="tok-nv">@pages</span> = <span class="tok-n">get-pages</span>(<span class="tok-nv">@members</span>);
<span class="tok-k">my</span> <span class="tok-nv">@documents</span> = <span class="tok-n">create-documents-from-pages</span>(<span class="tok-nv">@pages</span>, <span class="tok-nv">@members</span>);

<span class="tok-k">my</span> <span class="tok-nv">$docfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;documents.txt&quot;</span>, :<span class="tok-n">w</span>;
<span class="tok-nv">$docfh</span>.<span class="tok-nb">say</span>((.<span class="tok-s">&lt;docid&gt;</span>, .<span class="tok-s">&lt;personid&gt;</span>, .<span class="tok-s">&lt;body&gt;</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>)) <span class="tok-k">for</span> <span class="tok-nv">@documents</span>;
<span class="tok-nv">$docfh</span>.<span class="tok-nb">close</span>;

<span class="tok-k">my</span> <span class="tok-nv">$memfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;members.txt&quot;</span>, :<span class="tok-n">w</span>;
<span class="tok-nv">$memfh</span>.<span class="tok-nb">say</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-nv">@members</span>;
<span class="tok-nv">$memfh</span>.<span class="tok-nb">close</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们获得“Category：1954births”页面中列出的成员。我选择了Perl 6设计师诞生的那一年：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nb">Str</span> <span class="tok-nv">@members</span> = <span class="tok-n">get-members-from-category</span>(<span class="tok-s">&quot;Category:1954_births&quot;</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中，`get-members-from-category`通过维基语录API获取成员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">get-members-from-category</span>(<span class="tok-nb">Str</span> <span class="tok-nv">$category</span> --&gt; <span class="tok-nb">List</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$member-url</span> = <span class="tok-s">&quot;https://en.wikiquote.org/w/api.php?action=query&amp;list=categorymembers&amp;cmtitle={$category}&amp;cmlimit=100&amp;format=json&quot;</span>;
    @(<span class="tok-n">jget</span>(<span class="tok-nv">$member-url</span>)<span class="tok-s">&lt;query&gt;&lt;categorymembers&gt;</span>.<span class="tok-nb">map</span>(*<span class="tok-s">&lt;title&gt;</span>));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，调用`get-pages`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@pages</span> = <span class="tok-n">get-pages</span>(<span class="tok-nv">@members</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get-pages</code> 获取给定标题（即成员）页面的子例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">get-pages</span>(<span class="tok-nb">Str</span> <span class="tok-nv">@members</span>, <span class="tok-nb">Int</span> <span class="tok-nv">$batch</span> = <span class="tok-mi">50</span> --&gt; <span class="tok-nb">List</span>) {
    <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$start</span> = <span class="tok-mi">0</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@pages</span>;
    <span class="tok-k">while</span> <span class="tok-nv">$start</span> &lt; <span class="tok-nv">@members</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$list</span> = <span class="tok-nv">@members</span>[<span class="tok-nv">$start</span><span class="tok-o">..^</span><span class="tok-nb">List</span>(<span class="tok-nv">$start</span> + <span class="tok-nv">$batch</span>, +<span class="tok-nv">@members</span>).<span class="tok-nb">min</span>].<span class="tok-nb">map</span>({ <span class="tok-n">uri_escape</span>(<span class="tok-nv">$_</span>) }).<span class="tok-nb">join</span>(<span class="tok-s">&#39;%7C&#39;</span>);
        <span class="tok-k">my</span> <span class="tok-nv">$url</span> = <span class="tok-s">&quot;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2&amp;titles={$list}&quot;</span>;
        <span class="tok-nv">@pages</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-n">jget</span>(<span class="tok-nv">$url</span>)<span class="tok-s">&lt;query&gt;&lt;pages&gt;</span>.<span class="tok-nb">map</span>({ %(<span class="tok-nb">body</span> =&gt; .<span class="tok-s">&lt;revisions&gt;</span>[<span class="tok-mi">0</span>]<span class="tok-s">&lt;content&gt;</span>, <span class="tok-n">title</span> =&gt; .<span class="tok-s">&lt;title&gt;</span>) });
        <span class="tok-nv">$start</span> += <span class="tok-nv">$batch</span>;
    }
    <span class="tok-nv">@pages</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`@members[$start..^List($start + $batch, +@members).min]<code>是一段长度</code>$batch`，并且切片的元素由百分比编码`uri_escase`和联合`%7C`（即，编码的管道符号百分比）。
在这种情况下，结果之一`$list`是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">Mumia</span><span class="tok-nv">%20Abu-Jamal%7CRene%20Balcer%7CIain%20Banks%7CGerard%20Batten%7CChristie%20Brinkley%7CJames%20Cameron%20%28director%29%7CEugene%20Chadbourne%7CJackie%20Chan%7CChang%20Yu-hern%7CLee%20Child%7CHugo%20Ch%C3%A1vez%7CDon%20Coscarelli%7CElvis%20Costello%7CDaayiee%20Abdullah%7CThomas%20H</span>.<span class="tok-nv">%20Davenport%7CGerardine%20DeSanctis%7CAl%20Di%20Meola%7CKevin%20Dockery%20%28author%29%7CJohn%20Doe%20%28musician%29%7CF</span>.<span class="tok-nv">%20J</span>.<span class="tok-nv">%20Duarte%7CIain%20Duncan%20Smith%7CHerm%20Edwards%7CAbdel%20Fattah%20el-Sisi%7CRob%20Enderle%7CRecep%20Tayyip%20Erdo%C4%9Fan%7CAlejandro%20Pe%C3%B1a%20Esclusa%7CHarvey%20Fierstein%7CCarly%20Fiorina%7CGary%20L</span>.<span class="tok-nv">%20Francione%7CAshrita%20Furman%7CMary%20Gaitskill%7CGeorge%20Galloway%7C%C5%BDeljko%20Glasnovi%C4%87%7CGary%20Hamel%7CFran%C3%A7ois%20Hollande%7CKazuo%20Ishiguro%7CJean-Claude%20Juncker%7CAnish%20Kapoor%7CGuy%20Kawasaki%7CRobert%20Francis%20Kennedy%2C%20Jr</span>.<span class="tok-nv">%7CLawrence%20M</span>.<span class="tok-nv">%20Krauss%7CAnatoly%20Kudryavitsky%7CAnne%20Lamott%7CJoep%20Lange%7CAng%20Lee%7CLi%20Bin%7CRay%20Liotta%7CPeter%20Lipton%7CJames%20D</span>.<span class="tok-nv">%20Macdonald%7CKen%20MacLeod</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>get-pages`子例程使用哈希上下文相关器</code>%()`来创建哈希序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-nv">@pages</span>.<span class="tok-nb">push</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-n">jget</span>(<span class="tok-nv">$url</span>)<span class="tok-s">&lt;query&gt;&lt;pages&gt;</span>.<span class="tok-nb">map</span>({ %(<span class="tok-nb">body</span> =&gt; .<span class="tok-s">&lt;revisions&gt;</span>[<span class="tok-mi">0</span>]<span class="tok-s">&lt;content&gt;</span>, <span class="tok-n">title</span> =&gt; .<span class="tok-s">&lt;title&gt;</span>) });</code></pre>
</div>
</div>
<div class="paragraph">
<p>在那之后，我们调用 <code>create-documents-from-pages</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@documents</span> = <span class="tok-n">create-documents-from-pages</span>(<span class="tok-nv">@pages</span>, <span class="tok-nv">@members</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>create-documents-from-pages</code> 从每个页面创建文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">create-documents-from-pages</span>(<span class="tok-nv">@pages</span>, <span class="tok-nv">@members</span> --&gt; <span class="tok-nb">List</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">@documents</span>;
    <span class="tok-k">for</span> <span class="tok-nv">@pages</span> -&gt; <span class="tok-nv">$page</span> {
        <span class="tok-k">my</span> <span class="tok-nv">@quotations</span> = <span class="tok-nv">$page&lt;body&gt;</span>.<span class="tok-nb">split</span>(<span class="tok-s">&quot;\n&quot;</span>)\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/</span>, { <span class="tok-nv">$&lt;text&gt;</span> }, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/</span>, { <span class="tok-nv">$&lt;text&gt;</span> }, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;[&quot;</span>, <span class="tok-s">&quot;[&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;]&quot;</span>, <span class="tok-s">&quot;]&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;&amp;amp;&quot;</span>, <span class="tok-s">&quot;&amp;&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-s">&quot;&amp;nbsp;&quot;</span>, <span class="tok-s">&quot;&quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/:i [ \&lt;\/?\s?br\&gt; | \&lt;br\s?\/?\&gt; ]/</span>, <span class="tok-s">&quot; &quot;</span>, :<span class="tok-n">g</span>))\
        .<span class="tok-nb">grep</span>(<span class="tok-sr">/^\*&lt;-[*]&gt;/</span>)\
        .<span class="tok-nb">map</span>(*.<span class="tok-nb">subst</span>(<span class="tok-sr">/^\*\s+/</span>, <span class="tok-s">&quot;&quot;</span>));

        <span class="tok-c1"># Note: The order of array wikiquote API returned is agnostic.</span>
        <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$index</span> = <span class="tok-nv">@members</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">grep</span>({ .<span class="tok-nb">value</span> <span class="tok-o">eq</span> <span class="tok-nv">$page&lt;title&gt;</span> }).<span class="tok-nb">map</span>(*.<span class="tok-nb">key</span>).<span class="tok-n">head</span>;
        <span class="tok-nv">@documents</span>.<span class="tok-nb">push</span>(%(<span class="tok-nb">body</span> =&gt; <span class="tok-nv">$_</span>, <span class="tok-n">personid</span> =&gt; <span class="tok-nv">$index</span>)) <span class="tok-k">for</span> <span class="tok-nv">@quotations</span>;
    }
    <span class="tok-nv">@documents</span>.<span class="tok-nb">sort</span>({ <span class="tok-nv">$^a&lt;personid&gt;</span> &lt;=&gt; <span class="tok-nv">$^b&lt;personid&gt;</span> }).<span class="tok-nb">pairs</span>.<span class="tok-nb">map</span>({ %(<span class="tok-n">docid</span> =&gt; .<span class="tok-nb">key</span>, <span class="tok-n">personid</span> =&gt; .<span class="tok-nb">value</span><span class="tok-s">&lt;personid&gt;</span>, <span class="tok-nb">body</span> =&gt; .<span class="tok-nb">value</span><span class="tok-s">&lt;body&gt;</span>) }).<span class="tok-n">list</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`.map(<strong>.subst(/\<a href="https://docs.perl6.org/language/regexes#Named_captures">\[$&lt;text&gt;=(&#8592;[\[]|</a>&gt;?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;?)\]\]/, { $&lt;text&gt; }, :g))<code>和</code>.map(</strong>.subst(/\[\[$&lt;text&gt;=(&#8592;[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))<code>是隐藏命令，提取文本以显示和删除文本，以便从锚文本进行内部链接。例如，</code><a id="Perl"></a><code>被缩减为`Perl</code>。有关更多语法信息，请参阅：[https]：<a href="https://docs.perl6.org/language/regexes#Named_captures">//docs.perl6.org/language/regexes#Named_captures</a>或<a href="https://docs.perl6.org/routine/subst" class="bare">https://docs.perl6.org/routine/subst</a></p>
</div>
<div class="paragraph">
<p>经过一些清理操作（.eg，<code>.map(*.subst("[", "[", :g))</code>）后，我们提取引号线。</p>
</div>
<div class="paragraph">
<p>`.grep(/^*&#8592;[*]&gt;/)`查找以单星号开头的行，因为大多数引号都出现在这种行中。</p>
</div>
<div class="paragraph">
<p>接下来，`.map(<strong>.subst(/^\</strong>\s+/, ""))`删除每个星号，因为星号本身不是每个报价的组成部分。</p>
</div>
<div class="paragraph">
<p>最后，我们保存文档和成员（即标题）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">$docfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;documents.txt&quot;</span>, :<span class="tok-n">w</span>;
<span class="tok-nv">$docfh</span>.<span class="tok-nb">say</span>((.<span class="tok-s">&lt;docid&gt;</span>, .<span class="tok-s">&lt;personid&gt;</span>, .<span class="tok-s">&lt;body&gt;</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>)) <span class="tok-k">for</span> <span class="tok-nv">@documents</span>;
<span class="tok-nv">$docfh</span>.<span class="tok-nb">close</span>;

<span class="tok-k">my</span> <span class="tok-nv">$memfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;members.txt&quot;</span>, :<span class="tok-n">w</span>;
<span class="tok-nv">$memfh</span>.<span class="tok-nb">say</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-nv">@members</span>;
<span class="tok-nv">$memfh</span>.<span class="tok-nb">close</span>;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习2执行lda并可视化结果">46.2.3. 练习2：执行LDA并可视化结果</h4>
<div class="paragraph">
<p>在上一节中，我们保存了已清理的文档。
在本节中，我们使用文档进行LDA估计并将结果可视化。
本部分的目标是绘制文档主题分布并编写主题词表。</p>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">v6</span>.<span class="tok-n">c</span>;
<span class="tok-k">use</span> <span class="tok-n">Algorithm::LDA</span>;
<span class="tok-k">use</span> <span class="tok-n">Algorithm::LDA::Formatter</span>;
<span class="tok-k">use</span> <span class="tok-n">Algorithm::LDA::LDAModel</span>;
<span class="tok-k">use</span> <span class="tok-n">Chart::Gnuplot</span>;
<span class="tok-k">use</span> <span class="tok-n">Chart::Gnuplot::Subset</span>;

<span class="tok-k">sub</span> <span class="tok-n">create-model</span>(<span class="tok-nv">@documents</span> --&gt; <span class="tok-n">Algorithm::LDA::LDAModel</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$stopwords</span> = <span class="tok-s">&quot;stopwords/english&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">Set</span>;
    <span class="tok-k">my</span> <span class="tok-nv">&amp;tokenizer</span> = -&gt; <span class="tok-nv">$line</span> { <span class="tok-nv">$line</span>.<span class="tok-n">words</span>.<span class="tok-nb">map</span>(*.<span class="tok-nb">lc</span>).<span class="tok-nb">grep</span>(-&gt; <span class="tok-nv">$w</span> { (<span class="tok-nv">$stopwords</span> !(<span class="tok-n">cont</span>) <span class="tok-nv">$w</span>) <span class="tok-o">and</span> <span class="tok-nv">$w</span> !~~<span class="tok-sr"> /^[ &lt;:S&gt; | &lt;:P&gt; ]+$/</span> }) };
    <span class="tok-k">my</span> (<span class="tok-nv">$documents</span>, <span class="tok-nv">$vocabs</span>) = <span class="tok-n">Algorithm::LDA::Formatter</span>.<span class="tok-n">from-plain</span>(<span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> ($, $, *<span class="tok-nv">@body</span>) = .<span class="tok-n">words</span>; <span class="tok-nv">@body</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>) }), <span class="tok-nv">&amp;tokenizer</span>);
    <span class="tok-k">my</span> <span class="tok-n">Algorithm::LDA</span> <span class="tok-nv">$lda</span> .= <span class="tok-nb">new</span>(:<span class="tok-nv">$documents</span>, :<span class="tok-nv">$vocabs</span>);
    <span class="tok-k">my</span> <span class="tok-n">Algorithm::LDA::LDAModel</span> <span class="tok-nv">$model</span> = <span class="tok-nv">$lda</span>.<span class="tok-n">fit</span>(:<span class="tok-n">num-topics</span>(<span class="tok-mi">10</span>), :<span class="tok-n">num-iterations</span>(<span class="tok-mi">500</span>), :<span class="tok-n">seed</span>(<span class="tok-mi">2018</span>));
    <span class="tok-nv">$model</span>
}

<span class="tok-k">sub</span> <span class="tok-n">plot-topic-distribution</span>(<span class="tok-nv">$model</span>, <span class="tok-nv">@members</span>, <span class="tok-nv">@documents</span>, <span class="tok-nv">$search-regex</span> = <span class="tok-sr">rx/Larry/</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$target-personid</span> = <span class="tok-nv">@members</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">grep</span>({ .<span class="tok-nb">value</span> ~~ <span class="tok-nv">$search-regex</span> }).<span class="tok-nb">map</span>(*.<span class="tok-nb">key</span>).<span class="tok-n">head</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$docid</span> = <span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> (<span class="tok-nv">$docid</span>, <span class="tok-nv">$personid</span>, *<span class="tok-nv">@body</span>) = .<span class="tok-n">words</span>; %(<span class="tok-n">docid</span> =&gt; <span class="tok-nv">$docid</span>, <span class="tok-n">personid</span> =&gt; <span class="tok-nv">$personid</span>, <span class="tok-nb">body</span> =&gt; <span class="tok-nv">@body</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>)) })\
    .<span class="tok-nb">grep</span>({ .<span class="tok-s">&lt;personid&gt;</span> == <span class="tok-nv">$target-personid</span> <span class="tok-o">and</span> .<span class="tok-s">&lt;body&gt;</span> ~~<span class="tok-sr"> /:i &lt;&lt; perl &gt;&gt;/</span>}).<span class="tok-nb">map</span>(*<span class="tok-s">&lt;docid&gt;</span>).<span class="tok-n">head</span>;

    <span class="tok-n">note</span>(<span class="tok-s">&quot;@documents[$docid] is selected&quot;</span>);
    <span class="tok-k">my</span> (<span class="tok-nv">$row-size</span>, <span class="tok-nv">$col-size</span>) = <span class="tok-nv">$model</span>.<span class="tok-n">document-topic-matrix</span>.<span class="tok-nb">shape</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@doc-topic</span> = <span class="tok-k">gather</span> <span class="tok-k">for</span> (<span class="tok-nv">$docid</span> <span class="tok-o">X</span> ^<span class="tok-nv">$col-size</span>) -&gt; (<span class="tok-nv">$i</span>, <span class="tok-nv">$j</span>) { <span class="tok-k">take</span> <span class="tok-nv">$model</span>.<span class="tok-n">document-topic-matrix</span>[<span class="tok-nv">$i</span>;<span class="tok-nv">$j</span>]; }
    <span class="tok-k">my</span> <span class="tok-n">Chart::Gnuplot</span> <span class="tok-nv">$gnu</span> .= <span class="tok-nb">new</span>(:<span class="tok-n">terminal</span>(<span class="tok-s">&quot;png&quot;</span>), :<span class="tok-n">filename</span>(<span class="tok-s">&quot;topics.png&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">command</span>(<span class="tok-s">&quot;set boxwidth 0.5 relative&quot;</span>);
    <span class="tok-k">my</span> <span class="tok-n">AnyTicsTic</span> <span class="tok-nv">@tics</span> = <span class="tok-nv">@doc-topic</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">map</span>({ %(:<span class="tok-n">label</span>(.<span class="tok-nb">key</span>), :<span class="tok-n">pos</span>(.<span class="tok-nb">key</span>)) });
    <span class="tok-nv">$gnu</span>.<span class="tok-n">legend</span>(:<span class="tok-n">off</span>);
    <span class="tok-nv">$gnu</span>.<span class="tok-n">xlabel</span>(:<span class="tok-n">label</span>(<span class="tok-s">&quot;Topic&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">ylabel</span>(:<span class="tok-n">label</span>(<span class="tok-s">&quot;P(z|theta,d)&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">xtics</span>(:<span class="tok-n">tics</span>(<span class="tok-nv">@tics</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">plot</span>(:<span class="tok-n">vertices</span>(<span class="tok-nv">@doc-topic</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">map</span>({ @(.<span class="tok-nb">key</span>, .<span class="tok-nb">value</span>.<span class="tok-nb">exp</span>) })), :<span class="tok-n">style</span>(<span class="tok-s">&quot;boxes&quot;</span>), :<span class="tok-n">fill</span>(<span class="tok-s">&quot;solid&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">dispose</span>;
}

<span class="tok-k">sub</span> <span class="tok-n">write-nbest</span>(<span class="tok-nv">$model</span>) {
  <span class="tok-k">my</span> <span class="tok-nv">$topics</span> := <span class="tok-nv">$model</span>.<span class="tok-n">nbest-words-per-topic</span>(<span class="tok-mi">10</span>);
  <span class="tok-k">for</span> ^(<span class="tok-mi">10</span><span class="tok-o">/</span><span class="tok-mi">5</span>) -&gt; <span class="tok-nv">$part-i</span> {
    <span class="tok-nb">say</span> <span class="tok-s">&quot;|&quot;</span> ~ (^<span class="tok-mi">5</span>).<span class="tok-nb">map</span>(-&gt; <span class="tok-nv">$t</span> { <span class="tok-s">&quot;topic { $part-i * 5 + $t }&quot;</span> }).<span class="tok-nb">join</span>(<span class="tok-s">&quot;|&quot;</span>) ~ <span class="tok-s">&quot;|&quot;</span>;
    <span class="tok-nb">say</span> <span class="tok-s">&quot;|&quot;</span> ~ (^<span class="tok-mi">5</span>).<span class="tok-nb">map</span>({ <span class="tok-s">&quot;----&quot;</span> }).<span class="tok-nb">join</span>(<span class="tok-s">&quot;|&quot;</span>) ~ <span class="tok-s">&quot;|&quot;</span>;
    <span class="tok-k">for</span> ^<span class="tok-mi">10</span> -&gt; <span class="tok-nv">$rank</span> {
        <span class="tok-nb">say</span> <span class="tok-s">&quot;|&quot;</span> ~ <span class="tok-k">gather</span> <span class="tok-k">for</span> (<span class="tok-nv">$part-i</span> * <span class="tok-mi">5</span>)..^(<span class="tok-nv">$part-i</span> * <span class="tok-mi">5</span> + <span class="tok-mi">5</span>) -&gt; <span class="tok-nv">$topic</span> {
            <span class="tok-k">take</span> @(<span class="tok-nv">$topics</span>)[<span class="tok-nv">$topic</span>;<span class="tok-nv">$rank</span>].<span class="tok-nb">key</span>;
        }.<span class="tok-nb">join</span>(<span class="tok-s">&quot;|&quot;</span>) ~ <span class="tok-s">&quot;|&quot;</span>;
    }
    <span class="tok-s">&quot;&quot;</span>.<span class="tok-nb">say</span>;
  }
}

<span class="tok-k">sub</span> <span class="tok-n">save-model</span>(<span class="tok-nv">$model</span>) {
  <span class="tok-k">my</span> <span class="tok-nv">@document-topic-matrix</span> := <span class="tok-nv">$model</span>.<span class="tok-n">document-topic-matrix</span>;
  <span class="tok-k">my</span> (<span class="tok-nv">$document-size</span>, <span class="tok-nv">$topic-size</span>) = <span class="tok-nv">@document-topic-matrix</span>.<span class="tok-nb">shape</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$doctopicfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;document-topic.txt&quot;</span>, :<span class="tok-n">w</span>;

  <span class="tok-nv">$doctopicfh</span>.<span class="tok-n">say:</span> (<span class="tok-nv">$document-size</span>, <span class="tok-nv">$topic-size</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  <span class="tok-k">for</span> ^<span class="tok-nv">$document-size</span> -&gt; <span class="tok-nv">$doc-i</span> {
    <span class="tok-nv">$doctopicfh</span>.<span class="tok-n">say:</span> <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic</span> { <span class="tok-k">take</span> <span class="tok-nv">@document-topic-matrix</span>[<span class="tok-nv">$doc-i</span>;<span class="tok-nv">$topic</span>] }.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  }
  <span class="tok-nv">$doctopicfh</span>.<span class="tok-nb">close</span>;

  <span class="tok-k">my</span> <span class="tok-nv">@topic-word-matrix</span> := <span class="tok-nv">$model</span>.<span class="tok-n">topic-word-matrix</span>;
  <span class="tok-k">my</span> ($, <span class="tok-nv">$word-size</span>) = <span class="tok-nv">@topic-word-matrix</span>.<span class="tok-nb">shape</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$topicwordfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;topic-word.txt&quot;</span>, :<span class="tok-n">w</span>;

  <span class="tok-nv">$topicwordfh</span>.<span class="tok-n">say:</span> (<span class="tok-nv">$topic-size</span>, <span class="tok-nv">$word-size</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic-i</span> {
    <span class="tok-nv">$topicwordfh</span>.<span class="tok-n">say:</span> <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$word-size</span> -&gt; <span class="tok-nv">$word</span> { <span class="tok-k">take</span> <span class="tok-nv">@topic-word-matrix</span>[<span class="tok-nv">$topic-i</span>;<span class="tok-nv">$word</span>] }.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  }
  <span class="tok-nv">$topicwordfh</span>.<span class="tok-nb">close</span>;

  <span class="tok-k">my</span> <span class="tok-nv">@vocabulary</span> := <span class="tok-nv">$model</span>.<span class="tok-n">vocabulary</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$vocabfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;vocabulary.txt&quot;</span>, :<span class="tok-n">w</span>;

  <span class="tok-nv">$vocabfh</span>.<span class="tok-nb">say</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-nv">@vocabulary</span>;
  <span class="tok-nv">$vocabfh</span>.<span class="tok-nb">close</span>;
}

<span class="tok-k">my</span> <span class="tok-nv">@documents</span> = <span class="tok-s">&quot;documents.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
<span class="tok-k">my</span> <span class="tok-nv">$model</span> = <span class="tok-n">create-model</span>(<span class="tok-nv">@documents</span>);
<span class="tok-k">my</span> <span class="tok-nv">@members</span> = <span class="tok-s">&quot;members.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
<span class="tok-n">plot-topic-distribution</span>(<span class="tok-nv">$model</span>, <span class="tok-nv">@members</span>, <span class="tok-nv">@documents</span>);
<span class="tok-n">write-nbest</span>(<span class="tok-nv">$model</span>);
<span class="tok-n">save-model</span>(<span class="tok-nv">$model</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们加载已清理的文档并调用`create-model`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@documents</span> = <span class="tok-s">&quot;documents.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
<span class="tok-k">my</span> <span class="tok-nv">$model</span> = <span class="tok-n">create-model</span>(<span class="tok-nv">@documents</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>`create-model`通过加载给定文档来创建LDA模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">create-model</span>(<span class="tok-nv">@documents</span> --&gt; <span class="tok-n">Algorithm::LDA::LDAModel</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$stopwords</span> = <span class="tok-s">&quot;stopwords/english&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">Set</span>;
    <span class="tok-k">my</span> <span class="tok-nv">&amp;tokenizer</span> = -&gt; <span class="tok-nv">$line</span> { <span class="tok-nv">$line</span>.<span class="tok-n">words</span>.<span class="tok-nb">map</span>(*.<span class="tok-nb">lc</span>).<span class="tok-nb">grep</span>(-&gt; <span class="tok-nv">$w</span> { (<span class="tok-nv">$stopwords</span> !(<span class="tok-n">cont</span>) <span class="tok-nv">$w</span>) <span class="tok-o">and</span> <span class="tok-nv">$w</span> !~~<span class="tok-sr"> /^[ &lt;:S&gt; | &lt;:P&gt; ]+$/</span> }) };
    <span class="tok-k">my</span> (<span class="tok-nv">$documents</span>, <span class="tok-nv">$vocabs</span>) = <span class="tok-n">Algorithm::LDA::Formatter</span>.<span class="tok-n">from-plain</span>(<span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> ($, $, *<span class="tok-nv">@body</span>) = .<span class="tok-n">words</span>; <span class="tok-nv">@body</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>) }), <span class="tok-nv">&amp;tokenizer</span>);
    <span class="tok-k">my</span> <span class="tok-n">Algorithm::LDA</span> <span class="tok-nv">$lda</span> .= <span class="tok-nb">new</span>(:<span class="tok-nv">$documents</span>, :<span class="tok-nv">$vocabs</span>);
    <span class="tok-k">my</span> <span class="tok-n">Algorithm::LDA::LDAModel</span> <span class="tok-nv">$model</span> = <span class="tok-nv">$lda</span>.<span class="tok-n">fit</span>(:<span class="tok-n">num-topics</span>(<span class="tok-mi">10</span>), :<span class="tok-n">num-iterations</span>(<span class="tok-mi">500</span>), :<span class="tok-n">seed</span>(<span class="tok-mi">2018</span>));
    <span class="tok-nv">$model</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$stopwords`来自NLTK的一组英语停用词在哪里（我提到了初步部分），并且</code>&amp;tokenizer`是一个自定义标记器`Algorithm::LDA::Formatter.from-plain`。标记器转换给定句子如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. 通过空格拆分句子并生成令牌列表。</p>
</li>
<li>
<p>1. 用小写字符替换标记的每个字符。</p>
</li>
<li>
<p>1. 删除停用词列表中存在的令牌或分类为符号或标点符号的单长令牌。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Algorithm::LDA::Formatter.from-plain</code> 创建数字原生文档（即，文档中的每个单词被映射到其对应的词汇表id，并且该id由C int32表示）和来自文本列表的词汇表。</p>
</div>
<div class="paragraph">
<p>在`Algorithm::LDA`使用上述数值文档创建实例后，我们可以通过启动LDA估计`Algorithm::LDA.fit`。在此示例中，我们将主题数设置为10，将迭代次数设置为100，将srand的种子设置为2018。</p>
</div>
<div class="paragraph">
<p>接下来，我们绘制文档主题分布。在此绘图之前，我们加载已保存的成员</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@members</span> = <span class="tok-s">&quot;members.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
<span class="tok-n">plot-topic-distribution</span>(<span class="tok-nv">$model</span>, <span class="tok-nv">@members</span>, <span class="tok-nv">@documents</span>);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>plot-topic-distribution</code> 使用Chart </dt>
<dd>
<p>Gnuplot绘制主题分布：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">plot-topic-distribution</span>(<span class="tok-nv">$model</span>, <span class="tok-nv">@members</span>, <span class="tok-nv">@documents</span>, <span class="tok-nv">$search-regex</span> = <span class="tok-sr">rx/Larry/</span>) {
    <span class="tok-k">my</span> <span class="tok-nv">$target-personid</span> = <span class="tok-nv">@members</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">grep</span>({ .<span class="tok-nb">value</span> ~~ <span class="tok-nv">$search-regex</span> }).<span class="tok-nb">map</span>(*.<span class="tok-nb">key</span>).<span class="tok-n">head</span>;
    <span class="tok-k">my</span> <span class="tok-nv">$docid</span> = <span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> (<span class="tok-nv">$docid</span>, <span class="tok-nv">$personid</span>, *<span class="tok-nv">@body</span>) = .<span class="tok-n">words</span>; %(<span class="tok-n">docid</span> =&gt; <span class="tok-nv">$docid</span>, <span class="tok-n">personid</span> =&gt; <span class="tok-nv">$personid</span>, <span class="tok-nb">body</span> =&gt; <span class="tok-nv">@body</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>)) })\
    .<span class="tok-nb">grep</span>({ .<span class="tok-s">&lt;personid&gt;</span> == <span class="tok-nv">$target-personid</span> <span class="tok-o">and</span> .<span class="tok-s">&lt;body&gt;</span> ~~<span class="tok-sr"> /:i &lt;&lt; perl &gt;&gt;/</span>}).<span class="tok-nb">map</span>(*<span class="tok-s">&lt;docid&gt;</span>).<span class="tok-n">head</span>;

    <span class="tok-n">note</span>(<span class="tok-s">&quot;@documents[$docid] is selected&quot;</span>);
    <span class="tok-k">my</span> (<span class="tok-nv">$row-size</span>, <span class="tok-nv">$col-size</span>) = <span class="tok-nv">$model</span>.<span class="tok-n">document-topic-matrix</span>.<span class="tok-nb">shape</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@doc-topic</span> = <span class="tok-k">gather</span> <span class="tok-k">for</span> (<span class="tok-nv">$docid</span> <span class="tok-o">X</span> ^<span class="tok-nv">$col-size</span>) -&gt; (<span class="tok-nv">$i</span>, <span class="tok-nv">$j</span>) { <span class="tok-k">take</span> <span class="tok-nv">$model</span>.<span class="tok-n">document-topic-matrix</span>[<span class="tok-nv">$i</span>;<span class="tok-nv">$j</span>]; }
    <span class="tok-k">my</span> <span class="tok-n">Chart::Gnuplot</span> <span class="tok-nv">$gnu</span> .= <span class="tok-nb">new</span>(:<span class="tok-n">terminal</span>(<span class="tok-s">&quot;png&quot;</span>), :<span class="tok-n">filename</span>(<span class="tok-s">&quot;topics.png&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">command</span>(<span class="tok-s">&quot;set boxwidth 0.5 relative&quot;</span>);
    <span class="tok-k">my</span> <span class="tok-n">AnyTicsTic</span> <span class="tok-nv">@tics</span> = <span class="tok-nv">@doc-topic</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">map</span>({ %(:<span class="tok-n">label</span>(.<span class="tok-nb">key</span>), :<span class="tok-n">pos</span>(.<span class="tok-nb">key</span>)) });
    <span class="tok-nv">$gnu</span>.<span class="tok-n">legend</span>(:<span class="tok-n">off</span>);
    <span class="tok-nv">$gnu</span>.<span class="tok-n">xlabel</span>(:<span class="tok-n">label</span>(<span class="tok-s">&quot;Topic&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">ylabel</span>(:<span class="tok-n">label</span>(<span class="tok-s">&quot;P(z|theta,d)&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">xtics</span>(:<span class="tok-n">tics</span>(<span class="tok-nv">@tics</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">plot</span>(:<span class="tok-n">vertices</span>(<span class="tok-nv">@doc-topic</span>.<span class="tok-nb">pairs</span>.<span class="tok-nb">map</span>({ @(.<span class="tok-nb">key</span>, .<span class="tok-nb">value</span>.<span class="tok-nb">exp</span>) })), :<span class="tok-n">style</span>(<span class="tok-s">&quot;boxes&quot;</span>), :<span class="tok-n">fill</span>(<span class="tok-s">&quot;solid&quot;</span>));
    <span class="tok-nv">$gnu</span>.<span class="tok-n">dispose</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们绘制了Larry Wall的引文的主题分布（“虽然Perl口号是不仅仅有一种方法可以做到这一点，但我还是犹豫了10种方法来做某事。”）：</p>
</div>
<div class="paragraph">
<p>!<a href="https://camo.githubusercontent.com/787f04318d3c341aa81deaa2c2793054d48403ee/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f746f706963732d312e706e673f773d363430">img</a></p>
</div>
<div class="paragraph">
<p>在绘图之后，我们称之为`write-nbest`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-n">write-nbest</span>(<span class="tok-nv">$model</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在LDA中，XXX表示的主题表示为单词列表。`write-nbest`写一个降价风格的主题词分配表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">write-nbest</span>(<span class="tok-nv">$model</span>) {
  <span class="tok-k">my</span> <span class="tok-nv">$topics</span> := <span class="tok-nv">$model</span>.<span class="tok-n">nbest-words-per-topic</span>(<span class="tok-mi">10</span>);
  <span class="tok-k">for</span> ^(<span class="tok-mi">10</span><span class="tok-o">/</span><span class="tok-mi">5</span>) -&gt; <span class="tok-nv">$part-i</span> {
    <span class="tok-nb">say</span> <span class="tok-s">&quot;|&quot;</span> ~ (^<span class="tok-mi">5</span>).<span class="tok-nb">map</span>(-&gt; <span class="tok-nv">$t</span> { <span class="tok-s">&quot;topic { $part-i * 5 + $t }&quot;</span> }).<span class="tok-nb">join</span>(<span class="tok-s">&quot;|&quot;</span>) ~ <span class="tok-s">&quot;|&quot;</span>;
    <span class="tok-nb">say</span> <span class="tok-s">&quot;|&quot;</span> ~ (^<span class="tok-mi">5</span>).<span class="tok-nb">map</span>({ <span class="tok-s">&quot;----&quot;</span> }).<span class="tok-nb">join</span>(<span class="tok-s">&quot;|&quot;</span>) ~ <span class="tok-s">&quot;|&quot;</span>;
    <span class="tok-k">for</span> ^<span class="tok-mi">10</span> -&gt; <span class="tok-nv">$rank</span> {
        <span class="tok-nb">say</span> <span class="tok-s">&quot;|&quot;</span> ~ <span class="tok-k">gather</span> <span class="tok-k">for</span> (<span class="tok-nv">$part-i</span> * <span class="tok-mi">5</span>)..^(<span class="tok-nv">$part-i</span> * <span class="tok-mi">5</span> + <span class="tok-mi">5</span>) -&gt; <span class="tok-nv">$topic</span> {
            <span class="tok-k">take</span> @(<span class="tok-nv">$topics</span>)[<span class="tok-nv">$topic</span>;<span class="tok-nv">$rank</span>].<span class="tok-nb">key</span>;
        }.<span class="tok-nb">join</span>(<span class="tok-s">&quot;|&quot;</span>) ~ <span class="tok-s">&quot;|&quot;</span>;
    }
    <span class="tok-s">&quot;&quot;</span>.<span class="tok-nb">say</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是：</p>
</div>
<div class="paragraph">
<p>| topic 0  | topic 1   | topic 2  | topic 3  | topic 4   |
| -------- | --------- | -------- | -------- | --------- |
| would    | scotland  | black    | could    | one       |
| itâ€™s   | country   | mr.      | first    | work      |
| believe  | one       | lot      | law      | new       |
| one      | political | play     | college  | human     |
| took     | world     | official | basic    | process   |
| much     | need      | new      | speak    | business  |
| donâ€™t  | must      | reacher  | language | becomes   |
| ever     | national  | five     | every    | good      |
| far      | many      | car      | matter   | world     |
| fighting | us        | road     | right    | knowledge |</p>
</div>
<div class="paragraph">
<p>| topic 5 | topic 6   | topic 7 | topic 8   | topic 9 |
| ------- | --------- | ------- | --------- | ------- |
| apple   | united    | people  | like      | */      |
| likely  | war       | would   | one       | die     |
| company | states    | i’m     | something | und     |
| jobs    | years     | know    | think     | quantum |
| even    | would     | think   | way       | play    |
| steve   | american  | want    | things    | noble   |
| life    | president | get     | perl      | home    |
| like    | human     | going   | long      | dog     |
| end     | must      | say     | always    | student |
| small   | us        | go      | really    | ist     |</p>
</div>
<div class="paragraph">
<p>正如你所看到的那样，引用“虽然Perl Slogan不仅仅是一种方法，我还有10种方法可以做某事。”包含“one”，“way”和“perl”。这就是为什么这个引用主要由主题8组成的原因。</p>
</div>
<div class="paragraph">
<p>对于下一节，我们按`save-model`子程序保存模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">save-model</span>(<span class="tok-nv">$model</span>) {
  <span class="tok-k">my</span> <span class="tok-nv">@document-topic-matrix</span> := <span class="tok-nv">$model</span>.<span class="tok-n">document-topic-matrix</span>;
  <span class="tok-k">my</span> (<span class="tok-nv">$document-size</span>, <span class="tok-nv">$topic-size</span>) = <span class="tok-nv">@document-topic-matrix</span>.<span class="tok-nb">shape</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$doctopicfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;document-topic.txt&quot;</span>, :<span class="tok-n">w</span>;

  <span class="tok-nv">$doctopicfh</span>.<span class="tok-n">say:</span> (<span class="tok-nv">$document-size</span>, <span class="tok-nv">$topic-size</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  <span class="tok-k">for</span> ^<span class="tok-nv">$document-size</span> -&gt; <span class="tok-nv">$doc-i</span> {
    <span class="tok-nv">$doctopicfh</span>.<span class="tok-n">say:</span> <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic</span> { <span class="tok-k">take</span> <span class="tok-nv">@document-topic-matrix</span>[<span class="tok-nv">$doc-i</span>;<span class="tok-nv">$topic</span>] }.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  }
  <span class="tok-nv">$doctopicfh</span>.<span class="tok-nb">close</span>;

  <span class="tok-k">my</span> <span class="tok-nv">@topic-word-matrix</span> := <span class="tok-nv">$model</span>.<span class="tok-n">topic-word-matrix</span>;
  <span class="tok-k">my</span> ($, <span class="tok-nv">$word-size</span>) = <span class="tok-nv">@topic-word-matrix</span>.<span class="tok-nb">shape</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$topicwordfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;topic-word.txt&quot;</span>, :<span class="tok-n">w</span>;

  <span class="tok-nv">$topicwordfh</span>.<span class="tok-n">say:</span> (<span class="tok-nv">$topic-size</span>, <span class="tok-nv">$word-size</span>).<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic-i</span> {
    <span class="tok-nv">$topicwordfh</span>.<span class="tok-n">say:</span> <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$word-size</span> -&gt; <span class="tok-nv">$word</span> { <span class="tok-k">take</span> <span class="tok-nv">@topic-word-matrix</span>[<span class="tok-nv">$topic-i</span>;<span class="tok-nv">$word</span>] }.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>);
  }
  <span class="tok-nv">$topicwordfh</span>.<span class="tok-nb">close</span>;

  <span class="tok-k">my</span> <span class="tok-nv">@vocabulary</span> := <span class="tok-nv">$model</span>.<span class="tok-n">vocabulary</span>;
  <span class="tok-k">my</span> <span class="tok-nv">$vocabfh</span> = <span class="tok-nb">open</span> <span class="tok-s">&quot;vocabulary.txt&quot;</span>, :<span class="tok-n">w</span>;

  <span class="tok-nv">$vocabfh</span>.<span class="tok-nb">say</span>(<span class="tok-nv">$_</span>) <span class="tok-k">for</span> <span class="tok-nv">@vocabulary</span>;
  <span class="tok-nv">$vocabfh</span>.<span class="tok-nb">close</span>;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习3创建报价搜索引擎">46.2.4. 练习3：创建报价搜索引擎</h4>
<div class="paragraph">
<p>在本节中，我们创建一个报价搜索引擎，它使用上一节中创建的模型。
更具体地说，我们创建了基于LDA的文档模型（Xing Wei和W. Bruce Croft 2006），并创建了一个可以搜索报价的CLI工具。（注意，“token”和“word”这两个词在本节中是可互换的）</p>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">use</span> <span class="tok-n">v6</span>.<span class="tok-n">c</span>;

<span class="tok-k">sub</span> <span class="tok-n">MAIN</span>(<span class="tok-nb">Str</span> :<span class="tok-nv">$query</span>!) {
    <span class="tok-k">my</span> \<span class="tok-n">doc-topic-iter</span> = <span class="tok-s">&quot;document-topic.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">iterator</span>;
    <span class="tok-k">my</span> \<span class="tok-n">topic-word-iter</span> = <span class="tok-s">&quot;topic-word.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">iterator</span>;
    <span class="tok-k">my</span> (<span class="tok-nv">$document-size</span>, <span class="tok-nv">$topic-size</span>) = <span class="tok-n">doc-topic-iter</span>.<span class="tok-n">pull-one</span>.<span class="tok-n">words</span>;
    <span class="tok-k">my</span> ($, <span class="tok-nv">$word-size</span>) = <span class="tok-n">topic-word-iter</span>.<span class="tok-n">pull-one</span>.<span class="tok-n">words</span>;

    <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@document-topic</span>[<span class="tok-nv">$document-size</span>;<span class="tok-nv">$topic-size</span>];
    <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@topic-word</span>[<span class="tok-nv">$topic-size</span>;<span class="tok-nv">$word-size</span>];

    <span class="tok-k">for</span> ^<span class="tok-nv">$document-size</span> -&gt; <span class="tok-nv">$doc-i</span> {
        <span class="tok-k">my</span> \<span class="tok-n">maybe-line</span> := <span class="tok-n">doc-topic-iter</span>.<span class="tok-n">pull-one</span>;
        <span class="tok-k">die</span> <span class="tok-s">&quot;Error: Something went wrong&quot;</span> <span class="tok-k">if</span> <span class="tok-n">maybe-line</span> =:= <span class="tok-n">IterationEnd</span>;
        <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@line</span> = @(<span class="tok-n">maybe-line</span>).<span class="tok-n">words</span>&gt;&gt;.<span class="tok-nb">Num</span>;
        <span class="tok-k">for</span> ^<span class="tok-nv">@line</span> {
            <span class="tok-nv">@document-topic</span>[<span class="tok-nv">$doc-i</span>;<span class="tok-nv">$_</span>] = <span class="tok-nv">@line</span>[<span class="tok-nv">$_</span>];
        }
    }

    <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic-i</span> {
        <span class="tok-k">my</span> \<span class="tok-n">maybe-line</span> := <span class="tok-n">topic-word-iter</span>.<span class="tok-n">pull-one</span>;
        <span class="tok-k">die</span> <span class="tok-s">&quot;Error: Something went wrong&quot;</span> <span class="tok-k">if</span> <span class="tok-n">maybe-line</span> =:= <span class="tok-n">IterationEnd</span>;
        <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@line</span> = @(<span class="tok-n">maybe-line</span>).<span class="tok-n">words</span>&gt;&gt;.<span class="tok-nb">Num</span>;
        <span class="tok-k">for</span> ^<span class="tok-nv">@line</span> {
            <span class="tok-nv">@topic-word</span>[<span class="tok-nv">$topic-i</span>;<span class="tok-nv">$_</span>] = <span class="tok-nv">@line</span>[<span class="tok-nv">$_</span>];
        }
    }

    <span class="tok-k">my</span> <span class="tok-nv">%vocabulary</span> = <span class="tok-s">&quot;vocabulary.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">pairs</span>&gt;&gt;.<span class="tok-n">antipair</span>.<span class="tok-n">hash</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@members</span> = <span class="tok-s">&quot;members.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@documents</span> = <span class="tok-s">&quot;documents.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@docbodies</span> = <span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> ($, $, *<span class="tok-nv">@body</span>) = .<span class="tok-n">words</span>; <span class="tok-nv">@body</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>) });
    <span class="tok-k">my</span> <span class="tok-nv">%doc-to-person</span> = <span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> (<span class="tok-nv">$docid</span>, <span class="tok-nv">$personid</span>, $) = .<span class="tok-n">words</span>; %(<span class="tok-nv">$docid</span> =&gt; <span class="tok-nv">$personid</span>) }).<span class="tok-n">hash</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@query</span> = <span class="tok-nv">$query</span>.<span class="tok-n">words</span>.<span class="tok-nb">map</span>(*.<span class="tok-nb">lc</span>);

    <span class="tok-k">my</span> <span class="tok-nv">@sorted-list</span> = <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$document-size</span> -&gt; <span class="tok-nv">$doc-i</span> {
        <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">$log-prob</span> = <span class="tok-k">gather</span> <span class="tok-k">for</span> <span class="tok-nv">@query</span> -&gt; <span class="tok-nv">$token</span> {
            <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">$log-ml-prob</span> = <span class="tok-n">Pml</span>(<span class="tok-nv">@docbodies</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">$token</span>);
            <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">$log-lda-prob</span> = <span class="tok-n">Plda</span>(<span class="tok-nv">$token</span>, <span class="tok-nv">$topic-size</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">%vocabulary</span>, <span class="tok-nv">@document-topic</span>, <span class="tok-nv">@topic-word</span>);
            <span class="tok-k">take</span> <span class="tok-n">log-sum</span>(<span class="tok-nb">log</span>(<span class="tok-mf">0.2</span>) + <span class="tok-nv">$log-ml-prob</span>, <span class="tok-nb">log</span>(<span class="tok-mf">0.8</span>) + <span class="tok-nv">$log-lda-prob</span>);
        }.<span class="tok-nb">sum</span>;
        <span class="tok-k">take</span> %(<span class="tok-n">doc-i</span> =&gt; <span class="tok-nv">$doc-i</span>, <span class="tok-n">log-prob</span> =&gt; <span class="tok-nv">$log-prob</span>);
    }.<span class="tok-nb">sort</span>({ <span class="tok-nv">$^b&lt;log-prob&gt;</span> &lt;=&gt; <span class="tok-nv">$^a&lt;log-prob&gt;</span> });

    <span class="tok-k">for</span> ^<span class="tok-mi">10</span> {
        <span class="tok-k">my</span> <span class="tok-nv">$docid</span> = <span class="tok-nv">@sorted-list</span>[<span class="tok-nv">$_</span>]<span class="tok-s">&lt;doc-i&gt;</span>;
        <span class="tok-nb">sprintf</span>(<span class="tok-s">&quot;\&quot;%s\&quot; by %s %f&quot;</span>, <span class="tok-nv">@docbodies</span>[<span class="tok-nv">$docid</span>], <span class="tok-nv">@members</span>[<span class="tok-nv">%doc-to-person</span>{<span class="tok-nv">$docid</span>}], <span class="tok-nv">@sorted-list</span>[<span class="tok-nv">$_</span>]<span class="tok-s">&lt;log-prob&gt;</span>).<span class="tok-nb">say</span>;
    }

}

<span class="tok-k">sub</span> <span class="tok-n">Pml</span>(<span class="tok-nv">@docbodies</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">$token</span> --&gt; <span class="tok-nb">Num</span>) {
    <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$num-tokens</span> = <span class="tok-nv">@docbodies</span>[<span class="tok-nv">$doc-i</span>].<span class="tok-n">words</span>.<span class="tok-nb">grep</span>({ /:<span class="tok-n">i</span>^ <span class="tok-nv">$token</span> <span class="tok-vg">$/</span> }).<span class="tok-nb">elems</span>;
    <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$total-tokens</span> = <span class="tok-nv">@docbodies</span>[<span class="tok-nv">$doc-i</span>].<span class="tok-n">words</span>.<span class="tok-nb">elems</span>;
    <span class="tok-k">return</span> -<span class="tok-mf">100e0</span> <span class="tok-k">if</span> <span class="tok-nv">$total-tokens</span> == <span class="tok-mi">0</span> <span class="tok-o">or</span> <span class="tok-nv">$num-tokens</span> == <span class="tok-mi">0</span>;
    <span class="tok-nb">log</span>(<span class="tok-nv">$num-tokens</span>) - <span class="tok-nb">log</span>(<span class="tok-nv">$total-tokens</span>);
}

<span class="tok-k">sub</span> <span class="tok-n">Plda</span>(<span class="tok-nv">$token</span>, <span class="tok-nv">$topic-size</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">%vocabulary</span> <span class="tok-k">is</span> <span class="tok-n">raw</span>, <span class="tok-nv">@document-topic</span> <span class="tok-k">is</span> <span class="tok-n">raw</span>, <span class="tok-nv">@topic-word</span> <span class="tok-k">is</span> <span class="tok-n">raw</span> --&gt; <span class="tok-nb">Num</span>) {
    <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic</span> {
        <span class="tok-k">if</span> <span class="tok-nv">%vocabulary</span>{<span class="tok-nv">$token</span>}:<span class="tok-n">exists</span> {
            <span class="tok-k">take</span> <span class="tok-nv">@document-topic</span>[<span class="tok-nv">$doc-i</span>;<span class="tok-nv">$topic</span>] + <span class="tok-nv">@topic-word</span>[<span class="tok-nv">$topic</span>;<span class="tok-nv">%vocabulary</span>{<span class="tok-nv">$token</span>}];
        } <span class="tok-k">else</span> {
            <span class="tok-k">take</span> -<span class="tok-mf">100e0</span>;
        }
    }.<span class="tok-nb">reduce</span>(<span class="tok-nv">&amp;log-sum</span>);
}

<span class="tok-k">sub</span> <span class="tok-n">log-sum</span>(<span class="tok-nb">Num</span> <span class="tok-nv">$log-a</span>, <span class="tok-nb">Num</span> <span class="tok-nv">$log-b</span> --&gt; <span class="tok-nb">Num</span>) {
    <span class="tok-k">if</span> <span class="tok-nv">$log-a</span> &lt; <span class="tok-nv">$log-b</span> {
        <span class="tok-k">return</span> <span class="tok-nv">$log-b</span> + <span class="tok-nb">log</span>(<span class="tok-mi">1</span> + <span class="tok-nb">exp</span>(<span class="tok-nv">$log-a</span> - <span class="tok-nv">$log-b</span>))
    } <span class="tok-k">else</span> {
        <span class="tok-k">return</span> <span class="tok-nv">$log-a</span> + <span class="tok-nb">log</span>(<span class="tok-mi">1</span> + <span class="tok-nb">exp</span>(<span class="tok-nv">$log-b</span> - <span class="tok-nv">$log-a</span>))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在beggining，我们加载保存的模型和准备`@document-topic`，<code>@topic-word</code>，<code>%vocabulary</code>，<code>@documents</code>，<code>@docbodies</code>，<code>%doc-to-person`和</code>@members`</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span> <span class="tok-k">my</span> \<span class="tok-n">doc-topic-iter</span> = <span class="tok-s">&quot;document-topic.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">iterator</span>;
    <span class="tok-k">my</span> \<span class="tok-n">topic-word-iter</span> = <span class="tok-s">&quot;topic-word.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">iterator</span>;
    <span class="tok-k">my</span> (<span class="tok-nv">$document-size</span>, <span class="tok-nv">$topic-size</span>) = <span class="tok-n">doc-topic-iter</span>.<span class="tok-n">pull-one</span>.<span class="tok-n">words</span>;
    <span class="tok-k">my</span> ($, <span class="tok-nv">$word-size</span>) = <span class="tok-n">topic-word-iter</span>.<span class="tok-n">pull-one</span>.<span class="tok-n">words</span>;

    <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@document-topic</span>[<span class="tok-nv">$document-size</span>;<span class="tok-nv">$topic-size</span>];
    <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@topic-word</span>[<span class="tok-nv">$topic-size</span>;<span class="tok-nv">$word-size</span>];

    <span class="tok-k">for</span> ^<span class="tok-nv">$document-size</span> -&gt; <span class="tok-nv">$doc-i</span> {
        <span class="tok-k">my</span> \<span class="tok-n">maybe-line</span> = <span class="tok-n">doc-topic-iter</span>.<span class="tok-n">pull-one</span>;
        <span class="tok-k">die</span> <span class="tok-s">&quot;Error: Something went wrong&quot;</span> <span class="tok-k">if</span> <span class="tok-n">maybe-line</span> =:= <span class="tok-n">IterationEnd</span>;
        <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@line</span> = @(<span class="tok-n">maybe-line</span>).<span class="tok-n">words</span>&gt;&gt;.<span class="tok-nb">Num</span>;
        <span class="tok-k">for</span> ^<span class="tok-nv">@line</span> {
            <span class="tok-nv">@document-topic</span>[<span class="tok-nv">$doc-i</span>;<span class="tok-nv">$_</span>] = <span class="tok-nv">@line</span>[<span class="tok-nv">$_</span>];
        }
    }

    <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic-i</span> {
        <span class="tok-k">my</span> \<span class="tok-n">maybe-line</span> = <span class="tok-n">topic-word-iter</span>.<span class="tok-n">pull-one</span>;
        <span class="tok-k">die</span> <span class="tok-s">&quot;Error: Something went wrong&quot;</span> <span class="tok-k">if</span> <span class="tok-n">maybe-line</span> =:= <span class="tok-n">IterationEnd</span>;
        <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">@line</span> = @(<span class="tok-n">maybe-line</span>).<span class="tok-n">words</span>&gt;&gt;.<span class="tok-nb">Num</span>;
        <span class="tok-k">for</span> ^<span class="tok-nv">@line</span> {
            <span class="tok-nv">@topic-word</span>[<span class="tok-nv">$topic-i</span>;<span class="tok-nv">$_</span>] = <span class="tok-nv">@line</span>[<span class="tok-nv">$_</span>];
        }
    }

    <span class="tok-k">my</span> <span class="tok-nv">%vocabulary</span> = <span class="tok-s">&quot;vocabulary.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>.<span class="tok-nb">pairs</span>&gt;&gt;.<span class="tok-n">antipair</span>.<span class="tok-n">hash</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@members</span> = <span class="tok-s">&quot;members.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@documents</span> = <span class="tok-s">&quot;documents.txt&quot;</span>.<span class="tok-nb">IO</span>.<span class="tok-nb">lines</span>;
    <span class="tok-k">my</span> <span class="tok-nv">@docbodies</span> = <span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> ($, $, *<span class="tok-nv">@body</span>) = .<span class="tok-n">words</span>; <span class="tok-nv">@body</span>.<span class="tok-nb">join</span>(<span class="tok-s">&quot; &quot;</span>) });
    <span class="tok-k">my</span> <span class="tok-nv">%doc-to-person</span> = <span class="tok-nv">@documents</span>.<span class="tok-nb">map</span>({ <span class="tok-k">my</span> (<span class="tok-nv">$docid</span>, <span class="tok-nv">$personid</span>, $) = .<span class="tok-n">words</span>; %(<span class="tok-nv">$docid</span> =&gt; <span class="tok-nv">$personid</span>) }).<span class="tok-n">hash</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们`@query`使用选项设置`:$query`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">my</span> <span class="tok-nv">@query</span> = <span class="tok-nv">$query</span>.<span class="tok-n">words</span>.<span class="tok-nb">map</span>(*.<span class="tok-nb">lc</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，我们计算`P(query|document)`基于Eq 的概率。前面提到的9篇文章（注意我们使用对数来避免不流动并将参数mu设置为零）并对它们进行排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>    <span class="tok-k">my</span> <span class="tok-nv">@sorted-list</span> = <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$document-size</span> -&gt; <span class="tok-nv">$doc-i</span> {
        <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">$log-prob</span> = <span class="tok-k">gather</span> <span class="tok-k">for</span> <span class="tok-nv">@query</span> -&gt; <span class="tok-nv">$token</span> {
            <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">$log-ml-prob</span> = <span class="tok-n">Pml</span>(<span class="tok-nv">@docbodies</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">$token</span>);
            <span class="tok-k">my</span> <span class="tok-nb">Num</span> <span class="tok-nv">$log-lda-prob</span> = <span class="tok-n">Plda</span>(<span class="tok-nv">$token</span>, <span class="tok-nv">$topic-size</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">%vocabulary</span>, <span class="tok-nv">@document-topic</span>, <span class="tok-nv">@topic-word</span>);
            <span class="tok-k">take</span> <span class="tok-n">log-sum</span>(<span class="tok-nb">log</span>(<span class="tok-mf">0.2</span>) + <span class="tok-nv">$log-ml-prob</span>, <span class="tok-nb">log</span>(<span class="tok-mf">0.8</span>) + <span class="tok-nv">$log-lda-prob</span>);
        }.<span class="tok-nb">sum</span>;
        <span class="tok-k">take</span> %(<span class="tok-n">doc-i</span> =&gt; <span class="tok-nv">$doc-i</span>, <span class="tok-n">log-prob</span> =&gt; <span class="tok-nv">$log-prob</span>);
    }.<span class="tok-nb">sort</span>({ <span class="tok-nv">$^b&lt;log-prob&gt;</span> &lt;=&gt; <span class="tok-nv">$^a&lt;log-prob&gt;</span> });</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Plda`为每个主题添加给定文档概率（即lnP（主题| theta，文档））和单词给定主题概率（即lnP（word | phi，topic））的对数主题，并将它们加起来</code>.reduce(&amp;log-sum);`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">Plda</span>(<span class="tok-nv">$token</span>, <span class="tok-nv">$topic-size</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">%vocabulary</span> <span class="tok-k">is</span> <span class="tok-n">raw</span>, <span class="tok-nv">@document-topic</span> <span class="tok-k">is</span> <span class="tok-n">raw</span>, <span class="tok-nv">@topic-word</span> <span class="tok-k">is</span> <span class="tok-n">raw</span> --&gt; <span class="tok-nb">Num</span>) {
    <span class="tok-k">gather</span> <span class="tok-k">for</span> ^<span class="tok-nv">$topic-size</span> -&gt; <span class="tok-nv">$topic</span> {
        <span class="tok-k">if</span> <span class="tok-nv">%vocabulary</span>{<span class="tok-nv">$token</span>}:<span class="tok-n">exists</span> {
            <span class="tok-k">take</span> <span class="tok-nv">@document-topic</span>[<span class="tok-nv">$doc-i</span>;<span class="tok-nv">$topic</span>] + <span class="tok-nv">@topic-word</span>[<span class="tok-nv">$topic</span>;<span class="tok-nv">%vocabulary</span>{<span class="tok-nv">$token</span>}];
        } <span class="tok-k">else</span> {
            <span class="tok-k">take</span> -<span class="tok-mf">100e0</span>;
        }
    }.<span class="tok-nb">reduce</span>(<span class="tok-nv">&amp;log-sum</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且 <code>Pml</code>（ml表示最大似然）计数`$token`并将其标准化为文档中的总标记（注意，此计算也在日志空间中进行）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">Pml</span>(<span class="tok-nv">@docbodies</span>, <span class="tok-nv">$doc-i</span>, <span class="tok-nv">$token</span> --&gt; <span class="tok-nb">Num</span>) {
    <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$num-tokens</span> = <span class="tok-nv">@docbodies</span>[<span class="tok-nv">$doc-i</span>].<span class="tok-n">words</span>.<span class="tok-nb">grep</span>({ /:<span class="tok-n">i</span>^ <span class="tok-nv">$token</span> <span class="tok-vg">$/</span> }).<span class="tok-nb">elems</span>;
    <span class="tok-k">my</span> <span class="tok-nb">Int</span> <span class="tok-nv">$total-tokens</span> = <span class="tok-nv">@docbodies</span>[<span class="tok-nv">$doc-i</span>].<span class="tok-n">words</span>.<span class="tok-nb">elems</span>;
    <span class="tok-k">return</span> -<span class="tok-mf">100e0</span> <span class="tok-k">if</span> <span class="tok-nv">$total-tokens</span> == <span class="tok-mi">0</span> <span class="tok-o">or</span> <span class="tok-nv">$num-tokens</span> == <span class="tok-mi">0</span>;
    <span class="tok-nb">log</span>(<span class="tok-nv">$num-tokens</span>) - <span class="tok-nb">log</span>(<span class="tok-nv">$total-tokens</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，那就让我们执行吧！</p>
</div>
<div class="paragraph">
<p>查询“perl”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span>$ <span class="tok-n">perl6</span> <span class="tok-n">search-quotation</span>.<span class="tok-n">p6</span> --<span class="tok-n">query</span>=<span class="tok-s">&quot;perl&quot;</span>
<span class="tok-s">&quot;Perl will always provide the null.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.301156</span>
<span class="tok-s">&quot;Perl programming is an *empirical* science!&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.345189</span>
<span class="tok-s">&quot;The whole intent of Perl 5&#39;s module system was to encourage the growth of Perl culture rather than the Perl core.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.490238</span>
<span class="tok-s">&quot;I dunno, I dream in Perl sometimes...&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.491790</span>
<span class="tok-s">&quot;At many levels, Perl is a &#39;diagonal&#39; language.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.575779</span>
<span class="tok-s">&quot;Almost nothing in Perl serves a single purpose.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.589218</span>
<span class="tok-s">&quot;Perl has a long tradition of working around compilers.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.674111</span>
<span class="tok-s">&quot;As for whether Perl 6 will replace Perl 5, yeah, probably, in about 40 years or so.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.684454</span>
<span class="tok-s">&quot;Well, I think Perl should run faster than C.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.771155</span>
<span class="tok-s">&quot;It&#39;s certainly easy to calculate the average attendance for Perl conferences.&quot;</span> <span class="tok-nb">by</span> <span class="tok-n">Larry</span> <span class="tok-n">Wall</span> -<span class="tok-mf">3.864075</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>查询“apple”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ perl6 search-quotation.p6 --query<span class="tok-o">=</span><span class="tok-s2">&quot;apple&quot;</span>
<span class="tok-s2">&quot;Steve Jobs is the&quot;</span>With phones moving to technologies such as Apple Pay, an unwillingness to assure security could create a Target-like exposure that wipes Apple out of the market.<span class="tok-s2">&quot; by Rob Enderle -3.841538</span>
<span class="tok-s2">&quot;</span>*:From Joint Apple / HP press release dated <span class="tok-m">1</span> January <span class="tok-m">2004</span> available <span class="tok-o">[</span>http://www.apple.com/pr/library/2004/jan/08hp.html here<span class="tok-o">]</span>.<span class="tok-s2">&quot; by Carly Fiorina -3.904489</span>
<span class="tok-s2">&quot;</span>Samsung did to Apple what Apple did to Microsoft, skewering its devoted users and reputation, only better. ... There is a way <span class="tok-k">for</span> Apple to fight back, but the company no longer has that skill, and apparently doesn<span class="tok-s1">&#39;t know where to get it, either.&quot; by Rob Enderle -3.940359</span>
<span class="tok-s1">&quot;[W]hen it came to the iWatch, also a name that Apple didn&#39;</span>t own, Apple walked away from it and instead launched the Apple Watch. Certainly, no risk of litigation, but the product<span class="tok-s1">&#39;s sales are a fraction of what they otherwise might have been with the proper name and branding.&quot; by Rob Enderle -4.152145</span>
<span class="tok-s1">&quot;[W]hen Apple wanted the name &quot;iPhone&quot; and it was owned by Cisco, Steve Jobs just took it, and his legal team executed so he could keep it. It turned out that doing this was surprisingly inexpensive. And, as the Apple Watch showcased, the Apple Phone likely would not have sold anywhere near as well as the iPhone.&quot; by Rob Enderle -4.187223</span>
<span class="tok-s1">&quot;The cause of [Apple v. Qualcomm] appears to be an effort by Apple to pressure Qualcomm into providing a unique discount, largely because Apple has run into an innovation wall, is under increased competition from firms like Samsung, and has moved to a massive cost reduction strategy. (I&#39;</span>ve never known this to end well, as it causes suppliers to create unreliable components and outright fail.<span class="tok-o">)</span><span class="tok-s2">&quot; by Rob Enderle -4.318575</span>
<span class="tok-s2">&quot;</span>Apple tends to aggressively work to not discover problems with products that are shipped and certainly not talk about them.<span class="tok-s2">&quot; by Rob Enderle -4.380863</span>
<span class="tok-s2">&quot;</span>Apple no longer owns the tablet market, and will likely lose dominance this year or next. ... this level of sustained dominance doesn<span class="tok-s1">&#39;t appear to recur with the same vendor even if it launched the category.&quot; by Rob Enderle -4.397954</span>
<span class="tok-s1">&quot;Apple is becoming more and more like a typical tech firm â€” that is, long on technology and short on magic. ... Apple is drifting closer and closer to where it was back in the 1990s. It offers advancements that largely follow those made by others years earlier, product proliferation, a preference for more over simple elegance, and waning excitement.&quot; by Rob Enderle -4.448473</span>
<span class="tok-s1">&quot;[T]he litigation between Qualcomm and Apple/Intel ... is weird. What makes it weird is that Intel appears to think that by helping Apple drive down Qualcomm prices, it will gain an advantage, but since its only value is as a lower cost, lower performing, alternative to Qualcomm&#39;</span>s modems, the result would be more aggressively priced better alternatives to Intel<span class="tok-s1">&#39;s offerings from Qualcomm/Broadcom, wiping Intel out of the market. On paper, this is a lose/lose for Intel and even for Apple. The lower prices would flow to Apple competitors as well, lowering the price of competing phones. So, Apple would not get a lasting benefit either.&quot; by Rob Enderle -4.469852 Ronald McDonald of Apple, he is the face.&quot; by Rob Enderle -3.822949</span>
<span class="tok-s1">&quot;With phones moving to technologies such as Apple Pay, an unwillingness to assure security could create a Target-like exposure that wipes Apple out of the market.&quot; by Rob Enderle -3.849055</span>
<span class="tok-s1">&quot;*:From Joint Apple / HP press release dated 1 January 2004 available [http://www.apple.com/pr/library/2004/jan/08hp.html here].&quot; by Carly Fiorina -3.895163</span>
<span class="tok-s1">&quot;Samsung did to Apple what Apple did to Microsoft, skewering its devoted users and reputation, only better. ... There is a way for Apple to fight back, but the company no longer has that skill, and apparently doesn&#39;</span>t know where to get it, either.<span class="tok-s2">&quot; by Rob Enderle -4.052616</span>
<span class="tok-s2">&quot;</span>*** The previous line contains the naughty word <span class="tok-s1">&#39;$&amp;&#39;</span>.<span class="tok-se">\n</span> <span class="tok-k">if</span> /<span class="tok-o">(</span>ibm<span class="tok-p">|</span>apple<span class="tok-p">|</span>awk<span class="tok-o">)</span>/<span class="tok-p">;</span> <span class="tok-c1"># :-)&quot; by Larry Wall -4.088445</span>
<span class="tok-s2">&quot;The cause of [Apple v. Qualcomm] appears to be an effort by Apple to pressure Qualcomm into providing a unique discount, largely because Apple has run into an innovation wall, is under increased competition from firms like Samsung, and has moved to a massive cost reduction strategy. (I&#39;ve never known this to end well, as it causes suppliers to create unreliable components and outright fail.)&quot;</span> by Rob Enderle -4.169533
<span class="tok-s2">&quot;[T]he litigation between Qualcomm and Apple/Intel ... is weird. What makes it weird is that Intel appears to think that by helping Apple drive down Qualcomm prices, it will gain an advantage, but since its only value is as a lower cost, lower performing, alternative to Qualcomm&#39;s modems, the result would be more aggressively priced better alternatives to Intel&#39;s offerings from Qualcomm/Broadcom, wiping Intel out of the market. On paper, this is a lose/lose for Intel and even for Apple. The lower prices would flow to Apple competitors as well, lowering the price of competing phones. So, Apple would not get a lasting benefit either.&quot;</span> by Rob Enderle -4.197869
<span class="tok-s2">&quot;Apple tends to aggressively work to not discover problems with products that are shipped and certainly not talk about them.&quot;</span> by Rob Enderle -4.204618
<span class="tok-s2">&quot;Today&#39;s tech companies aren&#39;t built to last, as Apple&#39;s recent earnings report shows all too well.&quot;</span> by Rob Enderle -4.209901
<span class="tok-s2">&quot;[W]hen it came to the iWatch, also a name that Apple didn&#39;t own, Apple walked away from it and instead launched the Apple Watch. Certainly, no risk of litigation, but the product&#39;s sales are a fraction of what they otherwise might have been with the proper name and branding.&quot;</span> by Rob Enderle -4.238582</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结论_6">46.3. 结论</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">在本文中，我们探索了Wikiquote，并使用Algoritm </dt>
<dd>
<p>LDA创建了一个LDA模型。
之后我们构建了一个信息检索应用程序。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>感谢您阅读我的文章！下次见！</p>
</div>
</div>
<div class="sect2">
<h3 id="_引文_2">46.4. 引文</h3>
<div class="ulist">
<ul>
<li>
<p>Blei，David M.“Probabilistic topic models。”ACM 55.4（2012）的通讯：77-84。</p>
</li>
<li>
<p>Wei，Xing和W. Bruce Croft。“基于LDA的文档模型，用于临时检索。”第29届年度国际ACM SIGIR研究与开发信息检索会议论文集。ACM，2006。
== 第二十五天 - 以数之名</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个学期学期我参加了我的第一个校对课程，题为“数学证明研讨会简介”。在学习了其他数学课程（微积分，矩阵代数等）之后，我觉得我没有那么多的数学基础，到目前为止，我所做的只是纯粹的计算数学，到处撒上了一些证明。回想起来，我发现课程非常有趣，并且学习不同的定理及其证明，主要来自数论，给了我一个新的数学视角。</p>
</div>
<div class="paragraph">
<p>你可能会问，“这与 Perl 6 有什么关系？”。正如我所提到的，课堂上讨论的大多数证明或家庭作业都与数论有关。如果 Perl 6 和数论有一个共同点就是它们的可访问性。类似于数论的内容如何具体和熟悉，Perl 6 对初学者来说非常平易近人。事实上，鼓励初学者写出所谓的“婴儿 Perl”。</p>
</div>
<div class="paragraph">
<p>似乎他们分享的另一件事是他们的浩瀚。例如，在 Perl 6 中可以找到许多运算符，而在数论中，可以找到从偶数到可爱数字的过多不同类型的数字。在大多数情况下，这些数字很容易理解，如果有一个数字的定义，那么很容易检查该类别中是否包含给定的整数。例如，素数正式定义如下：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>如果整数p&gt; 1的唯一正数除数为1且p为p，则称p为素数，或简称为素数。否则，称整数p为合数。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过使用这个定义，我们可以非常简单地弄清楚某个数字是否是素数。例如，在前十个正整数中，2,3,5和7是素数。对于小数字来说这是微不足道的，但是用更大的数字手工完成它会很快变得单调乏味。这就是 Perl 6 的用武之地。Perl 6 提供了许多构造/函数，即使它们不能简化工作，它们也可以简化它。例如，考虑到素数的定义，我们可以轻松实现在 Perl 6 中测试素数的算法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">isPrime</span>( <span class="tok-nv">$number</span> ) {
    <span class="tok-k">return</span> <span class="tok-nv">$number</span> &gt; <span class="tok-mi">1</span> <span class="tok-k">if</span> <span class="tok-nv">$number</span> ≤ <span class="tok-mi">3</span>;

    <span class="tok-k">loop</span> (<span class="tok-k">my</span> <span class="tok-nv">$i</span> = <span class="tok-mi">2</span>; <span class="tok-nv">$i²</span> ≤ <span class="tok-nv">$number</span>; <span class="tok-nv">$i</span>++) {
        <span class="tok-k">return</span> <span class="tok-nb">False</span> <span class="tok-k">if</span> <span class="tok-nv">$number</span> %% <span class="tok-nv">$i</span>;
    }

    <span class="tok-k">return</span> <span class="tok-nb">True</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，这不是关于编写高性能代码。如果代码以这种方式拒绝，那么它将是优秀的，但它不是目标。我的目的是展示初学者在 Perl 6 中表达数学结构的容易程度。值得一提的是，Perl 6 已经包含了`is-prime`测试素数的子程序（或方法）。然而，尽管对于素数这是正确的，但对于你可能遇到的另一种类型的数字可能并非如此，例如阶乘，因子或甚至加泰罗尼亚数字。在这种情况下，Perl 6 会很有帮助。</p>
</div>
<div class="paragraph">
<p>在了解了不同类型的数字后，我开始寻找一些奇特的数字，看看如何使用 Perl 6 实现它们。在这个过程中，我发现这个<a href="http://www.daviddarling.info/encyclopedia/N/numbers_types.html">有用的网站</a>列出了一堆数字，它们的定义和一些例子。从所有这些中，我选择了四种类型的数字，这些数字并非愚蠢地难以实现（我仍然在编写 Perl 宝宝!😅），同时足以说明一些 Perl 6 构造。另一方面，我避免了那些可能过于简单的事情。</p>
</div>
<div class="paragraph">
<p>让我们开始于&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="_友善的数字">46.5. 友善的数字</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Amicable 数字是一对数字，也称为<strong>友好数字</strong>，每个<strong>数字</strong>的等分部分添加给另一个数字。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">aliquot-parts</span>( <span class="tok-nv">$number</span> ) {
   (^<span class="tok-nv">$number</span>).<span class="tok-n">grep:</span> <span class="tok-nv">$number</span> %% *;
}

<span class="tok-k">sub</span> <span class="tok-n">infix:</span><span class="tok-s">&lt;amic&gt;</span>( <span class="tok-nv">$m</span>, <span class="tok-nv">$n</span> ) {
    <span class="tok-nv">$m</span> == <span class="tok-n">aliquot-parts</span>(<span class="tok-nv">$n</span>).<span class="tok-nb">sum</span> &amp;&amp;
    <span class="tok-nv">$n</span> == <span class="tok-n">aliquot-parts</span>(<span class="tok-nv">$m</span>).<span class="tok-nb">sum</span>;
}

<span class="tok-nb">say</span> <span class="tok-mi">12</span> <span class="tok-n">amic</span> <span class="tok-mi">28</span>;   <span class="tok-c1"># False, 12 and 28 aren&#39;t amicables.</span>
<span class="tok-nb">say</span> <span class="tok-mi">220</span> <span class="tok-n">amic</span> <span class="tok-mi">284</span>; <span class="tok-c1"># True, 220 and 284 are though.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>数字的等分部分是排除数字本身的因素。为了找到数字的等分部分，我创建了一个子程序`aliquot-parts`，用于`1..^$number`创建从1到`$numbers`（不包括）的数字列表。随后对该列表进行了追踪，以找出列表中均匀分割的那些数字`$number`。在这个片段中，它是通过使用中缀运算符实现的`%%<code>，`True`如果第一个操作数可被第二个操作数整除，则返回该操作符。否则，它返回`False</code>。第二个操作数代表前面提到的列表中的任何数字，所以我使用过`*<code>，在这种情况下，它被称为*任何星形，*并在表达式上创建一个闭包</code>$number %% *<code>。因此，子程序中的整个表达式相当于</code>(^$number).grep: { $number %% $_ };`。最后，子程序返回`$number`排除`$number`自身的因子列表。</p>
</div>
<div class="paragraph">
<p>为了确定两个数字是否友好，我们可以只使用一个子程序。但是，Perl 6允许创建新的运算符，这些运算符*只是具有有趣名称的子程序*，我就是这么做的。我创建了中缀运算符（意思是两个操作数之间）<code>amic</code> ，<code>True`如果两个数字是友好的，则返回。否则，`False</code>。如你所见，创建新运算符的语法很简单：关键字`sub`，后跟运算符的类型（前缀，中缀，后缀等），引用构造内的运算符名称，预期参数和代码块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_factorion">46.6. Factorion</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>因子是一个自然数，等于给定基数中其数字的阶乘的总和。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">subset</span> <span class="tok-n">Whole</span> <span class="tok-k">of</span> <span class="tok-nb">Int</span> <span class="tok-k">where</span> * ≥ <span class="tok-mi">0</span>;

<span class="tok-k">sub</span> <span class="tok-n">postfix:</span><span class="tok-s">&lt;!&gt;( Whole $N --&gt;</span> <span class="tok-n">Whole</span> ) {
    [*] <span class="tok-mi">1</span>..<span class="tok-nv">$N</span>;
}

<span class="tok-k">sub</span> <span class="tok-n">is-factorion</span>( <span class="tok-n">Whole</span> <span class="tok-nv">$number</span> --&gt; <span class="tok-nb">Bool</span> ) {
    <span class="tok-nv">$number</span> == <span class="tok-nv">$number</span>.<span class="tok-nb">comb</span>.<span class="tok-nb">map</span>({ <span class="tok-nb">Int</span>(<span class="tok-nv">$_</span>)! }).<span class="tok-nb">sum</span>
}

<span class="tok-nb">say</span> <span class="tok-n">is-factorion</span>(<span class="tok-mi">25</span>);  <span class="tok-c1"># False</span>
<span class="tok-nb">say</span> <span class="tok-n">is-factorion</span>(<span class="tok-mi">145</span>); <span class="tok-c1"># True</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>回想一下，通常用数字<strong>N</strong>表示的阶乘`N!<code>是产品`1 x 2 x &#8230;&#8203; x N</code>。例如，<code>3! = 1 x 2 x 3 = 6</code>。在代码片段中，我创建了postfix运算符`!<code>以返回整数操作数的阶乘。因此`say 3!;</code>，在代码片段和打印中工作得很好`6`。计算阶乘是如何直接的：范围`1..$N`创建一个从1到`$N`（包括）的数字列表然后我使用`[&#8230;&#8203;]<code>，这被称为*减少*元运算符，运算符</code>*<code>减少创建的列表`1 x 2 x &#8230;&#8203; $N</code>，有效地给了我阶乘的`$N`。Perl 6中有许多运算符，元运算符`[&#8230;&#8203;]`可以与其中许多运算符一起使用。</p>
</div>
<div class="paragraph">
<p>至于因子，我想知道一个数字是否是一个因子，所以我创建了一个采用整数并返回一个布尔值的子程序。Perl 6逐渐输入，因此它允许显式输入变量，指定子的返回类型等。我决定键入子程序的参数和子程序的返回类型。</p>
</div>
<div class="paragraph">
<p>关于友好数字的部分，我对子程序的论点非常自由。但是，在这里，我决定遵循阶乘的定义，只允许整数，因此定义和使用该`Whole`类型。在Perl 6中，运算符`subset`使用基类型声明一个新类型。但是，如果我没有使用该`where`条款，那么我最终只会使用另一个名称，这个`Int`类型将是多余的。所以我使用该`where`子句来约束对所需输入的任何赋值的类型。在这种情况下，赋值给类型的变量`Whole`。</p>
</div>
<div class="paragraph">
<p>使用`is-factorion`sub，我使用该方法`comb`分解`$number`成数字，然后用`map`它们找到各自的阶乘并总结它们。子返回`True`if `$number`等于其数字的阶乘的总和。`False`否则返回。</p>
</div>
</div>
<div class="sect2">
<h3 id="_循环数">46.7. 循环数</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>循环数是具有<strong>N个</strong>数字的数字，当乘以时`1, 2, 3, &#8230;&#8203;, N`，以不同的顺序产生相同的数字。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">is-cyclic</span>( <span class="tok-nb">Int</span> <span class="tok-nv">$n</span> --&gt; <span class="tok-nb">Bool</span> ) {
    <span class="tok-k">for</span> <span class="tok-mi">1</span>..<span class="tok-nv">$n</span>.<span class="tok-nb">chars</span> -&gt; <span class="tok-nv">$d</span> {
        <span class="tok-k">return</span> <span class="tok-nb">False</span> <span class="tok-k">if</span> <span class="tok-nv">$n</span>.<span class="tok-nb">comb</span>.<span class="tok-nb">Bag</span> != (<span class="tok-nv">$n</span> * <span class="tok-nv">$d</span>).<span class="tok-nb">comb</span>.<span class="tok-nb">Bag</span>;
    }
    <span class="tok-k">return</span> <span class="tok-nb">True</span>;
}

<span class="tok-nb">say</span> <span class="tok-n">is-cyclic</span>(<span class="tok-mi">142857</span>); <span class="tok-c1"># True</span>
<span class="tok-nb">say</span> <span class="tok-n">is-cyclic</span>(<span class="tok-mi">95678</span>);  <span class="tok-c1"># False</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我创建了`is-cyclic`一个采用整数并返回布尔值的子程序。我使用`for`循环遍历数字位数（第1个，第2个等）并使用它们乘以每次迭代中的数字。然后我使用之前看到的`comb`方法，然后使用该`Bag`方法。在Perl 6中，a <code>Bag`是不同元素的不可变集合，没有特定顺序，其中每个元素按集合中的副本数加权。这是我需要的那种结构，因为只有数字的数字及其数量很重要，而不是它们的顺序，并且`Bag`完全实现了这一点。`False`如果行李不具有相同的数字或具有相同的数字但是加权不同，则子程序返回。除此以外，`True</code> 返回，表示数字的循环。</p>
</div>
</div>
<div class="sect2">
<h3 id="_快乐的数字">46.8. 快乐的数字</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>幸福数字由以下过程定义：从任何正整数开始，将数字替换为其在十进制数字中的数字的平方和，并重复该过程，直到该数字等于1（它将保留的位置），或者它在一个不包括1的循环中无休止地循环。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="perl6"><span></span><span class="tok-k">sub</span> <span class="tok-n">is-happy</span>( <span class="tok-nv">$n</span> <span class="tok-k">is</span> <span class="tok-k">copy</span> ) {
    <span class="tok-k">my</span> <span class="tok-nv">$seen-numbers</span> = :{};
    <span class="tok-k">while</span> <span class="tok-nv">$n</span> &gt; <span class="tok-mi">1</span> {
        <span class="tok-k">return</span> <span class="tok-nb">False</span> <span class="tok-k">if</span> <span class="tok-nv">$n</span> ∈ <span class="tok-nv">$seen-numbers</span>;
        <span class="tok-nv">$seen-numbers</span>{<span class="tok-nv">$n</span>} = <span class="tok-nb">True</span>;
        <span class="tok-nv">$n</span> = <span class="tok-nv">$n</span>.<span class="tok-nb">comb</span>.<span class="tok-nb">map</span>(*<span class="tok-n">²</span>).<span class="tok-nb">sum</span>
    }
    <span class="tok-k">return</span> <span class="tok-nb">True</span>;
}

<span class="tok-nb">say</span> <span class="tok-n">is-happy</span>(<span class="tok-mi">7</span>);     <span class="tok-c1"># True</span>
<span class="tok-nb">say</span> <span class="tok-n">is-happy</span>(<span class="tok-mi">2018</span>);  <span class="tok-c1"># False</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在完成定义中描述的过程之后，一个快乐的数字结束等于1.另一方面，一个非快乐的数字跟随一个到达循环的序列，该序列`4, 16, 37, 58, 89, 145, 42, 20, 4,…<code>不包括1.有了这个事实，我创建了散列</code>$seen-numbers`到跟踪这些数字。如while循环所示，该过程一次又一次地重复，同时`$n`大于1或直到看到数字。这里突出的线是包含符号∈的线。在集合论中，如果元素p是集合A的成员（或元素），则它由p∈A表示，这正是在此处测试的内容。如果数字`$n`是散列的元素，则子返回`False`。否则，它返回`True`，表示数字的幸福。</p>
</div>
</div>
<div class="sect2">
<h3 id="_摘要">46.9. 摘要</h3>
<div class="paragraph">
<p>在这篇文章中，我略微进行了逐步打字，如何定义一个新的运算符，使用`subset`关键字`set`和`bag`数据结构进行子类化。正如你可能已经意识到的那样，Perl 6 提供了许多可以促进许多不同任务的构造。在这种情况下，我希望以更加程序化的方式表达数字的定义。你可能会完全不同，但你可以放心，Perl 6 可以让你的工作更轻松，更有乐趣。</p>
</div>
<div class="paragraph">
<p>嗯&#8230;&#8203;&#8230;&#8203;这就是所有人！圣诞节快乐，新年快乐！</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-08-07 19:54:11 +0800
</div>
</div>
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments  { background: #f8f8f8; }
pre.pygments .tok-c { color: #408080; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #B00040 } /* Keyword.Type */
pre.pygments .tok-m { color: #666666 } /* Literal.Number */
pre.pygments .tok-s { color: #BA2121 } /* Literal.String */
pre.pygments .tok-na { color: #7D9029 } /* Name.Attribute */
pre.pygments .tok-nb { color: #008000 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #880000 } /* Name.Constant */
pre.pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
pre.pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0000FF } /* Name.Function */
pre.pygments .tok-nl { color: #A0A000 } /* Name.Label */
pre.pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #19177C } /* Name.Variable */
pre.pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
pre.pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #008000 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</body>
</html>